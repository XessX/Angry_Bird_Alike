        -:    0:Source:/Users/jubair/CLionProjects/untitled/test/catch.hh
        -:    0:Graph:./CMakeFiles/test_run.dir/test/gameTest.cpp.gcno
        -:    0:Data:./CMakeFiles/test_run.dir/test/gameTest.cpp.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:
        -:    2://              Copyright Catch2 Authors
        -:    3:// Distributed under the Boost Software License, Version 1.0.
        -:    4://   (See accompanying file LICENSE.txt or copy at
        -:    5://        https://www.boost.org/LICENSE_1_0.txt)
        -:    6:
        -:    7:// SPDX-License-Identifier: BSL-1.0
        -:    8:
        -:    9://  Catch v3.5.3
        -:   10://  Generated: 2024-03-01 22:05:55.031514
        -:   11://  ----------------------------------------------------------
        -:   12://  This file is an amalgamation of multiple different files.
        -:   13://  You probably shouldn't edit it directly.
        -:   14://  ----------------------------------------------------------
        -:   15:#ifndef CATCH_AMALGAMATED_HPP_INCLUDED
        -:   16:#define CATCH_AMALGAMATED_HPP_INCLUDED
        -:   17:
        -:   18:
        -:   19:/** \file
        -:   20: * This is a convenience header for Catch2. It includes **all** of Catch2 headers.
        -:   21: *
        -:   22: * Generally the Catch2 users should use specific includes they need,
        -:   23: * but this header can be used instead for ease-of-experimentation, or
        -:   24: * just plain convenience, at the cost of (significantly) increased
        -:   25: * compilation times.
        -:   26: *
        -:   27: * When a new header is added to either the top level folder, or to the
        -:   28: * corresponding internal subfolder, it should be added here. Headers
        -:   29: * added to the various subparts (e.g. matchers, generators, etc...),
        -:   30: * should go their respective catch-all headers.
        -:   31: */
        -:   32:
        -:   33:#ifndef CATCH_ALL_HPP_INCLUDED
        -:   34:#define CATCH_ALL_HPP_INCLUDED
        -:   35:
        -:   36:
        -:   37:
        -:   38:/** \file
        -:   39: * This is a convenience header for Catch2's benchmarking. It includes
        -:   40: * **all** of Catch2 headers related to benchmarking.
        -:   41: *
        -:   42: * Generally the Catch2 users should use specific includes they need,
        -:   43: * but this header can be used instead for ease-of-experimentation, or
        -:   44: * just plain convenience, at the cost of (significantly) increased
        -:   45: * compilation times.
        -:   46: *
        -:   47: * When a new header is added to either the `benchmark` folder, or to
        -:   48: * the corresponding internal (detail) subfolder, it should be added here.
        -:   49: */
        -:   50:
        -:   51:#ifndef CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -:   52:#define CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -:   53:
        -:   54:
        -:   55:
        -:   56:// Adapted from donated nonius code.
        -:   57:
        -:   58:#ifndef CATCH_BENCHMARK_HPP_INCLUDED
        -:   59:#define CATCH_BENCHMARK_HPP_INCLUDED
        -:   60:
        -:   61:
        -:   62:
        -:   63:#ifndef CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:   64:#define CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:   65:
        -:   66:// Detect a number of compiler features - by compiler
        -:   67:// The following features are defined:
        -:   68://
        -:   69:// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
        -:   70:// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
        -:   71:// CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?
        -:   72:// ****************
        -:   73:// Note to maintainers: if new toggles are added please document them
        -:   74:// in configuration.md, too
        -:   75:// ****************
        -:   76:
        -:   77:// In general each macro has a _NO_<feature name> form
        -:   78:// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
        -:   79:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -:   80:// can be combined, en-mass, with the _NO_ forms later.
        -:   81:
        -:   82:
        -:   83:
        -:   84:#ifndef CATCH_PLATFORM_HPP_INCLUDED
        -:   85:#define CATCH_PLATFORM_HPP_INCLUDED
        -:   86:
        -:   87:// See e.g.:
        -:   88:// https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-18.1/TargetConditionals.h.auto.html
        -:   89:#ifdef __APPLE__
        -:   90:#  include <TargetConditionals.h>
        -:   91:#  if (defined(TARGET_OS_OSX) && TARGET_OS_OSX == 1) || \
        -:   92:      (defined(TARGET_OS_MAC) && TARGET_OS_MAC == 1)
        -:   93:#    define CATCH_PLATFORM_MAC
        -:   94:#  elif (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE == 1)
        -:   95:#    define CATCH_PLATFORM_IPHONE
        -:   96:#  endif
        -:   97:
        -:   98:#elif defined(linux) || defined(__linux) || defined(__linux__)
        -:   99:#  define CATCH_PLATFORM_LINUX
        -:  100:
        -:  101:#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
        -:  102:#  define CATCH_PLATFORM_WINDOWS
        -:  103:
        -:  104:#  if defined( WINAPI_FAMILY ) && ( WINAPI_FAMILY == WINAPI_FAMILY_APP )
        -:  105:#      define CATCH_PLATFORM_WINDOWS_UWP
        -:  106:#  endif
        -:  107:
        -:  108:#elif defined(__ORBIS__) || defined(__PROSPERO__)
        -:  109:#  define CATCH_PLATFORM_PLAYSTATION
        -:  110:
        -:  111:#endif
        -:  112:
        -:  113:#endif // CATCH_PLATFORM_HPP_INCLUDED
        -:  114:
        -:  115:#ifdef __cplusplus
        -:  116:
        -:  117:#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
        -:  118:#    define CATCH_CPP17_OR_GREATER
        -:  119:#  endif
        -:  120:
        -:  121:#  if (__cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)
        -:  122:#    define CATCH_CPP20_OR_GREATER
        -:  123:#  endif
        -:  124:
        -:  125:#endif
        -:  126:
        -:  127:// Only GCC compiler should be used in this block, so other compilers trying to
        -:  128:// mask themselves as GCC should be ignored.
        -:  129:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && !defined(__CUDACC__) && !defined(__LCC__) && !defined(__NVCOMPILER)
        -:  130:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )
        -:  131:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )
        -:  132:
        -:  133:// This only works on GCC 9+. so we have to also add a global suppression of Wparentheses
        -:  134:// for older versions of GCC.
        -:  135:#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  136:         _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
        -:  137:
        -:  138:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \
        -:  139:         _Pragma( "GCC diagnostic ignored \"-Wunused-result\"" )
        -:  140:
        -:  141:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -:  142:         _Pragma( "GCC diagnostic ignored \"-Wunused-variable\"" )
        -:  143:
        -:  144:#    define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \
        -:  145:         _Pragma( "GCC diagnostic ignored \"-Wuseless-cast\"" )
        -:  146:
        -:  147:#    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \
        -:  148:         _Pragma( "GCC diagnostic ignored \"-Wshadow\"" )
        -:  149:
        -:  150:#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)
        -:  151:
        -:  152:#endif
        -:  153:
        -:  154:#if defined(__NVCOMPILER)
        -:  155:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "diag push" )
        -:  156:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "diag pop" )
        -:  157:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress declared_but_not_referenced" )
        -:  158:#endif
        -:  159:
        -:  160:#if defined(__CUDACC__) && !defined(__clang__)
        -:  161:#  ifdef __NVCC_DIAG_PRAGMA_SUPPORT__
        -:  162:// New pragmas introduced in CUDA 11.5+
        -:  163:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "nv_diagnostic push" )
        -:  164:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "nv_diagnostic pop" )
        -:  165:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "nv_diag_suppress 177" )
        -:  166:#  else
        -:  167:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS _Pragma( "diag_suppress 177" )
        -:  168:#  endif
        -:  169:#endif
        -:  170:
        -:  171:// clang-cl defines _MSC_VER as well as __clang__, which could cause the
        -:  172:// start/stop internal suppression macros to be double defined.
        -:  173:#if defined(__clang__) && !defined(_MSC_VER)
        -:  174:
        -:  175:#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )
        -:  176:#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )
        -:  177:
        -:  178:#endif // __clang__ && !_MSC_VER
        -:  179:
        -:  180:#if defined(__clang__)
        -:  181:
        -:  182:// As of this writing, IBM XL's implementation of __builtin_constant_p has a bug
        -:  183:// which results in calls to destructors being emitted for each temporary,
        -:  184:// without a matching initialization. In practice, this can result in something
        -:  185:// like `std::string::~string` being called on an uninitialized value.
        -:  186://
        -:  187:// For example, this code will likely segfault under IBM XL:
        -:  188:// ```
        -:  189:// REQUIRE(std::string("12") + "34" == "1234")
        -:  190:// ```
        -:  191://
        -:  192:// Similarly, NVHPC's implementation of `__builtin_constant_p` has a bug which
        -:  193:// results in calls to the immediately evaluated lambda expressions to be
        -:  194:// reported as unevaluated lambdas.
        -:  195:// https://developer.nvidia.com/nvidia_bug/3321845.
        -:  196://
        -:  197:// Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.
        -:  198:#  if !defined(__ibmxl__) && !defined(__CUDACC__) && !defined( __NVCOMPILER )
        -:  199:#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) /* NOLINT(cppcoreguidelines-pro-type-vararg, hicpp-vararg) */
        -:  200:#  endif
        -:  201:
        -:  202:
        -:  203:#    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -:  204:         _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
        -:  205:         _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")
        -:  206:
        -:  207:#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  208:         _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
        -:  209:
        -:  210:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -:  211:         _Pragma( "clang diagnostic ignored \"-Wunused-variable\"" )
        -:  212:
        -:  213:#    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -:  214:         _Pragma( "clang diagnostic ignored \"-Wgnu-zero-variadic-macro-arguments\"" )
        -:  215:
        -:  216:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -:  217:         _Pragma( "clang diagnostic ignored \"-Wunused-template\"" )
        -:  218:
        -:  219:#    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \
        -:  220:        _Pragma( "clang diagnostic ignored \"-Wcomma\"" )
        -:  221:
        -:  222:#    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS \
        -:  223:        _Pragma( "clang diagnostic ignored \"-Wshadow\"" )
        -:  224:
        -:  225:#endif // __clang__
        -:  226:
        -:  227:
        -:  228:////////////////////////////////////////////////////////////////////////////////
        -:  229:// We know some environments not to support full POSIX signals
        -:  230:#if defined( CATCH_PLATFORM_WINDOWS ) ||                                       \
        -:  231:    defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \
        -:  232:    defined( __CYGWIN__ ) ||                                                   \
        -:  233:    defined( __QNX__ ) ||                                                      \
        -:  234:    defined( __EMSCRIPTEN__ ) ||                                               \
        -:  235:    defined( __DJGPP__ ) ||                                                    \
        -:  236:    defined( __OS400__ )
        -:  237:#    define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  238:#else
        -:  239:#    define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
        -:  240:#endif
        -:  241:
        -:  242:////////////////////////////////////////////////////////////////////////////////
        -:  243:// Assume that some platforms do not support getenv.
        -:  244:#if defined( CATCH_PLATFORM_WINDOWS_UWP ) ||                                   \
        -:  245:    defined( CATCH_PLATFORM_PLAYSTATION ) ||                                   \
        -:  246:    defined( _GAMING_XBOX )
        -:  247:#    define CATCH_INTERNAL_CONFIG_NO_GETENV
        -:  248:#else
        -:  249:#    define CATCH_INTERNAL_CONFIG_GETENV
        -:  250:#endif
        -:  251:
        -:  252:////////////////////////////////////////////////////////////////////////////////
        -:  253:// Android somehow still does not support std::to_string
        -:  254:#if defined(__ANDROID__)
        -:  255:#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
        -:  256:#endif
        -:  257:
        -:  258:////////////////////////////////////////////////////////////////////////////////
        -:  259:// Not all Windows environments support SEH properly
        -:  260:#if defined(__MINGW32__)
        -:  261:#    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
        -:  262:#endif
        -:  263:
        -:  264:////////////////////////////////////////////////////////////////////////////////
        -:  265:// PS4
        -:  266:#if defined(__ORBIS__)
        -:  267:#    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
        -:  268:#endif
        -:  269:
        -:  270:////////////////////////////////////////////////////////////////////////////////
        -:  271:// Cygwin
        -:  272:#ifdef __CYGWIN__
        -:  273:
        -:  274:// Required for some versions of Cygwin to declare gettimeofday
        -:  275:// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
        -:  276:#   define _BSD_SOURCE
        -:  277:// some versions of cygwin (most) do not support std::to_string. Use the libstd check.
        -:  278:// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813
        -:  279:# if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \
        -:  280:           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
        -:  281:
        -:  282:#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
        -:  283:
        -:  284:# endif
        -:  285:#endif // __CYGWIN__
        -:  286:
        -:  287:////////////////////////////////////////////////////////////////////////////////
        -:  288:// Visual C++
        -:  289:#if defined(_MSC_VER)
        -:  290:
        -:  291:// We want to defer to nvcc-specific warning suppression if we are compiled
        -:  292:// with nvcc masquerading for MSVC.
        -:  293:#    if !defined( __CUDACC__ )
        -:  294:#        define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -:  295:            __pragma( warning( push ) )
        -:  296:#        define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -:  297:            __pragma( warning( pop ) )
        -:  298:#    endif
        -:  299:
        -:  300:// Universal Windows platform does not support SEH
        -:  301:// Or console colours (or console at all...)
        -:  302:#  if defined(CATCH_PLATFORM_WINDOWS_UWP)
        -:  303:#    define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32
        -:  304:#  else
        -:  305:#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
        -:  306:#  endif
        -:  307:
        -:  308:// MSVC traditional preprocessor needs some workaround for __VA_ARGS__
        -:  309:// _MSVC_TRADITIONAL == 0 means new conformant preprocessor
        -:  310:// _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor
        -:  311:#  if !defined(__clang__) // Handle Clang masquerading for msvc
        -:  312:#    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)
        -:  313:#      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -:  314:#    endif // MSVC_TRADITIONAL
        -:  315:#  endif // __clang__
        -:  316:
        -:  317:#endif // _MSC_VER
        -:  318:
        -:  319:#if defined(_REENTRANT) || defined(_MSC_VER)
        -:  320:// Enable async processing, as -pthread is specified or no additional linking is required
        -:  321:# define CATCH_INTERNAL_CONFIG_USE_ASYNC
        -:  322:#endif // _MSC_VER
        -:  323:
        -:  324:////////////////////////////////////////////////////////////////////////////////
        -:  325:// Check if we are compiled with -fno-exceptions or equivalent
        -:  326:#if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
        -:  327:#  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
        -:  328:#endif
        -:  329:
        -:  330:
        -:  331:////////////////////////////////////////////////////////////////////////////////
        -:  332:// Embarcadero C++Build
        -:  333:#if defined(__BORLANDC__)
        -:  334:    #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
        -:  335:#endif
        -:  336:
        -:  337:////////////////////////////////////////////////////////////////////////////////
        -:  338:
        -:  339:// RTX is a special version of Windows that is real time.
        -:  340:// This means that it is detected as Windows, but does not provide
        -:  341:// the same set of capabilities as real Windows does.
        -:  342:#if defined(UNDER_RTSS) || defined(RTX64_BUILD)
        -:  343:    #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
        -:  344:    #define CATCH_INTERNAL_CONFIG_NO_ASYNC
        -:  345:    #define CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32
        -:  346:#endif
        -:  347:
        -:  348:#if !defined(_GLIBCXX_USE_C99_MATH_TR1)
        -:  349:#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
        -:  350:#endif
        -:  351:
        -:  352:// Various stdlib support checks that require __has_include
        -:  353:#if defined(__has_include)
        -:  354:  // Check if string_view is available and usable
        -:  355:  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
        -:  356:  #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
        -:  357:  #endif
        -:  358:
        -:  359:  // Check if optional is available and usable
        -:  360:  #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
        -:  361:  #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
        -:  362:  #  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
        -:  363:
        -:  364:  // Check if byte is available and usable
        -:  365:  #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
        -:  366:  #    include <cstddef>
        -:  367:  #    if defined(__cpp_lib_byte) && (__cpp_lib_byte > 0)
        -:  368:  #      define CATCH_INTERNAL_CONFIG_CPP17_BYTE
        -:  369:  #    endif
        -:  370:  #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
        -:  371:
        -:  372:  // Check if variant is available and usable
        -:  373:  #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
        -:  374:  #    if defined(__clang__) && (__clang_major__ < 8)
        -:  375:         // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
        -:  376:         // fix should be in clang 8, workaround in libstdc++ 8.2
        -:  377:  #      include <ciso646>
        -:  378:  #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
        -:  379:  #        define CATCH_CONFIG_NO_CPP17_VARIANT
        -:  380:  #      else
        -:  381:  #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
        -:  382:  #      endif // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
        -:  383:  #    else
        -:  384:  #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
        -:  385:  #    endif // defined(__clang__) && (__clang_major__ < 8)
        -:  386:  #  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
        -:  387:#endif // defined(__has_include)
        -:  388:
        -:  389:
        -:  390:#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
        -:  391:#   define CATCH_CONFIG_WINDOWS_SEH
        -:  392:#endif
        -:  393:// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
        -:  394:#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -:  395:#   define CATCH_CONFIG_POSIX_SIGNALS
        -:  396:#endif
        -:  397:
        -:  398:#if defined(CATCH_INTERNAL_CONFIG_GETENV) && !defined(CATCH_INTERNAL_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_NO_GETENV) && !defined(CATCH_CONFIG_GETENV)
        -:  399:#   define CATCH_CONFIG_GETENV
        -:  400:#endif
        -:  401:
        -:  402:#if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)
        -:  403:#    define CATCH_CONFIG_CPP11_TO_STRING
        -:  404:#endif
        -:  405:
        -:  406:#if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)
        -:  407:#  define CATCH_CONFIG_CPP17_OPTIONAL
        -:  408:#endif
        -:  409:
        -:  410:#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
        -:  411:#  define CATCH_CONFIG_CPP17_STRING_VIEW
        -:  412:#endif
        -:  413:
        -:  414:#if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)
        -:  415:#  define CATCH_CONFIG_CPP17_VARIANT
        -:  416:#endif
        -:  417:
        -:  418:#if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)
        -:  419:#  define CATCH_CONFIG_CPP17_BYTE
        -:  420:#endif
        -:  421:
        -:  422:
        -:  423:#if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
        -:  424:#  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
        -:  425:#endif
        -:  426:
        -:  427:#if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)
        -:  428:#  define CATCH_CONFIG_NEW_CAPTURE
        -:  429:#endif
        -:  430:
        -:  431:#if !defined( CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED ) && \
        -:  432:    !defined( CATCH_CONFIG_DISABLE_EXCEPTIONS ) &&          \
        -:  433:    !defined( CATCH_CONFIG_NO_DISABLE_EXCEPTIONS )
        -:  434:#  define CATCH_CONFIG_DISABLE_EXCEPTIONS
        -:  435:#endif
        -:  436:
        -:  437:#if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)
        -:  438:#  define CATCH_CONFIG_POLYFILL_ISNAN
        -:  439:#endif
        -:  440:
        -:  441:#if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)
        -:  442:#  define CATCH_CONFIG_USE_ASYNC
        -:  443:#endif
        -:  444:
        -:  445:#if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
        -:  446:#  define CATCH_CONFIG_GLOBAL_NEXTAFTER
        -:  447:#endif
        -:  448:
        -:  449:
        -:  450:// Even if we do not think the compiler has that warning, we still have
        -:  451:// to provide a macro that can be used by the code.
        -:  452:#if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
        -:  453:#   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
        -:  454:#endif
        -:  455:#if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
        -:  456:#   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:  457:#endif
        -:  458:#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
        -:  459:#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
        -:  460:#endif
        -:  461:#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
        -:  462:#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
        -:  463:#endif
        -:  464:#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT)
        -:  465:#   define CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT
        -:  466:#endif
        -:  467:#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS)
        -:  468:#   define CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS
        -:  469:#endif
        -:  470:#if !defined(CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS)
        -:  471:#   define CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS
        -:  472:#endif
        -:  473:#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
        -:  474:#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
        -:  475:#endif
        -:  476:#if !defined( CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS )
        -:  477:#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  478:#endif
        -:  479:#if !defined( CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS )
        -:  480:#    define CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS
        -:  481:#endif
        -:  482:#if !defined( CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS )
        -:  483:#    define CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS
        -:  484:#endif
        -:  485:
        -:  486:
        -:  487:// The goal of this macro is to avoid evaluation of the arguments, but
        -:  488:// still have the compiler warn on problems inside...
        -:  489:#if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
        -:  490:#   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
        -:  491:#endif
        -:  492:
        -:  493:#if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)
        -:  494:#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  495:#elif defined(__clang__) && (__clang_major__ < 5)
        -:  496:#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
        -:  497:#endif
        -:  498:
        -:  499:
        -:  500:#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -:  501:#define CATCH_TRY if ((true))
        -:  502:#define CATCH_CATCH_ALL if ((false))
        -:  503:#define CATCH_CATCH_ANON(type) if ((false))
        -:  504:#else
        -:  505:#define CATCH_TRY try
        -:  506:#define CATCH_CATCH_ALL catch (...)
        -:  507:#define CATCH_CATCH_ANON(type) catch (type)
        -:  508:#endif
        -:  509:
        -:  510:#if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
        -:  511:#define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -:  512:#endif
        -:  513:
        -:  514:#if defined( CATCH_PLATFORM_WINDOWS ) &&       \
        -:  515:    !defined( CATCH_CONFIG_COLOUR_WIN32 ) && \
        -:  516:    !defined( CATCH_CONFIG_NO_COLOUR_WIN32 ) && \
        -:  517:    !defined( CATCH_INTERNAL_CONFIG_NO_COLOUR_WIN32 )
        -:  518:#    define CATCH_CONFIG_COLOUR_WIN32
        -:  519:#endif
        -:  520:
        -:  521:#if defined( CATCH_CONFIG_SHARED_LIBRARY ) && defined( _MSC_VER ) && \
        -:  522:    !defined( CATCH_CONFIG_STATIC )
        -:  523:#    ifdef Catch2_EXPORTS
        -:  524:#        define CATCH_EXPORT //__declspec( dllexport ) // not needed
        -:  525:#    else
        -:  526:#        define CATCH_EXPORT __declspec( dllimport )
        -:  527:#    endif
        -:  528:#else
        -:  529:#    define CATCH_EXPORT
        -:  530:#endif
        -:  531:
        -:  532:#endif // CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:  533:
        -:  534:
        -:  535:#ifndef CATCH_CONTEXT_HPP_INCLUDED
        -:  536:#define CATCH_CONTEXT_HPP_INCLUDED
        -:  537:
        -:  538:
        -:  539:namespace Catch {
        -:  540:
        -:  541:    class IResultCapture;
        -:  542:    class IConfig;
        -:  543:
        -:  544:    class Context {
        -:  545:        IConfig const* m_config = nullptr;
        -:  546:        IResultCapture* m_resultCapture = nullptr;
        -:  547:
        -:  548:        CATCH_EXPORT static Context* currentContext;
        -:  549:        friend Context& getCurrentMutableContext();
        -:  550:        friend Context const& getCurrentContext();
        -:  551:        static void createContext();
        -:  552:        friend void cleanUpContext();
        -:  553:
        -:  554:    public:
        -:  555:        IResultCapture* getResultCapture() const { return m_resultCapture; }
        -:  556:        IConfig const* getConfig() const { return m_config; }
        -:  557:        void setResultCapture( IResultCapture* resultCapture );
        -:  558:        void setConfig( IConfig const* config );
        -:  559:    };
        -:  560:
        -:  561:    Context& getCurrentMutableContext();
        -:  562:
        -:  563:    inline Context const& getCurrentContext() {
        -:  564:        // We duplicate the logic from `getCurrentMutableContext` here,
        -:  565:        // to avoid paying the call overhead in debug mode.
        -:  566:        if ( !Context::currentContext ) { Context::createContext(); }
        -:  567:        // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
        -:  568:        return *Context::currentContext;
        -:  569:    }
        -:  570:
        -:  571:    void cleanUpContext();
        -:  572:
        -:  573:    class SimplePcg32;
        -:  574:    SimplePcg32& sharedRng();
        -:  575:}
        -:  576:
        -:  577:#endif // CATCH_CONTEXT_HPP_INCLUDED
        -:  578:
        -:  579:
        -:  580:#ifndef CATCH_MOVE_AND_FORWARD_HPP_INCLUDED
        -:  581:#define CATCH_MOVE_AND_FORWARD_HPP_INCLUDED
        -:  582:
        -:  583:#include <type_traits>
        -:  584:
        -:  585://! Replacement for std::move with better compile time performance
        -:  586:#define CATCH_MOVE(...) static_cast<std::remove_reference_t<decltype(__VA_ARGS__)>&&>(__VA_ARGS__)
        -:  587:
        -:  588://! Replacement for std::forward with better compile time performance
        -:  589:#define CATCH_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
        -:  590:
        -:  591:#endif // CATCH_MOVE_AND_FORWARD_HPP_INCLUDED
        -:  592:
        -:  593:
        -:  594:#ifndef CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED
        -:  595:#define CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED
        -:  596:
        -:  597:namespace Catch {
        -:  598:
        -:  599:    //! Used to signal that an assertion macro failed
        -:  600:    struct TestFailureException{};
        -:  601:    //! Used to signal that the remainder of a test should be skipped
        -:  602:    struct TestSkipException {};
        -:  603:
        -:  604:    /**
        -:  605:     * Outlines throwing of `TestFailureException` into a single TU
        -:  606:     *
        -:  607:     * Also handles `CATCH_CONFIG_DISABLE_EXCEPTIONS` for callers.
        -:  608:     */
        -:  609:    [[noreturn]] void throw_test_failure_exception();
        -:  610:
        -:  611:    /**
        -:  612:     * Outlines throwing of `TestSkipException` into a single TU
        -:  613:     *
        -:  614:     * Also handles `CATCH_CONFIG_DISABLE_EXCEPTIONS` for callers.
        -:  615:     */
        -:  616:    [[noreturn]] void throw_test_skip_exception();
        -:  617:
        -:  618:} // namespace Catch
        -:  619:
        -:  620:#endif // CATCH_TEST_FAILURE_EXCEPTION_HPP_INCLUDED
        -:  621:
        -:  622:
        -:  623:#ifndef CATCH_UNIQUE_NAME_HPP_INCLUDED
        -:  624:#define CATCH_UNIQUE_NAME_HPP_INCLUDED
        -:  625:
        -:  626:
        -:  627:
        -:  628:
        -:  629:/** \file
        -:  630: * Wrapper for the CONFIG configuration option
        -:  631: *
        -:  632: * When generating internal unique names, there are two options. Either
        -:  633: * we mix in the current line number, or mix in an incrementing number.
        -:  634: * We prefer the latter, using `__COUNTER__`, but users might want to
        -:  635: * use the former.
        -:  636: */
        -:  637:
        -:  638:#ifndef CATCH_CONFIG_COUNTER_HPP_INCLUDED
        -:  639:#define CATCH_CONFIG_COUNTER_HPP_INCLUDED
        -:  640:
        -:  641:
        -:  642:#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
        -:  643:    #define CATCH_INTERNAL_CONFIG_COUNTER
        -:  644:#endif
        -:  645:
        -:  646:#if defined( CATCH_INTERNAL_CONFIG_COUNTER ) && \
        -:  647:    !defined( CATCH_CONFIG_NO_COUNTER ) && \
        -:  648:    !defined( CATCH_CONFIG_COUNTER )
        -:  649:#    define CATCH_CONFIG_COUNTER
        -:  650:#endif
        -:  651:
        -:  652:
        -:  653:#endif // CATCH_CONFIG_COUNTER_HPP_INCLUDED
        -:  654:#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
        -:  655:#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
        -:  656:#ifdef CATCH_CONFIG_COUNTER
        -:  657:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
        -:  658:#else
        -:  659:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
        -:  660:#endif
        -:  661:
        -:  662:#endif // CATCH_UNIQUE_NAME_HPP_INCLUDED
        -:  663:
        -:  664:
        -:  665:#ifndef CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -:  666:#define CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -:  667:
        -:  668:#include <string>
        -:  669:#include <chrono>
        -:  670:
        -:  671:
        -:  672:
        -:  673:#ifndef CATCH_STRINGREF_HPP_INCLUDED
        -:  674:#define CATCH_STRINGREF_HPP_INCLUDED
        -:  675:
        -:  676:#include <cstddef>
        -:  677:#include <string>
        -:  678:#include <iosfwd>
        -:  679:#include <cassert>
        -:  680:
        -:  681:#include <cstring>
        -:  682:
        -:  683:namespace Catch {
        -:  684:
        -:  685:    /// A non-owning string class (similar to the forthcoming std::string_view)
        -:  686:    /// Note that, because a StringRef may be a substring of another string,
        -:  687:    /// it may not be null terminated.
        -:  688:    class StringRef {
        -:  689:    public:
        -:  690:        using size_type = std::size_t;
        -:  691:        using const_iterator = const char*;
        -:  692:
        -:  693:        static constexpr size_type npos{ static_cast<size_type>( -1 ) };
        -:  694:
        -:  695:    private:
        -:  696:        static constexpr char const* const s_empty = "";
        -:  697:
      169:  698:        char const* m_start = s_empty;
      169:  699:        size_type m_size = 0;
        -:  700:
        -:  701:    public: // construction
      507:  702:        constexpr StringRef() noexcept = default;
        -:  703:
        -:  704:        StringRef( char const* rawChars ) noexcept;
        -:  705:
     1434:  706:        constexpr StringRef( char const* rawChars, size_type size ) noexcept
      717:  707:        :   m_start( rawChars ),
      717:  708:            m_size( size )
     1434:  709:        {}
        -:  710:
        -:  711:        StringRef( std::string const& stdString ) noexcept
        -:  712:        :   m_start( stdString.c_str() ),
        -:  713:            m_size( stdString.size() )
        -:  714:        {}
        -:  715:
        -:  716:        explicit operator std::string() const {
        -:  717:            return std::string(m_start, m_size);
        -:  718:        }
        -:  719:
        -:  720:    public: // operators
        -:  721:        auto operator == ( StringRef other ) const noexcept -> bool {
        -:  722:            return m_size == other.m_size
        -:  723:                && (std::memcmp( m_start, other.m_start, m_size ) == 0);
        -:  724:        }
        -:  725:        auto operator != (StringRef other) const noexcept -> bool {
        -:  726:            return !(*this == other);
        -:  727:        }
        -:  728:
        -:  729:        constexpr auto operator[] ( size_type index ) const noexcept -> char {
        -:  730:            assert(index < m_size);
        -:  731:            return m_start[index];
        -:  732:        }
        -:  733:
        -:  734:        bool operator<(StringRef rhs) const noexcept;
        -:  735:
        -:  736:    public: // named queries
        -:  737:        constexpr auto empty() const noexcept -> bool {
        -:  738:            return m_size == 0;
        -:  739:        }
        -:  740:        constexpr auto size() const noexcept -> size_type {
        -:  741:            return m_size;
        -:  742:        }
        -:  743:
        -:  744:        // Returns a substring of [start, start + length).
        -:  745:        // If start + length > size(), then the substring is [start, size()).
        -:  746:        // If start > size(), then the substring is empty.
        -:  747:        constexpr StringRef substr(size_type start, size_type length) const noexcept {
        -:  748:            if (start < m_size) {
        -:  749:                const auto shortened_size = m_size - start;
        -:  750:                return StringRef(m_start + start, (shortened_size < length) ? shortened_size : length);
        -:  751:            } else {
        -:  752:                return StringRef();
        -:  753:            }
        -:  754:        }
        -:  755:
        -:  756:        // Returns the current start pointer. May not be null-terminated.
        -:  757:        constexpr char const* data() const noexcept {
        -:  758:            return m_start;
        -:  759:        }
        -:  760:
        -:  761:        constexpr const_iterator begin() const { return m_start; }
        -:  762:        constexpr const_iterator end() const { return m_start + m_size; }
        -:  763:
        -:  764:
        -:  765:        friend std::string& operator += (std::string& lhs, StringRef rhs);
        -:  766:        friend std::ostream& operator << (std::ostream& os, StringRef str);
        -:  767:        friend std::string operator+(StringRef lhs, StringRef rhs);
        -:  768:
        -:  769:        /**
        -:  770:         * Provides a three-way comparison with rhs
        -:  771:         *
        -:  772:         * Returns negative number if lhs < rhs, 0 if lhs == rhs, and a positive
        -:  773:         * number if lhs > rhs
        -:  774:         */
        -:  775:        int compare( StringRef rhs ) const;
        -:  776:    };
        -:  777:
        -:  778:
      230:  779:    constexpr auto operator ""_sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
      230:  780:        return StringRef( rawChars, size );
        -:  781:    }
        -:  782:} // namespace Catch
        -:  783:
       40:  784:constexpr auto operator ""_catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
       40:  785:    return Catch::StringRef( rawChars, size );
        -:  786:}
        -:  787:
        -:  788:#endif // CATCH_STRINGREF_HPP_INCLUDED
        -:  789:
        -:  790:
        -:  791:#ifndef CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  792:#define CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  793:
        -:  794:namespace Catch {
        -:  795:
        -:  796:    // ResultWas::OfType enum
        -:  797:    struct ResultWas { enum OfType {
        -:  798:        Unknown = -1,
        -:  799:        Ok = 0,
        -:  800:        Info = 1,
        -:  801:        Warning = 2,
        -:  802:        // TODO: Should explicit skip be considered "not OK" (cf. isOk)? I.e., should it have the failure bit?
        -:  803:        ExplicitSkip = 4,
        -:  804:
        -:  805:        FailureBit = 0x10,
        -:  806:
        -:  807:        ExpressionFailed = FailureBit | 1,
        -:  808:        ExplicitFailure = FailureBit | 2,
        -:  809:
        -:  810:        Exception = 0x100 | FailureBit,
        -:  811:
        -:  812:        ThrewException = Exception | 1,
        -:  813:        DidntThrowException = Exception | 2,
        -:  814:
        -:  815:        FatalErrorCondition = 0x200 | FailureBit
        -:  816:
        -:  817:    }; };
        -:  818:
        -:  819:    bool isOk( ResultWas::OfType resultType );
        -:  820:    bool isJustInfo( int flags );
        -:  821:
        -:  822:
        -:  823:    // ResultDisposition::Flags enum
        -:  824:    struct ResultDisposition { enum Flags {
        -:  825:        Normal = 0x01,
        -:  826:
        -:  827:        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        -:  828:        FalseTest = 0x04,           // Prefix expression with !
        -:  829:        SuppressFail = 0x08         // Failures are reported but do not fail the test
        -:  830:    }; };
        -:  831:
        -:  832:    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
        -:  833:
        -:  834:    bool shouldContinueOnFailure( int flags );
        -:  835:    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
        -:  836:    bool shouldSuppressFailure( int flags );
        -:  837:
        -:  838:} // end namespace Catch
        -:  839:
        -:  840:#endif // CATCH_RESULT_TYPE_HPP_INCLUDED
        -:  841:
        -:  842:
        -:  843:#ifndef CATCH_UNIQUE_PTR_HPP_INCLUDED
        -:  844:#define CATCH_UNIQUE_PTR_HPP_INCLUDED
        -:  845:
        -:  846:#include <cassert>
        -:  847:#include <type_traits>
        -:  848:
        -:  849:
        -:  850:namespace Catch {
        -:  851:namespace Detail {
        -:  852:    /**
        -:  853:     * A reimplementation of `std::unique_ptr` for improved compilation performance
        -:  854:     *
        -:  855:     * Does not support arrays nor custom deleters.
        -:  856:     */
        -:  857:    template <typename T>
        -:  858:    class unique_ptr {
        -:  859:        T* m_ptr;
        -:  860:    public:
        -:  861:        constexpr unique_ptr(std::nullptr_t = nullptr):
        -:  862:            m_ptr{}
        -:  863:        {}
        -:  864:        explicit constexpr unique_ptr(T* ptr):
        -:  865:            m_ptr(ptr)
        -:  866:        {}
        -:  867:
        -:  868:        template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>
        -:  869:        unique_ptr(unique_ptr<U>&& from):
        -:  870:            m_ptr(from.release())
        -:  871:        {}
        -:  872:
        -:  873:        template <typename U, typename = std::enable_if_t<std::is_base_of<T, U>::value>>
        -:  874:        unique_ptr& operator=(unique_ptr<U>&& from) {
        -:  875:            reset(from.release());
        -:  876:
        -:  877:            return *this;
        -:  878:        }
        -:  879:
        -:  880:        unique_ptr(unique_ptr const&) = delete;
        -:  881:        unique_ptr& operator=(unique_ptr const&) = delete;
        -:  882:
        -:  883:        unique_ptr(unique_ptr&& rhs) noexcept:
        -:  884:            m_ptr(rhs.m_ptr) {
        -:  885:            rhs.m_ptr = nullptr;
        -:  886:        }
        -:  887:        unique_ptr& operator=(unique_ptr&& rhs) noexcept {
        -:  888:            reset(rhs.release());
        -:  889:
        -:  890:            return *this;
        -:  891:        }
        -:  892:
      124:  893:        ~unique_ptr() {
       62:  894:            delete m_ptr;
      124:  895:        }
        -:  896:
        -:  897:        T& operator*() {
        -:  898:            assert(m_ptr);
        -:  899:            return *m_ptr;
        -:  900:        }
        -:  901:        T const& operator*() const {
        -:  902:            assert(m_ptr);
        -:  903:            return *m_ptr;
        -:  904:        }
        -:  905:        T* operator->() noexcept {
        -:  906:            assert(m_ptr);
        -:  907:            return m_ptr;
        -:  908:        }
        -:  909:        T const* operator->() const noexcept {
        -:  910:            assert(m_ptr);
        -:  911:            return m_ptr;
        -:  912:        }
        -:  913:
        -:  914:        T* get() { return m_ptr; }
        -:  915:        T const* get() const { return m_ptr; }
        -:  916:
        -:  917:        void reset(T* ptr = nullptr) {
        -:  918:            delete m_ptr;
        -:  919:            m_ptr = ptr;
        -:  920:        }
        -:  921:
        -:  922:        T* release() {
        -:  923:            auto temp = m_ptr;
        -:  924:            m_ptr = nullptr;
        -:  925:            return temp;
        -:  926:        }
        -:  927:
        -:  928:        explicit operator bool() const {
        -:  929:            return m_ptr;
        -:  930:        }
        -:  931:
        -:  932:        friend void swap(unique_ptr& lhs, unique_ptr& rhs) {
        -:  933:            auto temp = lhs.m_ptr;
        -:  934:            lhs.m_ptr = rhs.m_ptr;
        -:  935:            rhs.m_ptr = temp;
        -:  936:        }
        -:  937:    };
        -:  938:
        -:  939:    //! Specialization to cause compile-time error for arrays
        -:  940:    template <typename T>
        -:  941:    class unique_ptr<T[]>;
        -:  942:
        -:  943:    template <typename T, typename... Args>
        -:  944:    unique_ptr<T> make_unique(Args&&... args) {
        -:  945:        return unique_ptr<T>(new T(CATCH_FORWARD(args)...));
        -:  946:    }
        -:  947:
        -:  948:
        -:  949:} // end namespace Detail
        -:  950:} // end namespace Catch
        -:  951:
        -:  952:#endif // CATCH_UNIQUE_PTR_HPP_INCLUDED
        -:  953:
        -:  954:
        -:  955:#ifndef CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED
        -:  956:#define CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED
        -:  957:
        -:  958:
        -:  959:
        -:  960:// Adapted from donated nonius code.
        -:  961:
        -:  962:#ifndef CATCH_CLOCK_HPP_INCLUDED
        -:  963:#define CATCH_CLOCK_HPP_INCLUDED
        -:  964:
        -:  965:#include <chrono>
        -:  966:
        -:  967:namespace Catch {
        -:  968:    namespace Benchmark {
        -:  969:        using IDuration = std::chrono::nanoseconds;
        -:  970:        using FDuration = std::chrono::duration<double, std::nano>;
        -:  971:
        -:  972:        template <typename Clock>
        -:  973:        using TimePoint = typename Clock::time_point;
        -:  974:
        -:  975:        using default_clock = std::chrono::steady_clock;
        -:  976:    } // namespace Benchmark
        -:  977:} // namespace Catch
        -:  978:
        -:  979:#endif // CATCH_CLOCK_HPP_INCLUDED
        -:  980:
        -:  981:namespace Catch {
        -:  982:
        -:  983:    // We cannot forward declare the type with default template argument
        -:  984:    // multiple times, so it is split out into a separate header so that
        -:  985:    // we can prevent multiple declarations in dependees
        -:  986:    template <typename Duration = Benchmark::FDuration>
        -:  987:    struct BenchmarkStats;
        -:  988:
        -:  989:} // end namespace Catch
        -:  990:
        -:  991:#endif // CATCH_BENCHMARK_STATS_FWD_HPP_INCLUDED
        -:  992:
        -:  993:namespace Catch {
        -:  994:
        -:  995:    class AssertionResult;
        -:  996:    struct AssertionInfo;
        -:  997:    struct SectionInfo;
        -:  998:    struct SectionEndInfo;
        -:  999:    struct MessageInfo;
        -: 1000:    struct MessageBuilder;
        -: 1001:    struct Counts;
        -: 1002:    struct AssertionReaction;
        -: 1003:    struct SourceLineInfo;
        -: 1004:
        -: 1005:    class ITransientExpression;
        -: 1006:    class IGeneratorTracker;
        -: 1007:
        -: 1008:    struct BenchmarkInfo;
        -: 1009:
        -: 1010:    namespace Generators {
        -: 1011:        class GeneratorUntypedBase;
        -: 1012:        using GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;
        -: 1013:    }
        -: 1014:
        -: 1015:
        -: 1016:    class IResultCapture {
        -: 1017:    public:
        -: 1018:        virtual ~IResultCapture();
        -: 1019:
        -: 1020:        virtual void notifyAssertionStarted( AssertionInfo const& info ) = 0;
        -: 1021:        virtual bool sectionStarted( StringRef sectionName,
        -: 1022:                                     SourceLineInfo const& sectionLineInfo,
        -: 1023:                                     Counts& assertions ) = 0;
        -: 1024:        virtual void sectionEnded( SectionEndInfo&& endInfo ) = 0;
        -: 1025:        virtual void sectionEndedEarly( SectionEndInfo&& endInfo ) = 0;
        -: 1026:
        -: 1027:        virtual IGeneratorTracker*
        -: 1028:        acquireGeneratorTracker( StringRef generatorName,
        -: 1029:                                 SourceLineInfo const& lineInfo ) = 0;
        -: 1030:        virtual IGeneratorTracker*
        -: 1031:        createGeneratorTracker( StringRef generatorName,
        -: 1032:                                SourceLineInfo lineInfo,
        -: 1033:                                Generators::GeneratorBasePtr&& generator ) = 0;
        -: 1034:
        -: 1035:        virtual void benchmarkPreparing( StringRef name ) = 0;
        -: 1036:        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
        -: 1037:        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;
        -: 1038:        virtual void benchmarkFailed( StringRef error ) = 0;
        -: 1039:
        -: 1040:        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        -: 1041:        virtual void popScopedMessage( MessageInfo const& message ) = 0;
        -: 1042:
        -: 1043:        virtual void emplaceUnscopedMessage( MessageBuilder&& builder ) = 0;
        -: 1044:
        -: 1045:        virtual void handleFatalErrorCondition( StringRef message ) = 0;
        -: 1046:
        -: 1047:        virtual void handleExpr
        -: 1048:                (   AssertionInfo const& info,
        -: 1049:                    ITransientExpression const& expr,
        -: 1050:                    AssertionReaction& reaction ) = 0;
        -: 1051:        virtual void handleMessage
        -: 1052:                (   AssertionInfo const& info,
        -: 1053:                    ResultWas::OfType resultType,
        -: 1054:                    StringRef message,
        -: 1055:                    AssertionReaction& reaction ) = 0;
        -: 1056:        virtual void handleUnexpectedExceptionNotThrown
        -: 1057:                (   AssertionInfo const& info,
        -: 1058:                    AssertionReaction& reaction ) = 0;
        -: 1059:        virtual void handleUnexpectedInflightException
        -: 1060:                (   AssertionInfo const& info,
        -: 1061:                    std::string&& message,
        -: 1062:                    AssertionReaction& reaction ) = 0;
        -: 1063:        virtual void handleIncomplete
        -: 1064:                (   AssertionInfo const& info ) = 0;
        -: 1065:        virtual void handleNonExpr
        -: 1066:                (   AssertionInfo const &info,
        -: 1067:                    ResultWas::OfType resultType,
        -: 1068:                    AssertionReaction &reaction ) = 0;
        -: 1069:
        -: 1070:
        -: 1071:
        -: 1072:        virtual bool lastAssertionPassed() = 0;
        -: 1073:        virtual void assertionPassed() = 0;
        -: 1074:
        -: 1075:        // Deprecated, do not use:
        -: 1076:        virtual std::string getCurrentTestName() const = 0;
        -: 1077:        virtual const AssertionResult* getLastResult() const = 0;
        -: 1078:        virtual void exceptionEarlyReported() = 0;
        -: 1079:    };
        -: 1080:
        -: 1081:    IResultCapture& getResultCapture();
        -: 1082:}
        -: 1083:
        -: 1084:#endif // CATCH_INTERFACES_CAPTURE_HPP_INCLUDED
        -: 1085:
        -: 1086:
        -: 1087:#ifndef CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -: 1088:#define CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -: 1089:
        -: 1090:
        -: 1091:
        -: 1092:#ifndef CATCH_NONCOPYABLE_HPP_INCLUDED
        -: 1093:#define CATCH_NONCOPYABLE_HPP_INCLUDED
        -: 1094:
        -: 1095:namespace Catch {
        -: 1096:    namespace Detail {
        -: 1097:
        -: 1098:        //! Deriving classes become noncopyable and nonmovable
        -: 1099:        class NonCopyable {
        -: 1100:            NonCopyable( NonCopyable const& ) = delete;
        -: 1101:            NonCopyable( NonCopyable&& ) = delete;
        -: 1102:            NonCopyable& operator=( NonCopyable const& ) = delete;
        -: 1103:            NonCopyable& operator=( NonCopyable&& ) = delete;
        -: 1104:
        -: 1105:        protected:
        -: 1106:            NonCopyable() noexcept = default;
        -: 1107:        };
        -: 1108:
        -: 1109:    } // namespace Detail
        -: 1110:} // namespace Catch
        -: 1111:
        -: 1112:#endif // CATCH_NONCOPYABLE_HPP_INCLUDED
        -: 1113:
        -: 1114:#include <chrono>
        -: 1115:#include <iosfwd>
        -: 1116:#include <string>
        -: 1117:#include <vector>
        -: 1118:
        -: 1119:namespace Catch {
        -: 1120:
        -: 1121:    enum class Verbosity {
        -: 1122:        Quiet = 0,
        -: 1123:        Normal,
        -: 1124:        High
        -: 1125:    };
        -: 1126:
        -: 1127:    struct WarnAbout { enum What {
        -: 1128:        Nothing = 0x00,
        -: 1129:        //! A test case or leaf section did not run any assertions
        -: 1130:        NoAssertions = 0x01,
        -: 1131:        //! A command line test spec matched no test cases
        -: 1132:        UnmatchedTestSpec = 0x02,
        -: 1133:    }; };
        -: 1134:
        -: 1135:    enum class ShowDurations {
        -: 1136:        DefaultForReporter,
        -: 1137:        Always,
        -: 1138:        Never
        -: 1139:    };
        -: 1140:    enum class TestRunOrder {
        -: 1141:        Declared,
        -: 1142:        LexicographicallySorted,
        -: 1143:        Randomized
        -: 1144:    };
        -: 1145:    enum class ColourMode : std::uint8_t {
        -: 1146:        //! Let Catch2 pick implementation based on platform detection
        -: 1147:        PlatformDefault,
        -: 1148:        //! Use ANSI colour code escapes
        -: 1149:        ANSI,
        -: 1150:        //! Use Win32 console colour API
        -: 1151:        Win32,
        -: 1152:        //! Don't use any colour
        -: 1153:        None
        -: 1154:    };
        -: 1155:    struct WaitForKeypress { enum When {
        -: 1156:        Never,
        -: 1157:        BeforeStart = 1,
        -: 1158:        BeforeExit = 2,
        -: 1159:        BeforeStartAndExit = BeforeStart | BeforeExit
        -: 1160:    }; };
        -: 1161:
        -: 1162:    class TestSpec;
        -: 1163:    class IStream;
        -: 1164:
        -: 1165:    class IConfig : public Detail::NonCopyable {
        -: 1166:    public:
        -: 1167:        virtual ~IConfig();
        -: 1168:
        -: 1169:        virtual bool allowThrows() const = 0;
        -: 1170:        virtual StringRef name() const = 0;
        -: 1171:        virtual bool includeSuccessfulResults() const = 0;
        -: 1172:        virtual bool shouldDebugBreak() const = 0;
        -: 1173:        virtual bool warnAboutMissingAssertions() const = 0;
        -: 1174:        virtual bool warnAboutUnmatchedTestSpecs() const = 0;
        -: 1175:        virtual bool zeroTestsCountAsSuccess() const = 0;
        -: 1176:        virtual int abortAfter() const = 0;
        -: 1177:        virtual bool showInvisibles() const = 0;
        -: 1178:        virtual ShowDurations showDurations() const = 0;
        -: 1179:        virtual double minDuration() const = 0;
        -: 1180:        virtual TestSpec const& testSpec() const = 0;
        -: 1181:        virtual bool hasTestFilters() const = 0;
        -: 1182:        virtual std::vector<std::string> const& getTestsOrTags() const = 0;
        -: 1183:        virtual TestRunOrder runOrder() const = 0;
        -: 1184:        virtual uint32_t rngSeed() const = 0;
        -: 1185:        virtual unsigned int shardCount() const = 0;
        -: 1186:        virtual unsigned int shardIndex() const = 0;
        -: 1187:        virtual ColourMode defaultColourMode() const = 0;
        -: 1188:        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
        -: 1189:        virtual Verbosity verbosity() const = 0;
        -: 1190:
        -: 1191:        virtual bool skipBenchmarks() const = 0;
        -: 1192:        virtual bool benchmarkNoAnalysis() const = 0;
        -: 1193:        virtual unsigned int benchmarkSamples() const = 0;
        -: 1194:        virtual double benchmarkConfidenceInterval() const = 0;
        -: 1195:        virtual unsigned int benchmarkResamples() const = 0;
        -: 1196:        virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
        -: 1197:    };
        -: 1198:}
        -: 1199:
        -: 1200:#endif // CATCH_INTERFACES_CONFIG_HPP_INCLUDED
        -: 1201:
        -: 1202:
        -: 1203:#ifndef CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1204:#define CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1205:
        -: 1206:
        -: 1207:#include <string>
        -: 1208:
        -: 1209:namespace Catch {
        -: 1210:
        -: 1211:    class TestCaseHandle;
        -: 1212:    struct TestCaseInfo;
        -: 1213:    class ITestCaseRegistry;
        -: 1214:    class IExceptionTranslatorRegistry;
        -: 1215:    class IExceptionTranslator;
        -: 1216:    class ReporterRegistry;
        -: 1217:    class IReporterFactory;
        -: 1218:    class ITagAliasRegistry;
        -: 1219:    class ITestInvoker;
        -: 1220:    class IMutableEnumValuesRegistry;
        -: 1221:    struct SourceLineInfo;
        -: 1222:
        -: 1223:    class StartupExceptionRegistry;
        -: 1224:    class EventListenerFactory;
        -: 1225:
        -: 1226:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -: 1227:
        -: 1228:    class IRegistryHub {
        -: 1229:    public:
        -: 1230:        virtual ~IRegistryHub(); // = default
        -: 1231:
        -: 1232:        virtual ReporterRegistry const& getReporterRegistry() const = 0;
        -: 1233:        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        -: 1234:        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
        -: 1235:        virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
        -: 1236:
        -: 1237:
        -: 1238:        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
        -: 1239:    };
        -: 1240:
        -: 1241:    class IMutableRegistryHub {
        -: 1242:    public:
        -: 1243:        virtual ~IMutableRegistryHub(); // = default
        -: 1244:        virtual void registerReporter( std::string const& name, IReporterFactoryPtr factory ) = 0;
        -: 1245:        virtual void registerListener( Detail::unique_ptr<EventListenerFactory> factory ) = 0;
        -: 1246:        virtual void registerTest(Detail::unique_ptr<TestCaseInfo>&& testInfo, Detail::unique_ptr<ITestInvoker>&& invoker) = 0;
        -: 1247:        virtual void registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator ) = 0;
        -: 1248:        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
        -: 1249:        virtual void registerStartupException() noexcept = 0;
        -: 1250:        virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
        -: 1251:    };
        -: 1252:
        -: 1253:    IRegistryHub const& getRegistryHub();
        -: 1254:    IMutableRegistryHub& getMutableRegistryHub();
        -: 1255:    void cleanUp();
        -: 1256:    std::string translateActiveException();
        -: 1257:
        -: 1258:}
        -: 1259:
        -: 1260:#endif // CATCH_INTERFACES_REGISTRY_HUB_HPP_INCLUDED
        -: 1261:
        -: 1262:
        -: 1263:#ifndef CATCH_BENCHMARK_STATS_HPP_INCLUDED
        -: 1264:#define CATCH_BENCHMARK_STATS_HPP_INCLUDED
        -: 1265:
        -: 1266:
        -: 1267:
        -: 1268:// Adapted from donated nonius code.
        -: 1269:
        -: 1270:#ifndef CATCH_ESTIMATE_HPP_INCLUDED
        -: 1271:#define CATCH_ESTIMATE_HPP_INCLUDED
        -: 1272:
        -: 1273:namespace Catch {
        -: 1274:    namespace Benchmark {
        -: 1275:        template <typename Type>
        -: 1276:        struct Estimate {
        -: 1277:            Type point;
        -: 1278:            Type lower_bound;
        -: 1279:            Type upper_bound;
        -: 1280:            double confidence_interval;
        -: 1281:        };
        -: 1282:    } // namespace Benchmark
        -: 1283:} // namespace Catch
        -: 1284:
        -: 1285:#endif // CATCH_ESTIMATE_HPP_INCLUDED
        -: 1286:
        -: 1287:
        -: 1288:// Adapted from donated nonius code.
        -: 1289:
        -: 1290:#ifndef CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED
        -: 1291:#define CATCH_OUTLIER_CLASSIFICATION_HPP_INCLUDED
        -: 1292:
        -: 1293:namespace Catch {
        -: 1294:    namespace Benchmark {
        -: 1295:        struct OutlierClassification {
        -: 1296:            int samples_seen = 0;
        -: 1297:            int low_severe = 0;     // more than 3 times IQR below Q1
        -: 1298:            int low_mild = 0;       // 1.5 to 3 times IQR below Q1
        -: 1299:            int high_mild = 0;      // 1.5 to 3 times IQR above Q3
        -: 1300:            int high_severe = 0;    // more than 3 times IQR above Q3
        -: 1301:
        -: 1302:            int total() const {
        -: 1303:                return low_severe + low_mild + high_mild + high_severe;
        -: 1304:            }
        -: 1305:        };
        -: 1306:    } // namespace Benchmark
        -: 1307:} // namespace Catch
        -: 1308:
        -: 1309:#endif // CATCH_OUTLIERS_CLASSIFICATION_HPP_INCLUDED
        -: 1310:// The fwd decl & default specialization needs to be seen by VS2017 before
        -: 1311:// BenchmarkStats itself, or VS2017 will report compilation error.
        -: 1312:
        -: 1313:#include <string>
        -: 1314:#include <vector>
        -: 1315:
        -: 1316:namespace Catch {
        -: 1317:
        -: 1318:    struct BenchmarkInfo {
        -: 1319:        std::string name;
        -: 1320:        double estimatedDuration;
        -: 1321:        int iterations;
        -: 1322:        unsigned int samples;
        -: 1323:        unsigned int resamples;
        -: 1324:        double clockResolution;
        -: 1325:        double clockCost;
        -: 1326:    };
        -: 1327:
        -: 1328:    // We need to keep template parameter for backwards compatibility,
        -: 1329:    // but we also do not want to use the template paraneter.
        -: 1330:    template <class Dummy>
        -: 1331:    struct BenchmarkStats {
        -: 1332:        BenchmarkInfo info;
        -: 1333:
        -: 1334:        std::vector<Benchmark::FDuration> samples;
        -: 1335:        Benchmark::Estimate<Benchmark::FDuration> mean;
        -: 1336:        Benchmark::Estimate<Benchmark::FDuration> standardDeviation;
        -: 1337:        Benchmark::OutlierClassification outliers;
        -: 1338:        double outlierVariance;
        -: 1339:    };
        -: 1340:
        -: 1341:
        -: 1342:} // end namespace Catch
        -: 1343:
        -: 1344:#endif // CATCH_BENCHMARK_STATS_HPP_INCLUDED
        -: 1345:
        -: 1346:
        -: 1347:// Adapted from donated nonius code.
        -: 1348:
        -: 1349:#ifndef CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1350:#define CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1351:
        -: 1352:
        -: 1353:namespace Catch {
        -: 1354:    namespace Benchmark {
        -: 1355:        struct EnvironmentEstimate {
        -: 1356:            FDuration mean;
        -: 1357:            OutlierClassification outliers;
        -: 1358:        };
        -: 1359:        struct Environment {
        -: 1360:            EnvironmentEstimate clock_resolution;
        -: 1361:            EnvironmentEstimate clock_cost;
        -: 1362:        };
        -: 1363:    } // namespace Benchmark
        -: 1364:} // namespace Catch
        -: 1365:
        -: 1366:#endif // CATCH_ENVIRONMENT_HPP_INCLUDED
        -: 1367:
        -: 1368:
        -: 1369:// Adapted from donated nonius code.
        -: 1370:
        -: 1371:#ifndef CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 1372:#define CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 1373:
        -: 1374:
        -: 1375:
        -: 1376:// Adapted from donated nonius code.
        -: 1377:
        -: 1378:#ifndef CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 1379:#define CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 1380:
        -: 1381:
        -: 1382:
        -: 1383:// Adapted from donated nonius code.
        -: 1384:
        -: 1385:#ifndef CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1386:#define CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1387:
        -: 1388:
        -: 1389:
        -: 1390:// Adapted from donated nonius code.
        -: 1391:
        -: 1392:#ifndef CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1393:#define CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1394:
        -: 1395:#if defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)
        -: 1396:#   include <atomic> // atomic_thread_fence
        -: 1397:#endif
        -: 1398:
        -: 1399:
        -: 1400:#include <type_traits>
        -: 1401:
        -: 1402:namespace Catch {
        -: 1403:    namespace Benchmark {
        -: 1404:#if defined(__GNUC__) || defined(__clang__)
        -: 1405:        template <typename T>
        -: 1406:        inline void keep_memory(T* p) {
        -: 1407:            asm volatile("" : : "g"(p) : "memory");
        -: 1408:        }
        -: 1409:        inline void keep_memory() {
        -: 1410:            asm volatile("" : : : "memory");
        -: 1411:        }
        -: 1412:
        -: 1413:        namespace Detail {
        -: 1414:            inline void optimizer_barrier() { keep_memory(); }
        -: 1415:        } // namespace Detail
        -: 1416:#elif defined(_MSC_VER) || defined(__IAR_SYSTEMS_ICC__)
        -: 1417:
        -: 1418:#if defined(_MSVC_VER)
        -: 1419:#pragma optimize("", off)
        -: 1420:#elif defined(__IAR_SYSTEMS_ICC__)
        -: 1421:// For IAR the pragma only affects the following function
        -: 1422:#pragma optimize=disable
        -: 1423:#endif
        -: 1424:        template <typename T>
        -: 1425:        inline void keep_memory(T* p) {
        -: 1426:            // thanks @milleniumbug
        -: 1427:            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);
        -: 1428:        }
        -: 1429:        // TODO equivalent keep_memory()
        -: 1430:#if defined(_MSVC_VER)
        -: 1431:#pragma optimize("", on)
        -: 1432:#endif
        -: 1433:
        -: 1434:        namespace Detail {
        -: 1435:            inline void optimizer_barrier() {
        -: 1436:                std::atomic_thread_fence(std::memory_order_seq_cst);
        -: 1437:            }
        -: 1438:        } // namespace Detail
        -: 1439:
        -: 1440:#endif
        -: 1441:
        -: 1442:        template <typename T>
        -: 1443:        inline void deoptimize_value(T&& x) {
        -: 1444:            keep_memory(&x);
        -: 1445:        }
        -: 1446:
        -: 1447:        template <typename Fn, typename... Args>
        -: 1448:        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<!std::is_same<void, decltype(fn(args...))>::value> {
        -: 1449:            deoptimize_value(CATCH_FORWARD(fn) (CATCH_FORWARD(args)...));
        -: 1450:        }
        -: 1451:
        -: 1452:        template <typename Fn, typename... Args>
        -: 1453:        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> std::enable_if_t<std::is_same<void, decltype(fn(args...))>::value> {
        -: 1454:            CATCH_FORWARD((fn)) (CATCH_FORWARD(args)...);
        -: 1455:        }
        -: 1456:    } // namespace Benchmark
        -: 1457:} // namespace Catch
        -: 1458:
        -: 1459:#endif // CATCH_OPTIMIZER_HPP_INCLUDED
        -: 1460:
        -: 1461:
        -: 1462:#ifndef CATCH_META_HPP_INCLUDED
        -: 1463:#define CATCH_META_HPP_INCLUDED
        -: 1464:
        -: 1465:#include <type_traits>
        -: 1466:
        -: 1467:namespace Catch {
        -: 1468:    template <typename>
        -: 1469:    struct true_given : std::true_type {};
        -: 1470:
        -: 1471:    struct is_callable_tester {
        -: 1472:        template <typename Fun, typename... Args>
        -: 1473:        static true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> test(int);
        -: 1474:        template <typename...>
        -: 1475:        static std::false_type test(...);
        -: 1476:    };
        -: 1477:
        -: 1478:    template <typename T>
        -: 1479:    struct is_callable;
        -: 1480:
        -: 1481:    template <typename Fun, typename... Args>
        -: 1482:    struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};
        -: 1483:
        -: 1484:
        -: 1485:#if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703
        -: 1486:    // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
        -: 1487:    // replaced with std::invoke_result here.
        -: 1488:    template <typename Func, typename... U>
        -: 1489:    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U...>>>;
        -: 1490:#else
        -: 1491:    template <typename Func, typename... U>
        -: 1492:    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::result_of_t<Func(U...)>>>;
        -: 1493:#endif
        -: 1494:
        -: 1495:} // namespace Catch
        -: 1496:
        -: 1497:namespace mpl_{
        -: 1498:    struct na;
        -: 1499:}
        -: 1500:
        -: 1501:#endif // CATCH_META_HPP_INCLUDED
        -: 1502:
        -: 1503:namespace Catch {
        -: 1504:    namespace Benchmark {
        -: 1505:        namespace Detail {
        -: 1506:            struct ChronometerConcept {
        -: 1507:                virtual void start() = 0;
        -: 1508:                virtual void finish() = 0;
        -: 1509:                virtual ~ChronometerConcept(); // = default;
        -: 1510:
        -: 1511:                ChronometerConcept() = default;
        -: 1512:                ChronometerConcept(ChronometerConcept const&) = default;
        -: 1513:                ChronometerConcept& operator=(ChronometerConcept const&) = default;
        -: 1514:            };
        -: 1515:            template <typename Clock>
        -: 1516:            struct ChronometerModel final : public ChronometerConcept {
        -: 1517:                void start() override { started = Clock::now(); }
        -: 1518:                void finish() override { finished = Clock::now(); }
        -: 1519:
        -: 1520:                IDuration elapsed() const {
        -: 1521:                    return std::chrono::duration_cast<std::chrono::nanoseconds>(
        -: 1522:                        finished - started );
        -: 1523:                }
        -: 1524:
        -: 1525:                TimePoint<Clock> started;
        -: 1526:                TimePoint<Clock> finished;
        -: 1527:            };
        -: 1528:        } // namespace Detail
        -: 1529:
        -: 1530:        struct Chronometer {
        -: 1531:        public:
        -: 1532:            template <typename Fun>
        -: 1533:            void measure(Fun&& fun) { measure(CATCH_FORWARD(fun), is_callable<Fun(int)>()); }
        -: 1534:
        -: 1535:            int runs() const { return repeats; }
        -: 1536:
        -: 1537:            Chronometer(Detail::ChronometerConcept& meter, int repeats_)
        -: 1538:                : impl(&meter)
        -: 1539:                , repeats(repeats_) {}
        -: 1540:
        -: 1541:        private:
        -: 1542:            template <typename Fun>
        -: 1543:            void measure(Fun&& fun, std::false_type) {
        -: 1544:                measure([&fun](int) { return fun(); }, std::true_type());
        -: 1545:            }
        -: 1546:
        -: 1547:            template <typename Fun>
        -: 1548:            void measure(Fun&& fun, std::true_type) {
        -: 1549:                Detail::optimizer_barrier();
        -: 1550:                impl->start();
        -: 1551:                for (int i = 0; i < repeats; ++i) invoke_deoptimized(fun, i);
        -: 1552:                impl->finish();
        -: 1553:                Detail::optimizer_barrier();
        -: 1554:            }
        -: 1555:
        -: 1556:            Detail::ChronometerConcept* impl;
        -: 1557:            int repeats;
        -: 1558:        };
        -: 1559:    } // namespace Benchmark
        -: 1560:} // namespace Catch
        -: 1561:
        -: 1562:#endif // CATCH_CHRONOMETER_HPP_INCLUDED
        -: 1563:
        -: 1564:#include <type_traits>
        -: 1565:
        -: 1566:namespace Catch {
        -: 1567:    namespace Benchmark {
        -: 1568:        namespace Detail {
        -: 1569:            template <typename T, typename U>
        -: 1570:            struct is_related
        -: 1571:                : std::is_same<std::decay_t<T>, std::decay_t<U>> {};
        -: 1572:
        -: 1573:            /// We need to reinvent std::function because every piece of code that might add overhead
        -: 1574:            /// in a measurement context needs to have consistent performance characteristics so that we
        -: 1575:            /// can account for it in the measurement.
        -: 1576:            /// Implementations of std::function with optimizations that aren't always applicable, like
        -: 1577:            /// small buffer optimizations, are not uncommon.
        -: 1578:            /// This is effectively an implementation of std::function without any such optimizations;
        -: 1579:            /// it may be slow, but it is consistently slow.
        -: 1580:            struct BenchmarkFunction {
        -: 1581:            private:
        -: 1582:                struct callable {
        -: 1583:                    virtual void call(Chronometer meter) const = 0;
        -: 1584:                    virtual Catch::Detail::unique_ptr<callable> clone() const = 0;
        -: 1585:                    virtual ~callable(); // = default;
        -: 1586:
        -: 1587:                    callable() = default;
        -: 1588:                    callable(callable const&) = default;
        -: 1589:                    callable& operator=(callable const&) = default;
        -: 1590:                };
        -: 1591:                template <typename Fun>
        -: 1592:                struct model : public callable {
        -: 1593:                    model(Fun&& fun_) : fun(CATCH_MOVE(fun_)) {}
        -: 1594:                    model(Fun const& fun_) : fun(fun_) {}
        -: 1595:
        -: 1596:                    Catch::Detail::unique_ptr<callable> clone() const override {
        -: 1597:                        return Catch::Detail::make_unique<model<Fun>>( *this );
        -: 1598:                    }
        -: 1599:
        -: 1600:                    void call(Chronometer meter) const override {
        -: 1601:                        call(meter, is_callable<Fun(Chronometer)>());
        -: 1602:                    }
        -: 1603:                    void call(Chronometer meter, std::true_type) const {
        -: 1604:                        fun(meter);
        -: 1605:                    }
        -: 1606:                    void call(Chronometer meter, std::false_type) const {
        -: 1607:                        meter.measure(fun);
        -: 1608:                    }
        -: 1609:
        -: 1610:                    Fun fun;
        -: 1611:                };
        -: 1612:
        -: 1613:                struct do_nothing { void operator()() const {} };
        -: 1614:
        -: 1615:                template <typename T>
        -: 1616:                BenchmarkFunction(model<T>* c) : f(c) {}
        -: 1617:
        -: 1618:            public:
        -: 1619:                BenchmarkFunction()
        -: 1620:                    : f(new model<do_nothing>{ {} }) {}
        -: 1621:
        -: 1622:                template <typename Fun,
        -: 1623:                    std::enable_if_t<!is_related<Fun, BenchmarkFunction>::value, int> = 0>
        -: 1624:                    BenchmarkFunction(Fun&& fun)
        -: 1625:                    : f(new model<std::decay_t<Fun>>(CATCH_FORWARD(fun))) {}
        -: 1626:
        -: 1627:                BenchmarkFunction( BenchmarkFunction&& that ) noexcept:
        -: 1628:                    f( CATCH_MOVE( that.f ) ) {}
        -: 1629:
        -: 1630:                BenchmarkFunction(BenchmarkFunction const& that)
        -: 1631:                    : f(that.f->clone()) {}
        -: 1632:
        -: 1633:                BenchmarkFunction&
        -: 1634:                operator=( BenchmarkFunction&& that ) noexcept {
        -: 1635:                    f = CATCH_MOVE( that.f );
        -: 1636:                    return *this;
        -: 1637:                }
        -: 1638:
        -: 1639:                BenchmarkFunction& operator=(BenchmarkFunction const& that) {
        -: 1640:                    f = that.f->clone();
        -: 1641:                    return *this;
        -: 1642:                }
        -: 1643:
        -: 1644:                void operator()(Chronometer meter) const { f->call(meter); }
        -: 1645:
        -: 1646:            private:
        -: 1647:                Catch::Detail::unique_ptr<callable> f;
        -: 1648:            };
        -: 1649:        } // namespace Detail
        -: 1650:    } // namespace Benchmark
        -: 1651:} // namespace Catch
        -: 1652:
        -: 1653:#endif // CATCH_BENCHMARK_FUNCTION_HPP_INCLUDED
        -: 1654:
        -: 1655:
        -: 1656:// Adapted from donated nonius code.
        -: 1657:
        -: 1658:#ifndef CATCH_REPEAT_HPP_INCLUDED
        -: 1659:#define CATCH_REPEAT_HPP_INCLUDED
        -: 1660:
        -: 1661:#include <type_traits>
        -: 1662:
        -: 1663:namespace Catch {
        -: 1664:    namespace Benchmark {
        -: 1665:        namespace Detail {
        -: 1666:            template <typename Fun>
        -: 1667:            struct repeater {
        -: 1668:                void operator()(int k) const {
        -: 1669:                    for (int i = 0; i < k; ++i) {
        -: 1670:                        fun();
        -: 1671:                    }
        -: 1672:                }
        -: 1673:                Fun fun;
        -: 1674:            };
        -: 1675:            template <typename Fun>
        -: 1676:            repeater<std::decay_t<Fun>> repeat(Fun&& fun) {
        -: 1677:                return { CATCH_FORWARD(fun) };
        -: 1678:            }
        -: 1679:        } // namespace Detail
        -: 1680:    } // namespace Benchmark
        -: 1681:} // namespace Catch
        -: 1682:
        -: 1683:#endif // CATCH_REPEAT_HPP_INCLUDED
        -: 1684:
        -: 1685:
        -: 1686:// Adapted from donated nonius code.
        -: 1687:
        -: 1688:#ifndef CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 1689:#define CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 1690:
        -: 1691:
        -: 1692:
        -: 1693:// Adapted from donated nonius code.
        -: 1694:
        -: 1695:#ifndef CATCH_MEASURE_HPP_INCLUDED
        -: 1696:#define CATCH_MEASURE_HPP_INCLUDED
        -: 1697:
        -: 1698:
        -: 1699:
        -: 1700:// Adapted from donated nonius code.
        -: 1701:
        -: 1702:#ifndef CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1703:#define CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1704:
        -: 1705:
        -: 1706:namespace Catch {
        -: 1707:    namespace Benchmark {
        -: 1708:        namespace Detail {
        -: 1709:            template <typename T>
        -: 1710:            struct CompleteType { using type = T; };
        -: 1711:            template <>
        -: 1712:            struct CompleteType<void> { struct type {}; };
        -: 1713:
        -: 1714:            template <typename T>
        -: 1715:            using CompleteType_t = typename CompleteType<T>::type;
        -: 1716:
        -: 1717:            template <typename Result>
        -: 1718:            struct CompleteInvoker {
        -: 1719:                template <typename Fun, typename... Args>
        -: 1720:                static Result invoke(Fun&& fun, Args&&... args) {
        -: 1721:                    return CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);
        -: 1722:                }
        -: 1723:            };
        -: 1724:            template <>
        -: 1725:            struct CompleteInvoker<void> {
        -: 1726:                template <typename Fun, typename... Args>
        -: 1727:                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {
        -: 1728:                    CATCH_FORWARD(fun)(CATCH_FORWARD(args)...);
        -: 1729:                    return {};
        -: 1730:                }
        -: 1731:            };
        -: 1732:
        -: 1733:            // invoke and not return void :(
        -: 1734:            template <typename Fun, typename... Args>
        -: 1735:            CompleteType_t<FunctionReturnType<Fun, Args...>> complete_invoke(Fun&& fun, Args&&... args) {
        -: 1736:                return CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(CATCH_FORWARD(fun), CATCH_FORWARD(args)...);
        -: 1737:            }
        -: 1738:
        -: 1739:        } // namespace Detail
        -: 1740:
        -: 1741:        template <typename Fun>
        -: 1742:        Detail::CompleteType_t<FunctionReturnType<Fun>> user_code(Fun&& fun) {
        -: 1743:            return Detail::complete_invoke(CATCH_FORWARD(fun));
        -: 1744:        }
        -: 1745:    } // namespace Benchmark
        -: 1746:} // namespace Catch
        -: 1747:
        -: 1748:#endif // CATCH_COMPLETE_INVOKE_HPP_INCLUDED
        -: 1749:
        -: 1750:
        -: 1751:// Adapted from donated nonius code.
        -: 1752:
        -: 1753:#ifndef CATCH_TIMING_HPP_INCLUDED
        -: 1754:#define CATCH_TIMING_HPP_INCLUDED
        -: 1755:
        -: 1756:
        -: 1757:#include <type_traits>
        -: 1758:
        -: 1759:namespace Catch {
        -: 1760:    namespace Benchmark {
        -: 1761:        template <typename Result>
        -: 1762:        struct Timing {
        -: 1763:            IDuration elapsed;
        -: 1764:            Result result;
        -: 1765:            int iterations;
        -: 1766:        };
        -: 1767:        template <typename Func, typename... Args>
        -: 1768:        using TimingOf = Timing<Detail::CompleteType_t<FunctionReturnType<Func, Args...>>>;
        -: 1769:    } // namespace Benchmark
        -: 1770:} // namespace Catch
        -: 1771:
        -: 1772:#endif // CATCH_TIMING_HPP_INCLUDED
        -: 1773:
        -: 1774:namespace Catch {
        -: 1775:    namespace Benchmark {
        -: 1776:        namespace Detail {
        -: 1777:            template <typename Clock, typename Fun, typename... Args>
        -: 1778:            TimingOf<Fun, Args...> measure(Fun&& fun, Args&&... args) {
        -: 1779:                auto start = Clock::now();
        -: 1780:                auto&& r = Detail::complete_invoke(fun, CATCH_FORWARD(args)...);
        -: 1781:                auto end = Clock::now();
        -: 1782:                auto delta = end - start;
        -: 1783:                return { delta, CATCH_FORWARD(r), 1 };
        -: 1784:            }
        -: 1785:        } // namespace Detail
        -: 1786:    } // namespace Benchmark
        -: 1787:} // namespace Catch
        -: 1788:
        -: 1789:#endif // CATCH_MEASURE_HPP_INCLUDED
        -: 1790:
        -: 1791:#include <type_traits>
        -: 1792:
        -: 1793:namespace Catch {
        -: 1794:    namespace Benchmark {
        -: 1795:        namespace Detail {
        -: 1796:            template <typename Clock, typename Fun>
        -: 1797:            TimingOf<Fun, int> measure_one(Fun&& fun, int iters, std::false_type) {
        -: 1798:                return Detail::measure<Clock>(fun, iters);
        -: 1799:            }
        -: 1800:            template <typename Clock, typename Fun>
        -: 1801:            TimingOf<Fun, Chronometer> measure_one(Fun&& fun, int iters, std::true_type) {
        -: 1802:                Detail::ChronometerModel<Clock> meter;
        -: 1803:                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));
        -: 1804:
        -: 1805:                return { meter.elapsed(), CATCH_MOVE(result), iters };
        -: 1806:            }
        -: 1807:
        -: 1808:            template <typename Clock, typename Fun>
        -: 1809:            using run_for_at_least_argument_t = std::conditional_t<is_callable<Fun(Chronometer)>::value, Chronometer, int>;
        -: 1810:
        -: 1811:
        -: 1812:            [[noreturn]]
        -: 1813:            void throw_optimized_away_error();
        -: 1814:
        -: 1815:            template <typename Clock, typename Fun>
        -: 1816:            TimingOf<Fun, run_for_at_least_argument_t<Clock, Fun>>
        -: 1817:                run_for_at_least(IDuration how_long,
        -: 1818:                                 const int initial_iterations,
        -: 1819:                                 Fun&& fun) {
        -: 1820:                auto iters = initial_iterations;
        -: 1821:                while (iters < (1 << 30)) {
        -: 1822:                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());
        -: 1823:
        -: 1824:                    if (Timing.elapsed >= how_long) {
        -: 1825:                        return { Timing.elapsed, CATCH_MOVE(Timing.result), iters };
        -: 1826:                    }
        -: 1827:                    iters *= 2;
        -: 1828:                }
        -: 1829:                throw_optimized_away_error();
        -: 1830:            }
        -: 1831:        } // namespace Detail
        -: 1832:    } // namespace Benchmark
        -: 1833:} // namespace Catch
        -: 1834:
        -: 1835:#endif // CATCH_RUN_FOR_AT_LEAST_HPP_INCLUDED
        -: 1836:
        -: 1837:#include <vector>
        -: 1838:
        -: 1839:namespace Catch {
        -: 1840:    namespace Benchmark {
        -: 1841:        struct ExecutionPlan {
        -: 1842:            int iterations_per_sample;
        -: 1843:            FDuration estimated_duration;
        -: 1844:            Detail::BenchmarkFunction benchmark;
        -: 1845:            FDuration warmup_time;
        -: 1846:            int warmup_iterations;
        -: 1847:
        -: 1848:            template <typename Clock>
        -: 1849:            std::vector<FDuration> run(const IConfig &cfg, Environment env) const {
        -: 1850:                // warmup a bit
        -: 1851:                Detail::run_for_at_least<Clock>(
        -: 1852:                    std::chrono::duration_cast<IDuration>( warmup_time ),
        -: 1853:                    warmup_iterations,
        -: 1854:                    Detail::repeat( []() { return Clock::now(); } )
        -: 1855:                );
        -: 1856:
        -: 1857:                std::vector<FDuration> times;
        -: 1858:                const auto num_samples = cfg.benchmarkSamples();
        -: 1859:                times.reserve( num_samples );
        -: 1860:                for ( size_t i = 0; i < num_samples; ++i ) {
        -: 1861:                    Detail::ChronometerModel<Clock> model;
        -: 1862:                    this->benchmark( Chronometer( model, iterations_per_sample ) );
        -: 1863:                    auto sample_time = model.elapsed() - env.clock_cost.mean;
        -: 1864:                    if ( sample_time < FDuration::zero() ) {
        -: 1865:                        sample_time = FDuration::zero();
        -: 1866:                    }
        -: 1867:                    times.push_back(sample_time / iterations_per_sample);
        -: 1868:                }
        -: 1869:                return times;
        -: 1870:            }
        -: 1871:        };
        -: 1872:    } // namespace Benchmark
        -: 1873:} // namespace Catch
        -: 1874:
        -: 1875:#endif // CATCH_EXECUTION_PLAN_HPP_INCLUDED
        -: 1876:
        -: 1877:
        -: 1878:// Adapted from donated nonius code.
        -: 1879:
        -: 1880:#ifndef CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 1881:#define CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 1882:
        -: 1883:
        -: 1884:
        -: 1885:// Adapted from donated nonius code.
        -: 1886:
        -: 1887:#ifndef CATCH_STATS_HPP_INCLUDED
        -: 1888:#define CATCH_STATS_HPP_INCLUDED
        -: 1889:
        -: 1890:
        -: 1891:#include <vector>
        -: 1892:
        -: 1893:namespace Catch {
        -: 1894:    namespace Benchmark {
        -: 1895:        namespace Detail {
        -: 1896:            using sample = std::vector<double>;
        -: 1897:
        -: 1898:            double weighted_average_quantile( int k,
        -: 1899:                                              int q,
        -: 1900:                                              double* first,
        -: 1901:                                              double* last );
        -: 1902:
        -: 1903:            OutlierClassification
        -: 1904:            classify_outliers( double const* first, double const* last );
        -: 1905:
        -: 1906:            double mean( double const* first, double const* last );
        -: 1907:
        -: 1908:            double normal_cdf( double x );
        -: 1909:
        -: 1910:            double erfc_inv(double x);
        -: 1911:
        -: 1912:            double normal_quantile(double p);
        -: 1913:
        -: 1914:            Estimate<double>
        -: 1915:            bootstrap( double confidence_level,
        -: 1916:                       double* first,
        -: 1917:                       double* last,
        -: 1918:                       sample const& resample,
        -: 1919:                       double ( *estimator )( double const*, double const* ) );
        -: 1920:
        -: 1921:            struct bootstrap_analysis {
        -: 1922:                Estimate<double> mean;
        -: 1923:                Estimate<double> standard_deviation;
        -: 1924:                double outlier_variance;
        -: 1925:            };
        -: 1926:
        -: 1927:            bootstrap_analysis analyse_samples(double confidence_level,
        -: 1928:                                               unsigned int n_resamples,
        -: 1929:                                               double* first,
        -: 1930:                                               double* last);
        -: 1931:        } // namespace Detail
        -: 1932:    } // namespace Benchmark
        -: 1933:} // namespace Catch
        -: 1934:
        -: 1935:#endif // CATCH_STATS_HPP_INCLUDED
        -: 1936:
        -: 1937:#include <algorithm>
        -: 1938:#include <vector>
        -: 1939:#include <cmath>
        -: 1940:
        -: 1941:namespace Catch {
        -: 1942:    namespace Benchmark {
        -: 1943:        namespace Detail {
        -: 1944:            template <typename Clock>
        -: 1945:            std::vector<double> resolution(int k) {
        -: 1946:                std::vector<TimePoint<Clock>> times;
        -: 1947:                times.reserve(static_cast<size_t>(k + 1));
        -: 1948:                for ( int i = 0; i < k + 1; ++i ) {
        -: 1949:                    times.push_back( Clock::now() );
        -: 1950:                }
        -: 1951:
        -: 1952:                std::vector<double> deltas;
        -: 1953:                deltas.reserve(static_cast<size_t>(k));
        -: 1954:                for ( size_t idx = 1; idx < times.size(); ++idx ) {
        -: 1955:                    deltas.push_back( static_cast<double>(
        -: 1956:                        ( times[idx] - times[idx - 1] ).count() ) );
        -: 1957:                }
        -: 1958:
        -: 1959:                return deltas;
        -: 1960:            }
        -: 1961:
        -: 1962:            constexpr auto warmup_iterations = 10000;
        -: 1963:            constexpr auto warmup_time = std::chrono::milliseconds(100);
        -: 1964:            constexpr auto minimum_ticks = 1000;
        -: 1965:            constexpr auto warmup_seed = 10000;
        -: 1966:            constexpr auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
        -: 1967:            constexpr auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
        -: 1968:            constexpr auto clock_cost_estimation_tick_limit = 100000;
        -: 1969:            constexpr auto clock_cost_estimation_time = std::chrono::milliseconds(10);
        -: 1970:            constexpr auto clock_cost_estimation_iterations = 10000;
        -: 1971:
        -: 1972:            template <typename Clock>
        -: 1973:            int warmup() {
        -: 1974:                return run_for_at_least<Clock>(warmup_time, warmup_seed, &resolution<Clock>)
        -: 1975:                    .iterations;
        -: 1976:            }
        -: 1977:            template <typename Clock>
        -: 1978:            EnvironmentEstimate estimate_clock_resolution(int iterations) {
        -: 1979:                auto r = run_for_at_least<Clock>(clock_resolution_estimation_time, iterations, &resolution<Clock>)
        -: 1980:                    .result;
        -: 1981:                return {
        -: 1982:                    FDuration(mean(r.data(), r.data() + r.size())),
        -: 1983:                    classify_outliers(r.data(), r.data() + r.size()),
        -: 1984:                };
        -: 1985:            }
        -: 1986:            template <typename Clock>
        -: 1987:            EnvironmentEstimate estimate_clock_cost(FDuration resolution) {
        -: 1988:                auto time_limit = (std::min)(
        -: 1989:                    resolution * clock_cost_estimation_tick_limit,
        -: 1990:                    FDuration(clock_cost_estimation_time_limit));
        -: 1991:                auto time_clock = [](int k) {
        -: 1992:                    return Detail::measure<Clock>([k] {
        -: 1993:                        for (int i = 0; i < k; ++i) {
        -: 1994:                            volatile auto ignored = Clock::now();
        -: 1995:                            (void)ignored;
        -: 1996:                        }
        -: 1997:                    }).elapsed;
        -: 1998:                };
        -: 1999:                time_clock(1);
        -: 2000:                int iters = clock_cost_estimation_iterations;
        -: 2001:                auto&& r = run_for_at_least<Clock>(clock_cost_estimation_time, iters, time_clock);
        -: 2002:                std::vector<double> times;
        -: 2003:                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));
        -: 2004:                times.reserve(static_cast<size_t>(nsamples));
        -: 2005:                for ( int s = 0; s < nsamples; ++s ) {
        -: 2006:                    times.push_back( static_cast<double>(
        -: 2007:                        ( time_clock( r.iterations ) / r.iterations )
        -: 2008:                            .count() ) );
        -: 2009:                }
        -: 2010:                return {
        -: 2011:                    FDuration(mean(times.data(), times.data() + times.size())),
        -: 2012:                    classify_outliers(times.data(), times.data() + times.size()),
        -: 2013:                };
        -: 2014:            }
        -: 2015:
        -: 2016:            template <typename Clock>
        -: 2017:            Environment measure_environment() {
        -: 2018:#if defined(__clang__)
        -: 2019:#    pragma clang diagnostic push
        -: 2020:#    pragma clang diagnostic ignored "-Wexit-time-destructors"
        -: 2021:#endif
        -: 2022:                static Catch::Detail::unique_ptr<Environment> env;
        -: 2023:#if defined(__clang__)
        -: 2024:#    pragma clang diagnostic pop
        -: 2025:#endif
        -: 2026:                if (env) {
        -: 2027:                    return *env;
        -: 2028:                }
        -: 2029:
        -: 2030:                auto iters = Detail::warmup<Clock>();
        -: 2031:                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);
        -: 2032:                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);
        -: 2033:
        -: 2034:                env = Catch::Detail::make_unique<Environment>( Environment{resolution, cost} );
        -: 2035:                return *env;
        -: 2036:            }
        -: 2037:        } // namespace Detail
        -: 2038:    } // namespace Benchmark
        -: 2039:} // namespace Catch
        -: 2040:
        -: 2041:#endif // CATCH_ESTIMATE_CLOCK_HPP_INCLUDED
        -: 2042:
        -: 2043:
        -: 2044:// Adapted from donated nonius code.
        -: 2045:
        -: 2046:#ifndef CATCH_ANALYSE_HPP_INCLUDED
        -: 2047:#define CATCH_ANALYSE_HPP_INCLUDED
        -: 2048:
        -: 2049:
        -: 2050:
        -: 2051:// Adapted from donated nonius code.
        -: 2052:
        -: 2053:#ifndef CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2054:#define CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2055:
        -: 2056:
        -: 2057:#include <vector>
        -: 2058:
        -: 2059:namespace Catch {
        -: 2060:    namespace Benchmark {
        -: 2061:        struct SampleAnalysis {
        -: 2062:            std::vector<FDuration> samples;
        -: 2063:            Estimate<FDuration> mean;
        -: 2064:            Estimate<FDuration> standard_deviation;
        -: 2065:            OutlierClassification outliers;
        -: 2066:            double outlier_variance;
        -: 2067:        };
        -: 2068:    } // namespace Benchmark
        -: 2069:} // namespace Catch
        -: 2070:
        -: 2071:#endif // CATCH_SAMPLE_ANALYSIS_HPP_INCLUDED
        -: 2072:
        -: 2073:
        -: 2074:namespace Catch {
        -: 2075:    class IConfig;
        -: 2076:
        -: 2077:    namespace Benchmark {
        -: 2078:        namespace Detail {
        -: 2079:            SampleAnalysis analyse(const IConfig &cfg, FDuration* first, FDuration* last);
        -: 2080:        } // namespace Detail
        -: 2081:    } // namespace Benchmark
        -: 2082:} // namespace Catch
        -: 2083:
        -: 2084:#endif // CATCH_ANALYSE_HPP_INCLUDED
        -: 2085:
        -: 2086:#include <algorithm>
        -: 2087:#include <chrono>
        -: 2088:#include <exception>
        -: 2089:#include <string>
        -: 2090:#include <cmath>
        -: 2091:
        -: 2092:namespace Catch {
        -: 2093:    namespace Benchmark {
        -: 2094:        struct Benchmark {
        -: 2095:            Benchmark(std::string&& benchmarkName)
        -: 2096:                : name(CATCH_MOVE(benchmarkName)) {}
        -: 2097:
        -: 2098:            template <class FUN>
        -: 2099:            Benchmark(std::string&& benchmarkName , FUN &&func)
        -: 2100:                : fun(CATCH_MOVE(func)), name(CATCH_MOVE(benchmarkName)) {}
        -: 2101:
        -: 2102:            template <typename Clock>
        -: 2103:            ExecutionPlan prepare(const IConfig &cfg, Environment env) const {
        -: 2104:                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
        -: 2105:                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(cfg.benchmarkWarmupTime()));
        -: 2106:                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<IDuration>(run_time), 1, fun);
        -: 2107:                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));
        -: 2108:                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FDuration>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
        -: 2109:            }
        -: 2110:
        -: 2111:            template <typename Clock = default_clock>
        -: 2112:            void run() {
        -: 2113:                static_assert( Clock::is_steady,
        -: 2114:                               "Benchmarking clock should be steady" );
        -: 2115:                auto const* cfg = getCurrentContext().getConfig();
        -: 2116:
        -: 2117:                auto env = Detail::measure_environment<Clock>();
        -: 2118:
        -: 2119:                getResultCapture().benchmarkPreparing(name);
        -: 2120:                CATCH_TRY{
        -: 2121:                    auto plan = user_code([&] {
        -: 2122:                        return prepare<Clock>(*cfg, env);
        -: 2123:                    });
        -: 2124:
        -: 2125:                    BenchmarkInfo info {
        -: 2126:                        CATCH_MOVE(name),
        -: 2127:                        plan.estimated_duration.count(),
        -: 2128:                        plan.iterations_per_sample,
        -: 2129:                        cfg->benchmarkSamples(),
        -: 2130:                        cfg->benchmarkResamples(),
        -: 2131:                        env.clock_resolution.mean.count(),
        -: 2132:                        env.clock_cost.mean.count()
        -: 2133:                    };
        -: 2134:
        -: 2135:                    getResultCapture().benchmarkStarting(info);
        -: 2136:
        -: 2137:                    auto samples = user_code([&] {
        -: 2138:                        return plan.template run<Clock>(*cfg, env);
        -: 2139:                    });
        -: 2140:
        -: 2141:                    auto analysis = Detail::analyse(*cfg, samples.data(), samples.data() + samples.size());
        -: 2142:                    BenchmarkStats<> stats{ CATCH_MOVE(info), CATCH_MOVE(analysis.samples), analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
        -: 2143:                    getResultCapture().benchmarkEnded(stats);
        -: 2144:                } CATCH_CATCH_ANON (TestFailureException const&) {
        -: 2145:                    getResultCapture().benchmarkFailed("Benchmark failed due to failed assertion"_sr);
        -: 2146:                } CATCH_CATCH_ALL{
        -: 2147:                    getResultCapture().benchmarkFailed(translateActiveException());
        -: 2148:                    // We let the exception go further up so that the
        -: 2149:                    // test case is marked as failed.
        -: 2150:                    std::rethrow_exception(std::current_exception());
        -: 2151:                }
        -: 2152:            }
        -: 2153:
        -: 2154:            // sets lambda to be used in fun *and* executes benchmark!
        -: 2155:            template <typename Fun, std::enable_if_t<!Detail::is_related<Fun, Benchmark>::value, int> = 0>
        -: 2156:                Benchmark & operator=(Fun func) {
        -: 2157:                auto const* cfg = getCurrentContext().getConfig();
        -: 2158:                if (!cfg->skipBenchmarks()) {
        -: 2159:                    fun = Detail::BenchmarkFunction(func);
        -: 2160:                    run();
        -: 2161:                }
        -: 2162:                return *this;
        -: 2163:            }
        -: 2164:
        -: 2165:            explicit operator bool() {
        -: 2166:                return true;
        -: 2167:            }
        -: 2168:
        -: 2169:        private:
        -: 2170:            Detail::BenchmarkFunction fun;
        -: 2171:            std::string name;
        -: 2172:        };
        -: 2173:    }
        -: 2174:} // namespace Catch
        -: 2175:
        -: 2176:#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
        -: 2177:#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2
        -: 2178:
        -: 2179:#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
        -: 2180:    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        -: 2181:        BenchmarkName = [&](int benchmarkIndex)
        -: 2182:
        -: 2183:#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
        -: 2184:    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
        -: 2185:        BenchmarkName = [&]
        -: 2186:
        -: 2187:#if defined(CATCH_CONFIG_PREFIX_ALL)
        -: 2188:
        -: 2189:#define CATCH_BENCHMARK(...) \
        -: 2190:    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
        -: 2191:#define CATCH_BENCHMARK_ADVANCED(name) \
        -: 2192:    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)
        -: 2193:
        -: 2194:#else
        -: 2195:
        -: 2196:#define BENCHMARK(...) \
        -: 2197:    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
        -: 2198:#define BENCHMARK_ADVANCED(name) \
        -: 2199:    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(CATCH2_INTERNAL_BENCHMARK_), name)
        -: 2200:
        -: 2201:#endif
        -: 2202:
        -: 2203:#endif // CATCH_BENCHMARK_HPP_INCLUDED
        -: 2204:
        -: 2205:
        -: 2206:// Adapted from donated nonius code.
        -: 2207:
        -: 2208:#ifndef CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2209:#define CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2210:
        -: 2211:
        -: 2212:#include <type_traits>
        -: 2213:
        -: 2214:namespace Catch {
        -: 2215:    namespace Benchmark {
        -: 2216:        namespace Detail {
        -: 2217:            template <typename T, bool Destruct>
        -: 2218:            struct ObjectStorage
        -: 2219:            {
        -: 2220:                ObjectStorage() = default;
        -: 2221:
        -: 2222:                ObjectStorage(const ObjectStorage& other)
        -: 2223:                {
        -: 2224:                    new(&data) T(other.stored_object());
        -: 2225:                }
        -: 2226:
        -: 2227:                ObjectStorage(ObjectStorage&& other)
        -: 2228:                {
        -: 2229:                    new(data) T(CATCH_MOVE(other.stored_object()));
        -: 2230:                }
        -: 2231:
        -: 2232:                ~ObjectStorage() { destruct_on_exit<T>(); }
        -: 2233:
        -: 2234:                template <typename... Args>
        -: 2235:                void construct(Args&&... args)
        -: 2236:                {
        -: 2237:                    new (data) T(CATCH_FORWARD(args)...);
        -: 2238:                }
        -: 2239:
        -: 2240:                template <bool AllowManualDestruction = !Destruct>
        -: 2241:                std::enable_if_t<AllowManualDestruction> destruct()
        -: 2242:                {
        -: 2243:                    stored_object().~T();
        -: 2244:                }
        -: 2245:
        -: 2246:            private:
        -: 2247:                // If this is a constructor benchmark, destruct the underlying object
        -: 2248:                template <typename U>
        -: 2249:                void destruct_on_exit(std::enable_if_t<Destruct, U>* = nullptr) { destruct<true>(); }
        -: 2250:                // Otherwise, don't
        -: 2251:                template <typename U>
        -: 2252:                void destruct_on_exit(std::enable_if_t<!Destruct, U>* = nullptr) { }
        -: 2253:
        -: 2254:#if defined( __GNUC__ ) && __GNUC__ <= 6
        -: 2255:#    pragma GCC diagnostic push
        -: 2256:#    pragma GCC diagnostic ignored "-Wstrict-aliasing"
        -: 2257:#endif
        -: 2258:                T& stored_object() { return *reinterpret_cast<T*>( data ); }
        -: 2259:
        -: 2260:                T const& stored_object() const {
        -: 2261:                    return *reinterpret_cast<T const*>( data );
        -: 2262:                }
        -: 2263:#if defined( __GNUC__ ) && __GNUC__ <= 6
        -: 2264:#    pragma GCC diagnostic pop
        -: 2265:#endif
        -: 2266:
        -: 2267:                alignas( T ) unsigned char data[sizeof( T )]{};
        -: 2268:            };
        -: 2269:        } // namespace Detail
        -: 2270:
        -: 2271:        template <typename T>
        -: 2272:        using storage_for = Detail::ObjectStorage<T, true>;
        -: 2273:
        -: 2274:        template <typename T>
        -: 2275:        using destructable_object = Detail::ObjectStorage<T, false>;
        -: 2276:    } // namespace Benchmark
        -: 2277:} // namespace Catch
        -: 2278:
        -: 2279:#endif // CATCH_CONSTRUCTOR_HPP_INCLUDED
        -: 2280:
        -: 2281:#endif // CATCH_BENCHMARK_ALL_HPP_INCLUDED
        -: 2282:
        -: 2283:
        -: 2284:#ifndef CATCH_APPROX_HPP_INCLUDED
        -: 2285:#define CATCH_APPROX_HPP_INCLUDED
        -: 2286:
        -: 2287:
        -: 2288:
        -: 2289:#ifndef CATCH_TOSTRING_HPP_INCLUDED
        -: 2290:#define CATCH_TOSTRING_HPP_INCLUDED
        -: 2291:
        -: 2292:
        -: 2293:#include <vector>
        -: 2294:#include <cstddef>
        -: 2295:#include <type_traits>
        -: 2296:#include <string>
        -: 2297:
        -: 2298:
        -: 2299:
        -: 2300:
        -: 2301:/** \file
        -: 2302: * Wrapper for the WCHAR configuration option
        -: 2303: *
        -: 2304: * We want to support platforms that do not provide `wchar_t`, so we
        -: 2305: * sometimes have to disable providing wchar_t overloads through Catch2,
        -: 2306: * e.g. the StringMaker specialization for `std::wstring`.
        -: 2307: */
        -: 2308:
        -: 2309:#ifndef CATCH_CONFIG_WCHAR_HPP_INCLUDED
        -: 2310:#define CATCH_CONFIG_WCHAR_HPP_INCLUDED
        -: 2311:
        -: 2312:
        -: 2313:// We assume that WCHAR should be enabled by default, and only disabled
        -: 2314:// for a shortlist (so far only DJGPP) of compilers.
        -: 2315:
        -: 2316:#if defined(__DJGPP__)
        -: 2317:#  define CATCH_INTERNAL_CONFIG_NO_WCHAR
        -: 2318:#endif // __DJGPP__
        -: 2319:
        -: 2320:#if !defined( CATCH_INTERNAL_CONFIG_NO_WCHAR ) && \
        -: 2321:    !defined( CATCH_CONFIG_NO_WCHAR ) && \
        -: 2322:    !defined( CATCH_CONFIG_WCHAR )
        -: 2323:#    define CATCH_CONFIG_WCHAR
        -: 2324:#endif
        -: 2325:
        -: 2326:#endif // CATCH_CONFIG_WCHAR_HPP_INCLUDED
        -: 2327:
        -: 2328:
        -: 2329:#ifndef CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED
        -: 2330:#define CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED
        -: 2331:
        -: 2332:
        -: 2333:#include <iosfwd>
        -: 2334:#include <cstddef>
        -: 2335:#include <ostream>
        -: 2336:#include <string>
        -: 2337:
        -: 2338:namespace Catch {
        -: 2339:
        -: 2340:    class ReusableStringStream : Detail::NonCopyable {
        -: 2341:        std::size_t m_index;
        -: 2342:        std::ostream* m_oss;
        -: 2343:    public:
        -: 2344:        ReusableStringStream();
        -: 2345:        ~ReusableStringStream();
        -: 2346:
        -: 2347:        //! Returns the serialized state
        -: 2348:        std::string str() const;
        -: 2349:        //! Sets internal state to `str`
        -: 2350:        void str(std::string const& str);
        -: 2351:
        -: 2352:#if defined(__GNUC__) && !defined(__clang__)
        -: 2353:#pragma GCC diagnostic push
        -: 2354:// Old versions of GCC do not understand -Wnonnull-compare
        -: 2355:#pragma GCC diagnostic ignored "-Wpragmas"
        -: 2356:// Streaming a function pointer triggers Waddress and Wnonnull-compare
        -: 2357:// on GCC, because it implicitly converts it to bool and then decides
        -: 2358:// that the check it uses (a? true : false) is tautological and cannot
        -: 2359:// be null...
        -: 2360:#pragma GCC diagnostic ignored "-Waddress"
        -: 2361:#pragma GCC diagnostic ignored "-Wnonnull-compare"
        -: 2362:#endif
        -: 2363:
        -: 2364:        template<typename T>
        -: 2365:        auto operator << ( T const& value ) -> ReusableStringStream& {
        -: 2366:            *m_oss << value;
        -: 2367:            return *this;
        -: 2368:        }
        -: 2369:
        -: 2370:#if defined(__GNUC__) && !defined(__clang__)
        -: 2371:#pragma GCC diagnostic pop
        -: 2372:#endif
        -: 2373:        auto get() -> std::ostream& { return *m_oss; }
        -: 2374:    };
        -: 2375:}
        -: 2376:
        -: 2377:#endif // CATCH_REUSABLE_STRING_STREAM_HPP_INCLUDED
        -: 2378:
        -: 2379:
        -: 2380:#ifndef CATCH_VOID_TYPE_HPP_INCLUDED
        -: 2381:#define CATCH_VOID_TYPE_HPP_INCLUDED
        -: 2382:
        -: 2383:
        -: 2384:namespace Catch {
        -: 2385:    namespace Detail {
        -: 2386:
        -: 2387:        template <typename...>
        -: 2388:        struct make_void { using type = void; };
        -: 2389:
        -: 2390:        template <typename... Ts>
        -: 2391:        using void_t = typename make_void<Ts...>::type;
        -: 2392:
        -: 2393:    } // namespace Detail
        -: 2394:} // namespace Catch
        -: 2395:
        -: 2396:
        -: 2397:#endif // CATCH_VOID_TYPE_HPP_INCLUDED
        -: 2398:
        -: 2399:
        -: 2400:#ifndef CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2401:#define CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2402:
        -: 2403:
        -: 2404:#include <vector>
        -: 2405:
        -: 2406:namespace Catch {
        -: 2407:
        -: 2408:    namespace Detail {
        -: 2409:        struct EnumInfo {
        -: 2410:            StringRef m_name;
        -: 2411:            std::vector<std::pair<int, StringRef>> m_values;
        -: 2412:
        -: 2413:            ~EnumInfo();
        -: 2414:
        -: 2415:            StringRef lookup( int value ) const;
        -: 2416:        };
        -: 2417:    } // namespace Detail
        -: 2418:
        -: 2419:    class IMutableEnumValuesRegistry {
        -: 2420:    public:
        -: 2421:        virtual ~IMutableEnumValuesRegistry(); // = default;
        -: 2422:
        -: 2423:        virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;
        -: 2424:
        -: 2425:        template<typename E>
        -: 2426:        Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
        -: 2427:            static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
        -: 2428:            std::vector<int> intValues;
        -: 2429:            intValues.reserve( values.size() );
        -: 2430:            for( auto enumValue : values )
        -: 2431:                intValues.push_back( static_cast<int>( enumValue ) );
        -: 2432:            return registerEnum( enumName, allEnums, intValues );
        -: 2433:        }
        -: 2434:    };
        -: 2435:
        -: 2436:} // Catch
        -: 2437:
        -: 2438:#endif // CATCH_INTERFACES_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 2439:
        -: 2440:#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2441:#include <string_view>
        -: 2442:#endif
        -: 2443:
        -: 2444:#ifdef _MSC_VER
        -: 2445:#pragma warning(push)
        -: 2446:#pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
        -: 2447:#endif
        -: 2448:
        -: 2449:// We need a dummy global operator<< so we can bring it into Catch namespace later
        -: 2450:struct Catch_global_namespace_dummy{};
        -: 2451:std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
        -: 2452:
        -: 2453:namespace Catch {
        -: 2454:    // Bring in global namespace operator<< for ADL lookup in
        -: 2455:    // `IsStreamInsertable` below.
        -: 2456:    using ::operator<<;
        -: 2457:
        -: 2458:    namespace Detail {
        -: 2459:
        -: 2460:        inline std::size_t catch_strnlen(const char *str, std::size_t n) {
        -: 2461:            auto ret = std::char_traits<char>::find(str, n, '\0');
        -: 2462:            if (ret != nullptr) {
        -: 2463:                return static_cast<std::size_t>(ret - str);
        -: 2464:            }
        -: 2465:            return n;
        -: 2466:        }
        -: 2467:
        -: 2468:        constexpr StringRef unprintableString = "{?}"_sr;
        -: 2469:
        -: 2470:        //! Encases `string in quotes, and optionally escapes invisibles
        -: 2471:        std::string convertIntoString( StringRef string, bool escapeInvisibles );
        -: 2472:
        -: 2473:        //! Encases `string` in quotes, and escapes invisibles if user requested
        -: 2474:        //! it via CLI
        -: 2475:        std::string convertIntoString( StringRef string );
        -: 2476:
        -: 2477:        std::string rawMemoryToString( const void *object, std::size_t size );
        -: 2478:
        -: 2479:        template<typename T>
        -: 2480:        std::string rawMemoryToString( const T& object ) {
        -: 2481:          return rawMemoryToString( &object, sizeof(object) );
        -: 2482:        }
        -: 2483:
        -: 2484:        template<typename T>
        -: 2485:        class IsStreamInsertable {
        -: 2486:            template<typename Stream, typename U>
        -: 2487:            static auto test(int)
        -: 2488:                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());
        -: 2489:
        -: 2490:            template<typename, typename>
        -: 2491:            static auto test(...)->std::false_type;
        -: 2492:
        -: 2493:        public:
        -: 2494:            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
        -: 2495:        };
        -: 2496:
        -: 2497:        template<typename E>
        -: 2498:        std::string convertUnknownEnumToString( E e );
        -: 2499:
        -: 2500:        template<typename T>
        -: 2501:        std::enable_if_t<
        -: 2502:            !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
        -: 2503:        std::string> convertUnstreamable( T const& ) {
        -: 2504:            return std::string(Detail::unprintableString);
        -: 2505:        }
        -: 2506:        template<typename T>
        -: 2507:        std::enable_if_t<
        -: 2508:            !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
        -: 2509:         std::string> convertUnstreamable(T const& ex) {
        -: 2510:            return ex.what();
        -: 2511:        }
        -: 2512:
        -: 2513:
        -: 2514:        template<typename T>
        -: 2515:        std::enable_if_t<
        -: 2516:            std::is_enum<T>::value,
        -: 2517:        std::string> convertUnstreamable( T const& value ) {
        -: 2518:            return convertUnknownEnumToString( value );
        -: 2519:        }
        -: 2520:
        -: 2521:#if defined(_MANAGED)
        -: 2522:        //! Convert a CLR string to a utf8 std::string
        -: 2523:        template<typename T>
        -: 2524:        std::string clrReferenceToString( T^ ref ) {
        -: 2525:            if (ref == nullptr)
        -: 2526:                return std::string("null");
        -: 2527:            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());
        -: 2528:            cli::pin_ptr<System::Byte> p = &bytes[0];
        -: 2529:            return std::string(reinterpret_cast<char const *>(p), bytes->Length);
        -: 2530:        }
        -: 2531:#endif
        -: 2532:
        -: 2533:    } // namespace Detail
        -: 2534:
        -: 2535:
        -: 2536:    template <typename T, typename = void>
        -: 2537:    struct StringMaker {
        -: 2538:        template <typename Fake = T>
        -: 2539:        static
        -: 2540:        std::enable_if_t<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>
        -: 2541:            convert(const Fake& value) {
        -: 2542:                ReusableStringStream rss;
        -: 2543:                // NB: call using the function-like syntax to avoid ambiguity with
        -: 2544:                // user-defined templated operator<< under clang.
        -: 2545:                rss.operator<<(value);
        -: 2546:                return rss.str();
        -: 2547:        }
        -: 2548:
        -: 2549:        template <typename Fake = T>
        -: 2550:        static
        -: 2551:        std::enable_if_t<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>
        -: 2552:            convert( const Fake& value ) {
        -: 2553:#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
        -: 2554:            return Detail::convertUnstreamable(value);
        -: 2555:#else
        -: 2556:            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
        -: 2557:#endif
        -: 2558:        }
        -: 2559:    };
        -: 2560:
        -: 2561:    namespace Detail {
        -: 2562:
        -: 2563:        // This function dispatches all stringification requests inside of Catch.
        -: 2564:        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
        -: 2565:        template <typename T>
        3: 2566:        std::string stringify(const T& e) {
        3: 2567:            return ::Catch::StringMaker<std::remove_cv_t<std::remove_reference_t<T>>>::convert(e);
        -: 2568:        }
        -: 2569:
        -: 2570:        template<typename E>
        -: 2571:        std::string convertUnknownEnumToString( E e ) {
        -: 2572:            return ::Catch::Detail::stringify(static_cast<std::underlying_type_t<E>>(e));
        -: 2573:        }
        -: 2574:
        -: 2575:#if defined(_MANAGED)
        -: 2576:        template <typename T>
        -: 2577:        std::string stringify( T^ e ) {
        -: 2578:            return ::Catch::StringMaker<T^>::convert(e);
        -: 2579:        }
        -: 2580:#endif
        -: 2581:
        -: 2582:    } // namespace Detail
        -: 2583:
        -: 2584:    // Some predefined specializations
        -: 2585:
        -: 2586:    template<>
        -: 2587:    struct StringMaker<std::string> {
        -: 2588:        static std::string convert(const std::string& str);
        -: 2589:    };
        -: 2590:
        -: 2591:#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2592:    template<>
        -: 2593:    struct StringMaker<std::string_view> {
        -: 2594:        static std::string convert(std::string_view str);
        -: 2595:    };
        -: 2596:#endif
        -: 2597:
        -: 2598:    template<>
        -: 2599:    struct StringMaker<char const *> {
        -: 2600:        static std::string convert(char const * str);
        -: 2601:    };
        -: 2602:    template<>
        -: 2603:    struct StringMaker<char *> {
        -: 2604:        static std::string convert(char * str);
        -: 2605:    };
        -: 2606:
        -: 2607:#if defined(CATCH_CONFIG_WCHAR)
        -: 2608:    template<>
        -: 2609:    struct StringMaker<std::wstring> {
        -: 2610:        static std::string convert(const std::wstring& wstr);
        -: 2611:    };
        -: 2612:
        -: 2613:# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
        -: 2614:    template<>
        -: 2615:    struct StringMaker<std::wstring_view> {
        -: 2616:        static std::string convert(std::wstring_view str);
        -: 2617:    };
        -: 2618:# endif
        -: 2619:
        -: 2620:    template<>
        -: 2621:    struct StringMaker<wchar_t const *> {
        -: 2622:        static std::string convert(wchar_t const * str);
        -: 2623:    };
        -: 2624:    template<>
        -: 2625:    struct StringMaker<wchar_t *> {
        -: 2626:        static std::string convert(wchar_t * str);
        -: 2627:    };
        -: 2628:#endif // CATCH_CONFIG_WCHAR
        -: 2629:
        -: 2630:    template<size_t SZ>
        -: 2631:    struct StringMaker<char[SZ]> {
        -: 2632:        static std::string convert(char const* str) {
        -: 2633:            return Detail::convertIntoString(
        -: 2634:                StringRef( str, Detail::catch_strnlen( str, SZ ) ) );
        -: 2635:        }
        -: 2636:    };
        -: 2637:    template<size_t SZ>
        -: 2638:    struct StringMaker<signed char[SZ]> {
        -: 2639:        static std::string convert(signed char const* str) {
        -: 2640:            auto reinterpreted = reinterpret_cast<char const*>(str);
        -: 2641:            return Detail::convertIntoString(
        -: 2642:                StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));
        -: 2643:        }
        -: 2644:    };
        -: 2645:    template<size_t SZ>
        -: 2646:    struct StringMaker<unsigned char[SZ]> {
        -: 2647:        static std::string convert(unsigned char const* str) {
        -: 2648:            auto reinterpreted = reinterpret_cast<char const*>(str);
        -: 2649:            return Detail::convertIntoString(
        -: 2650:                StringRef(reinterpreted, Detail::catch_strnlen(reinterpreted, SZ)));
        -: 2651:        }
        -: 2652:    };
        -: 2653:
        -: 2654:#if defined(CATCH_CONFIG_CPP17_BYTE)
        -: 2655:    template<>
        -: 2656:    struct StringMaker<std::byte> {
        -: 2657:        static std::string convert(std::byte value);
        -: 2658:    };
        -: 2659:#endif // defined(CATCH_CONFIG_CPP17_BYTE)
        -: 2660:    template<>
        -: 2661:    struct StringMaker<int> {
        -: 2662:        static std::string convert(int value);
        -: 2663:    };
        -: 2664:    template<>
        -: 2665:    struct StringMaker<long> {
        -: 2666:        static std::string convert(long value);
        -: 2667:    };
        -: 2668:    template<>
        -: 2669:    struct StringMaker<long long> {
        -: 2670:        static std::string convert(long long value);
        -: 2671:    };
        -: 2672:    template<>
        -: 2673:    struct StringMaker<unsigned int> {
        -: 2674:        static std::string convert(unsigned int value);
        -: 2675:    };
        -: 2676:    template<>
        -: 2677:    struct StringMaker<unsigned long> {
        -: 2678:        static std::string convert(unsigned long value);
        -: 2679:    };
        -: 2680:    template<>
        -: 2681:    struct StringMaker<unsigned long long> {
        -: 2682:        static std::string convert(unsigned long long value);
        -: 2683:    };
        -: 2684:
        -: 2685:    template<>
        -: 2686:    struct StringMaker<bool> {
    #####: 2687:        static std::string convert(bool b) {
        -: 2688:            using namespace std::string_literals;
    #####: 2689:            return b ? "true"s : "false"s;
        -: 2690:        }
        -: 2691:    };
        -: 2692:
        -: 2693:    template<>
        -: 2694:    struct StringMaker<char> {
        -: 2695:        static std::string convert(char c);
        -: 2696:    };
        -: 2697:    template<>
        -: 2698:    struct StringMaker<signed char> {
        -: 2699:        static std::string convert(signed char value);
        -: 2700:    };
        -: 2701:    template<>
        -: 2702:    struct StringMaker<unsigned char> {
        -: 2703:        static std::string convert(unsigned char value);
        -: 2704:    };
        -: 2705:
        -: 2706:    template<>
        -: 2707:    struct StringMaker<std::nullptr_t> {
        -: 2708:        static std::string convert(std::nullptr_t) {
        -: 2709:            using namespace std::string_literals;
        -: 2710:            return "nullptr"s;
        -: 2711:        }
        -: 2712:    };
        -: 2713:
        -: 2714:    template<>
        -: 2715:    struct StringMaker<float> {
        -: 2716:        static std::string convert(float value);
        -: 2717:        CATCH_EXPORT static int precision;
        -: 2718:    };
        -: 2719:
        -: 2720:    template<>
        -: 2721:    struct StringMaker<double> {
        -: 2722:        static std::string convert(double value);
        -: 2723:        CATCH_EXPORT static int precision;
        -: 2724:    };
        -: 2725:
        -: 2726:    template <typename T>
        -: 2727:    struct StringMaker<T*> {
        -: 2728:        template <typename U>
        -: 2729:        static std::string convert(U* p) {
        -: 2730:            if (p) {
        -: 2731:                return ::Catch::Detail::rawMemoryToString(p);
        -: 2732:            } else {
        -: 2733:                return "nullptr";
        -: 2734:            }
        -: 2735:        }
        -: 2736:    };
        -: 2737:
        -: 2738:    template <typename R, typename C>
        -: 2739:    struct StringMaker<R C::*> {
        -: 2740:        static std::string convert(R C::* p) {
        -: 2741:            if (p) {
        -: 2742:                return ::Catch::Detail::rawMemoryToString(p);
        -: 2743:            } else {
        -: 2744:                return "nullptr";
        -: 2745:            }
        -: 2746:        }
        -: 2747:    };
        -: 2748:
        -: 2749:#if defined(_MANAGED)
        -: 2750:    template <typename T>
        -: 2751:    struct StringMaker<T^> {
        -: 2752:        static std::string convert( T^ ref ) {
        -: 2753:            return ::Catch::Detail::clrReferenceToString(ref);
        -: 2754:        }
        -: 2755:    };
        -: 2756:#endif
        -: 2757:
        -: 2758:    namespace Detail {
        -: 2759:        template<typename InputIterator, typename Sentinel = InputIterator>
        -: 2760:        std::string rangeToString(InputIterator first, Sentinel last) {
        -: 2761:            ReusableStringStream rss;
        -: 2762:            rss << "{ ";
        -: 2763:            if (first != last) {
        -: 2764:                rss << ::Catch::Detail::stringify(*first);
        -: 2765:                for (++first; first != last; ++first)
        -: 2766:                    rss << ", " << ::Catch::Detail::stringify(*first);
        -: 2767:            }
        -: 2768:            rss << " }";
        -: 2769:            return rss.str();
        -: 2770:        }
        -: 2771:    }
        -: 2772:
        -: 2773:} // namespace Catch
        -: 2774:
        -: 2775://////////////////////////////////////////////////////
        -: 2776:// Separate std-lib types stringification, so it can be selectively enabled
        -: 2777:// This means that we do not bring in their headers
        -: 2778:
        -: 2779:#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
        -: 2780:#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 2781:#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 2782:#  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
        -: 2783:#  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
        -: 2784:#endif
        -: 2785:
        -: 2786:// Separate std::pair specialization
        -: 2787:#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
        -: 2788:#include <utility>
        -: 2789:namespace Catch {
        -: 2790:    template<typename T1, typename T2>
        -: 2791:    struct StringMaker<std::pair<T1, T2> > {
        -: 2792:        static std::string convert(const std::pair<T1, T2>& pair) {
        -: 2793:            ReusableStringStream rss;
        -: 2794:            rss << "{ "
        -: 2795:                << ::Catch::Detail::stringify(pair.first)
        -: 2796:                << ", "
        -: 2797:                << ::Catch::Detail::stringify(pair.second)
        -: 2798:                << " }";
        -: 2799:            return rss.str();
        -: 2800:        }
        -: 2801:    };
        -: 2802:}
        -: 2803:#endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
        -: 2804:
        -: 2805:#if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)
        -: 2806:#include <optional>
        -: 2807:namespace Catch {
        -: 2808:    template<typename T>
        -: 2809:    struct StringMaker<std::optional<T> > {
        -: 2810:        static std::string convert(const std::optional<T>& optional) {
        -: 2811:            if (optional.has_value()) {
        -: 2812:                return ::Catch::Detail::stringify(*optional);
        -: 2813:            } else {
        -: 2814:                return "{ }";
        -: 2815:            }
        -: 2816:        }
        -: 2817:    };
        -: 2818:    template <>
        -: 2819:    struct StringMaker<std::nullopt_t> {
        -: 2820:        static std::string convert(const std::nullopt_t&) {
        -: 2821:            return "{ }";
        -: 2822:        }
        -: 2823:    };
        -: 2824:}
        -: 2825:#endif // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
        -: 2826:
        -: 2827:// Separate std::tuple specialization
        -: 2828:#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
        -: 2829:#include <tuple>
        -: 2830:namespace Catch {
        -: 2831:    namespace Detail {
        -: 2832:        template<
        -: 2833:            typename Tuple,
        -: 2834:            std::size_t N = 0,
        -: 2835:            bool = (N < std::tuple_size<Tuple>::value)
        -: 2836:            >
        -: 2837:            struct TupleElementPrinter {
        -: 2838:            static void print(const Tuple& tuple, std::ostream& os) {
        -: 2839:                os << (N ? ", " : " ")
        -: 2840:                    << ::Catch::Detail::stringify(std::get<N>(tuple));
        -: 2841:                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
        -: 2842:            }
        -: 2843:        };
        -: 2844:
        -: 2845:        template<
        -: 2846:            typename Tuple,
        -: 2847:            std::size_t N
        -: 2848:        >
        -: 2849:            struct TupleElementPrinter<Tuple, N, false> {
        -: 2850:            static void print(const Tuple&, std::ostream&) {}
        -: 2851:        };
        -: 2852:
        -: 2853:    }
        -: 2854:
        -: 2855:
        -: 2856:    template<typename ...Types>
        -: 2857:    struct StringMaker<std::tuple<Types...>> {
        -: 2858:        static std::string convert(const std::tuple<Types...>& tuple) {
        -: 2859:            ReusableStringStream rss;
        -: 2860:            rss << '{';
        -: 2861:            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
        -: 2862:            rss << " }";
        -: 2863:            return rss.str();
        -: 2864:        }
        -: 2865:    };
        -: 2866:}
        -: 2867:#endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
        -: 2868:
        -: 2869:#if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)
        -: 2870:#include <variant>
        -: 2871:namespace Catch {
        -: 2872:    template<>
        -: 2873:    struct StringMaker<std::monostate> {
        -: 2874:        static std::string convert(const std::monostate&) {
        -: 2875:            return "{ }";
        -: 2876:        }
        -: 2877:    };
        -: 2878:
        -: 2879:    template<typename... Elements>
        -: 2880:    struct StringMaker<std::variant<Elements...>> {
        -: 2881:        static std::string convert(const std::variant<Elements...>& variant) {
        -: 2882:            if (variant.valueless_by_exception()) {
        -: 2883:                return "{valueless variant}";
        -: 2884:            } else {
        -: 2885:                return std::visit(
        -: 2886:                    [](const auto& value) {
        -: 2887:                        return ::Catch::Detail::stringify(value);
        -: 2888:                    },
        -: 2889:                    variant
        -: 2890:                );
        -: 2891:            }
        -: 2892:        }
        -: 2893:    };
        -: 2894:}
        -: 2895:#endif // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
        -: 2896:
        -: 2897:namespace Catch {
        -: 2898:    // Import begin/ end from std here
        -: 2899:    using std::begin;
        -: 2900:    using std::end;
        -: 2901:
        -: 2902:    namespace Detail {
        -: 2903:        template <typename T, typename = void>
        -: 2904:        struct is_range_impl : std::false_type {};
        -: 2905:
        -: 2906:        template <typename T>
        -: 2907:        struct is_range_impl<T, void_t<decltype(begin(std::declval<T>()))>> : std::true_type {};
        -: 2908:    } // namespace Detail
        -: 2909:
        -: 2910:    template <typename T>
        -: 2911:    struct is_range : Detail::is_range_impl<T> {};
        -: 2912:
        -: 2913:#if defined(_MANAGED) // Managed types are never ranges
        -: 2914:    template <typename T>
        -: 2915:    struct is_range<T^> {
        -: 2916:        static const bool value = false;
        -: 2917:    };
        -: 2918:#endif
        -: 2919:
        -: 2920:    template<typename Range>
        -: 2921:    std::string rangeToString( Range const& range ) {
        -: 2922:        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
        -: 2923:    }
        -: 2924:
        -: 2925:    // Handle vector<bool> specially
        -: 2926:    template<typename Allocator>
        -: 2927:    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
        -: 2928:        ReusableStringStream rss;
        -: 2929:        rss << "{ ";
        -: 2930:        bool first = true;
        -: 2931:        for( bool b : v ) {
        -: 2932:            if( first )
        -: 2933:                first = false;
        -: 2934:            else
        -: 2935:                rss << ", ";
        -: 2936:            rss << ::Catch::Detail::stringify( b );
        -: 2937:        }
        -: 2938:        rss << " }";
        -: 2939:        return rss.str();
        -: 2940:    }
        -: 2941:
        -: 2942:    template<typename R>
        -: 2943:    struct StringMaker<R, std::enable_if_t<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>> {
        -: 2944:        static std::string convert( R const& range ) {
        -: 2945:            return rangeToString( range );
        -: 2946:        }
        -: 2947:    };
        -: 2948:
        -: 2949:    template <typename T, size_t SZ>
        -: 2950:    struct StringMaker<T[SZ]> {
        -: 2951:        static std::string convert(T const(&arr)[SZ]) {
        -: 2952:            return rangeToString(arr);
        -: 2953:        }
        -: 2954:    };
        -: 2955:
        -: 2956:
        -: 2957:} // namespace Catch
        -: 2958:
        -: 2959:// Separate std::chrono::duration specialization
        -: 2960:#include <ctime>
        -: 2961:#include <ratio>
        -: 2962:#include <chrono>
        -: 2963:
        -: 2964:
        -: 2965:namespace Catch {
        -: 2966:
        -: 2967:template <class Ratio>
        -: 2968:struct ratio_string {
        -: 2969:    static std::string symbol() {
        -: 2970:        Catch::ReusableStringStream rss;
        -: 2971:        rss << '[' << Ratio::num << '/'
        -: 2972:            << Ratio::den << ']';
        -: 2973:        return rss.str();
        -: 2974:    }
        -: 2975:};
        -: 2976:
        -: 2977:template <>
        -: 2978:struct ratio_string<std::atto> {
        -: 2979:    static char symbol() { return 'a'; }
        -: 2980:};
        -: 2981:template <>
        -: 2982:struct ratio_string<std::femto> {
        -: 2983:    static char symbol() { return 'f'; }
        -: 2984:};
        -: 2985:template <>
        -: 2986:struct ratio_string<std::pico> {
        -: 2987:    static char symbol() { return 'p'; }
        -: 2988:};
        -: 2989:template <>
        -: 2990:struct ratio_string<std::nano> {
        -: 2991:    static char symbol() { return 'n'; }
        -: 2992:};
        -: 2993:template <>
        -: 2994:struct ratio_string<std::micro> {
        -: 2995:    static char symbol() { return 'u'; }
        -: 2996:};
        -: 2997:template <>
        -: 2998:struct ratio_string<std::milli> {
        -: 2999:    static char symbol() { return 'm'; }
        -: 3000:};
        -: 3001:
        -: 3002:    ////////////
        -: 3003:    // std::chrono::duration specializations
        -: 3004:    template<typename Value, typename Ratio>
        -: 3005:    struct StringMaker<std::chrono::duration<Value, Ratio>> {
        -: 3006:        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
        -: 3007:            ReusableStringStream rss;
        -: 3008:            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
        -: 3009:            return rss.str();
        -: 3010:        }
        -: 3011:    };
        -: 3012:    template<typename Value>
        -: 3013:    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
        -: 3014:        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
        -: 3015:            ReusableStringStream rss;
        -: 3016:            rss << duration.count() << " s";
        -: 3017:            return rss.str();
        -: 3018:        }
        -: 3019:    };
        -: 3020:    template<typename Value>
        -: 3021:    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
        -: 3022:        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
        -: 3023:            ReusableStringStream rss;
        -: 3024:            rss << duration.count() << " m";
        -: 3025:            return rss.str();
        -: 3026:        }
        -: 3027:    };
        -: 3028:    template<typename Value>
        -: 3029:    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
        -: 3030:        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
        -: 3031:            ReusableStringStream rss;
        -: 3032:            rss << duration.count() << " h";
        -: 3033:            return rss.str();
        -: 3034:        }
        -: 3035:    };
        -: 3036:
        -: 3037:    ////////////
        -: 3038:    // std::chrono::time_point specialization
        -: 3039:    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
        -: 3040:    template<typename Clock, typename Duration>
        -: 3041:    struct StringMaker<std::chrono::time_point<Clock, Duration>> {
        -: 3042:        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
        -: 3043:            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
        -: 3044:        }
        -: 3045:    };
        -: 3046:    // std::chrono::time_point<system_clock> specialization
        -: 3047:    template<typename Duration>
        -: 3048:    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
        -: 3049:        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
        -: 3050:            auto converted = std::chrono::system_clock::to_time_t(time_point);
        -: 3051:
        -: 3052:#ifdef _MSC_VER
        -: 3053:            std::tm timeInfo = {};
        -: 3054:            gmtime_s(&timeInfo, &converted);
        -: 3055:#else
        -: 3056:            std::tm* timeInfo = std::gmtime(&converted);
        -: 3057:#endif
        -: 3058:
        -: 3059:            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -: 3060:            char timeStamp[timeStampSize];
        -: 3061:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -: 3062:
        -: 3063:#ifdef _MSC_VER
        -: 3064:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -: 3065:#else
        -: 3066:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -: 3067:#endif
        -: 3068:            return std::string(timeStamp, timeStampSize - 1);
        -: 3069:        }
        -: 3070:    };
        -: 3071:}
        -: 3072:
        -: 3073:
        -: 3074:#define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
        -: 3075:namespace Catch { \
        -: 3076:    template<> struct StringMaker<enumName> { \
        -: 3077:        static std::string convert( enumName value ) { \
        -: 3078:            static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
        -: 3079:            return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \
        -: 3080:        } \
        -: 3081:    }; \
        -: 3082:}
        -: 3083:
        -: 3084:#define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )
        -: 3085:
        -: 3086:#ifdef _MSC_VER
        -: 3087:#pragma warning(pop)
        -: 3088:#endif
        -: 3089:
        -: 3090:#endif // CATCH_TOSTRING_HPP_INCLUDED
        -: 3091:
        -: 3092:#include <type_traits>
        -: 3093:
        -: 3094:namespace Catch {
        -: 3095:
        -: 3096:    class Approx {
        -: 3097:    private:
        -: 3098:        bool equalityComparisonImpl(double other) const;
        -: 3099:        // Sets and validates the new margin (margin >= 0)
        -: 3100:        void setMargin(double margin);
        -: 3101:        // Sets and validates the new epsilon (0 < epsilon < 1)
        -: 3102:        void setEpsilon(double epsilon);
        -: 3103:
        -: 3104:    public:
        -: 3105:        explicit Approx ( double value );
        -: 3106:
        -: 3107:        static Approx custom();
        -: 3108:
        -: 3109:        Approx operator-() const;
        -: 3110:
        -: 3111:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3112:        Approx operator()( T const& value ) const {
        -: 3113:            Approx approx( static_cast<double>(value) );
        -: 3114:            approx.m_epsilon = m_epsilon;
        -: 3115:            approx.m_margin = m_margin;
        -: 3116:            approx.m_scale = m_scale;
        -: 3117:            return approx;
        -: 3118:        }
        -: 3119:
        -: 3120:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
       11: 3121:        explicit Approx( T const& value ): Approx(static_cast<double>(value))
       11: 3122:        {}
        -: 3123:
        -: 3124:
        -: 3125:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
       15: 3126:        friend bool operator == ( const T& lhs, Approx const& rhs ) {
       15: 3127:            auto lhs_v = static_cast<double>(lhs);
       15: 3128:            return rhs.equalityComparisonImpl(lhs_v);
        -: 3129:        }
        -: 3130:
        -: 3131:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3132:        friend bool operator == ( Approx const& lhs, const T& rhs ) {
        -: 3133:            return operator==( rhs, lhs );
        -: 3134:        }
        -: 3135:
        -: 3136:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3137:        friend bool operator != ( T const& lhs, Approx const& rhs ) {
        -: 3138:            return !operator==( lhs, rhs );
        -: 3139:        }
        -: 3140:
        -: 3141:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3142:        friend bool operator != ( Approx const& lhs, T const& rhs ) {
        -: 3143:            return !operator==( rhs, lhs );
        -: 3144:        }
        -: 3145:
        -: 3146:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3147:        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
        -: 3148:            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
        -: 3149:        }
        -: 3150:
        -: 3151:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3152:        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
        -: 3153:            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
        -: 3154:        }
        -: 3155:
        -: 3156:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3157:        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
        -: 3158:            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
        -: 3159:        }
        -: 3160:
        -: 3161:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3162:        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
        -: 3163:            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
        -: 3164:        }
        -: 3165:
        -: 3166:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
       15: 3167:        Approx& epsilon( T const& newEpsilon ) {
       15: 3168:            const auto epsilonAsDouble = static_cast<double>(newEpsilon);
       15: 3169:            setEpsilon(epsilonAsDouble);
       15: 3170:            return *this;
        -: 3171:        }
        -: 3172:
        -: 3173:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3174:        Approx& margin( T const& newMargin ) {
        -: 3175:            const auto marginAsDouble = static_cast<double>(newMargin);
        -: 3176:            setMargin(marginAsDouble);
        -: 3177:            return *this;
        -: 3178:        }
        -: 3179:
        -: 3180:        template <typename T, typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -: 3181:        Approx& scale( T const& newScale ) {
        -: 3182:            m_scale = static_cast<double>(newScale);
        -: 3183:            return *this;
        -: 3184:        }
        -: 3185:
        -: 3186:        std::string toString() const;
        -: 3187:
        -: 3188:    private:
        -: 3189:        double m_epsilon;
        -: 3190:        double m_margin;
        -: 3191:        double m_scale;
        -: 3192:        double m_value;
        -: 3193:    };
        -: 3194:
        -: 3195:namespace literals {
        -: 3196:    Approx operator ""_a(long double val);
        -: 3197:    Approx operator ""_a(unsigned long long val);
        -: 3198:} // end namespace literals
        -: 3199:
        -: 3200:template<>
        -: 3201:struct StringMaker<Catch::Approx> {
        -: 3202:    static std::string convert(Catch::Approx const& value);
        -: 3203:};
        -: 3204:
        -: 3205:} // end namespace Catch
        -: 3206:
        -: 3207:#endif // CATCH_APPROX_HPP_INCLUDED
        -: 3208:
        -: 3209:
        -: 3210:#ifndef CATCH_ASSERTION_INFO_HPP_INCLUDED
        -: 3211:#define CATCH_ASSERTION_INFO_HPP_INCLUDED
        -: 3212:
        -: 3213:
        -: 3214:
        -: 3215:#ifndef CATCH_SOURCE_LINE_INFO_HPP_INCLUDED
        -: 3216:#define CATCH_SOURCE_LINE_INFO_HPP_INCLUDED
        -: 3217:
        -: 3218:#include <cstddef>
        -: 3219:#include <iosfwd>
        -: 3220:
        -: 3221:namespace Catch {
        -: 3222:
        -: 3223:    struct SourceLineInfo {
        -: 3224:
        -: 3225:        SourceLineInfo() = delete;
       90: 3226:        constexpr SourceLineInfo( char const* _file, std::size_t _line ) noexcept:
       45: 3227:            file( _file ),
       45: 3228:            line( _line )
       90: 3229:        {}
        -: 3230:
        -: 3231:        bool operator == ( SourceLineInfo const& other ) const noexcept;
        -: 3232:        bool operator < ( SourceLineInfo const& other ) const noexcept;
        -: 3233:
        -: 3234:        char const* file;
        -: 3235:        std::size_t line;
        -: 3236:
        -: 3237:        friend std::ostream& operator << (std::ostream& os, SourceLineInfo const& info);
        -: 3238:    };
        -: 3239:}
        -: 3240:
        -: 3241:#define CATCH_INTERNAL_LINEINFO \
        -: 3242:    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
        -: 3243:
        -: 3244:#endif // CATCH_SOURCE_LINE_INFO_HPP_INCLUDED
        -: 3245:
        -: 3246:namespace Catch {
        -: 3247:
        -: 3248:    struct AssertionInfo {
        -: 3249:        // AssertionInfo() = delete;
        -: 3250:
        -: 3251:        StringRef macroName;
        -: 3252:        SourceLineInfo lineInfo;
        -: 3253:        StringRef capturedExpression;
        -: 3254:        ResultDisposition::Flags resultDisposition;
        -: 3255:    };
        -: 3256:
        -: 3257:} // end namespace Catch
        -: 3258:
        -: 3259:#endif // CATCH_ASSERTION_INFO_HPP_INCLUDED
        -: 3260:
        -: 3261:
        -: 3262:#ifndef CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -: 3263:#define CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -: 3264:
        -: 3265:
        -: 3266:
        -: 3267:#ifndef CATCH_LAZY_EXPR_HPP_INCLUDED
        -: 3268:#define CATCH_LAZY_EXPR_HPP_INCLUDED
        -: 3269:
        -: 3270:#include <iosfwd>
        -: 3271:
        -: 3272:namespace Catch {
        -: 3273:
        -: 3274:    class ITransientExpression;
        -: 3275:
        -: 3276:    class LazyExpression {
        -: 3277:        friend class AssertionHandler;
        -: 3278:        friend struct AssertionStats;
        -: 3279:        friend class RunContext;
        -: 3280:
        -: 3281:        ITransientExpression const* m_transientExpression = nullptr;
        -: 3282:        bool m_isNegated;
        -: 3283:    public:
        -: 3284:        LazyExpression( bool isNegated ):
        -: 3285:            m_isNegated(isNegated)
        -: 3286:        {}
        -: 3287:        LazyExpression(LazyExpression const& other) = default;
        -: 3288:        LazyExpression& operator = ( LazyExpression const& ) = delete;
        -: 3289:
        -: 3290:        explicit operator bool() const {
        -: 3291:            return m_transientExpression != nullptr;
        -: 3292:        }
        -: 3293:
        -: 3294:        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
        -: 3295:    };
        -: 3296:
        -: 3297:} // namespace Catch
        -: 3298:
        -: 3299:#endif // CATCH_LAZY_EXPR_HPP_INCLUDED
        -: 3300:
        -: 3301:#include <string>
        -: 3302:
        -: 3303:namespace Catch {
        -: 3304:
        -: 3305:    struct AssertionResultData
        -: 3306:    {
        -: 3307:        AssertionResultData() = delete;
        -: 3308:
        -: 3309:        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );
        -: 3310:
        -: 3311:        std::string message;
        -: 3312:        mutable std::string reconstructedExpression;
        -: 3313:        LazyExpression lazyExpression;
        -: 3314:        ResultWas::OfType resultType;
        -: 3315:
        -: 3316:        std::string reconstructExpression() const;
        -: 3317:    };
        -: 3318:
        -: 3319:    class AssertionResult {
        -: 3320:    public:
        -: 3321:        AssertionResult() = delete;
        -: 3322:        AssertionResult( AssertionInfo const& info, AssertionResultData&& data );
        -: 3323:
        -: 3324:        bool isOk() const;
        -: 3325:        bool succeeded() const;
        -: 3326:        ResultWas::OfType getResultType() const;
        -: 3327:        bool hasExpression() const;
        -: 3328:        bool hasMessage() const;
        -: 3329:        std::string getExpression() const;
        -: 3330:        std::string getExpressionInMacro() const;
        -: 3331:        bool hasExpandedExpression() const;
        -: 3332:        std::string getExpandedExpression() const;
        -: 3333:        StringRef getMessage() const;
        -: 3334:        SourceLineInfo getSourceInfo() const;
        -: 3335:        StringRef getTestMacroName() const;
        -: 3336:
        -: 3337:    //protected:
        -: 3338:        AssertionInfo m_info;
        -: 3339:        AssertionResultData m_resultData;
        -: 3340:    };
        -: 3341:
        -: 3342:} // end namespace Catch
        -: 3343:
        -: 3344:#endif // CATCH_ASSERTION_RESULT_HPP_INCLUDED
        -: 3345:
        -: 3346:
        -: 3347:#ifndef CATCH_CONFIG_HPP_INCLUDED
        -: 3348:#define CATCH_CONFIG_HPP_INCLUDED
        -: 3349:
        -: 3350:
        -: 3351:
        -: 3352:#ifndef CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3353:#define CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3354:
        -: 3355:#ifdef __clang__
        -: 3356:#pragma clang diagnostic push
        -: 3357:#pragma clang diagnostic ignored "-Wpadded"
        -: 3358:#endif
        -: 3359:
        -: 3360:
        -: 3361:
        -: 3362:#ifndef CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3363:#define CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3364:
        -: 3365:
        -: 3366:
        -: 3367:#ifndef CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3368:#define CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3369:
        -: 3370:namespace Catch {
        -: 3371:
        -: 3372:    enum class CaseSensitive { Yes, No };
        -: 3373:
        -: 3374:} // namespace Catch
        -: 3375:
        -: 3376:#endif // CATCH_CASE_SENSITIVE_HPP_INCLUDED
        -: 3377:
        -: 3378:#include <string>
        -: 3379:
        -: 3380:namespace Catch
        -: 3381:{
        -: 3382:    class WildcardPattern {
        -: 3383:        enum WildcardPosition {
        -: 3384:            NoWildcard = 0,
        -: 3385:            WildcardAtStart = 1,
        -: 3386:            WildcardAtEnd = 2,
        -: 3387:            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        -: 3388:        };
        -: 3389:
        -: 3390:    public:
        -: 3391:
        -: 3392:        WildcardPattern( std::string const& pattern, CaseSensitive caseSensitivity );
        -: 3393:        bool matches( std::string const& str ) const;
        -: 3394:
        -: 3395:    private:
        -: 3396:        std::string normaliseString( std::string const& str ) const;
        -: 3397:        CaseSensitive m_caseSensitivity;
        -: 3398:        WildcardPosition m_wildcard = NoWildcard;
        -: 3399:        std::string m_pattern;
        -: 3400:    };
        -: 3401:}
        -: 3402:
        -: 3403:#endif // CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3404:
        -: 3405:#include <iosfwd>
        -: 3406:#include <string>
        -: 3407:#include <vector>
        -: 3408:
        -: 3409:namespace Catch {
        -: 3410:
        -: 3411:    class IConfig;
        -: 3412:    struct TestCaseInfo;
        -: 3413:    class TestCaseHandle;
        -: 3414:
        -: 3415:    class TestSpec {
        -: 3416:
        -: 3417:        class Pattern {
        -: 3418:        public:
        -: 3419:            explicit Pattern( std::string const& name );
        -: 3420:            virtual ~Pattern();
        -: 3421:            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
        -: 3422:            std::string const& name() const;
        -: 3423:        private:
        -: 3424:            virtual void serializeTo( std::ostream& out ) const = 0;
        -: 3425:            // Writes string that would be reparsed into the pattern
        -: 3426:            friend std::ostream& operator<<(std::ostream& out,
        -: 3427:                                            Pattern const& pattern) {
        -: 3428:                pattern.serializeTo( out );
        -: 3429:                return out;
        -: 3430:            }
        -: 3431:
        -: 3432:            std::string const m_name;
        -: 3433:        };
        -: 3434:
        -: 3435:        class NamePattern : public Pattern {
        -: 3436:        public:
        -: 3437:            explicit NamePattern( std::string const& name, std::string const& filterString );
        -: 3438:            bool matches( TestCaseInfo const& testCase ) const override;
        -: 3439:        private:
        -: 3440:            void serializeTo( std::ostream& out ) const override;
        -: 3441:
        -: 3442:            WildcardPattern m_wildcardPattern;
        -: 3443:        };
        -: 3444:
        -: 3445:        class TagPattern : public Pattern {
        -: 3446:        public:
        -: 3447:            explicit TagPattern( std::string const& tag, std::string const& filterString );
        -: 3448:            bool matches( TestCaseInfo const& testCase ) const override;
        -: 3449:        private:
        -: 3450:            void serializeTo( std::ostream& out ) const override;
        -: 3451:
        -: 3452:            std::string m_tag;
        -: 3453:        };
        -: 3454:
        -: 3455:        struct Filter {
        -: 3456:            std::vector<Detail::unique_ptr<Pattern>> m_required;
        -: 3457:            std::vector<Detail::unique_ptr<Pattern>> m_forbidden;
        -: 3458:
        -: 3459:            //! Serializes this filter into a string that would be parsed into
        -: 3460:            //! an equivalent filter
        -: 3461:            void serializeTo( std::ostream& out ) const;
        -: 3462:            friend std::ostream& operator<<(std::ostream& out, Filter const& f) {
        -: 3463:                f.serializeTo( out );
        -: 3464:                return out;
        -: 3465:            }
        -: 3466:
        -: 3467:            bool matches( TestCaseInfo const& testCase ) const;
        -: 3468:        };
        -: 3469:
        -: 3470:        static std::string extractFilterName( Filter const& filter );
        -: 3471:
        -: 3472:    public:
        -: 3473:        struct FilterMatch {
        -: 3474:            std::string name;
        -: 3475:            std::vector<TestCaseHandle const*> tests;
        -: 3476:        };
        -: 3477:        using Matches = std::vector<FilterMatch>;
        -: 3478:        using vectorStrings = std::vector<std::string>;
        -: 3479:
        -: 3480:        bool hasFilters() const;
        -: 3481:        bool matches( TestCaseInfo const& testCase ) const;
        -: 3482:        Matches matchesByFilter( std::vector<TestCaseHandle> const& testCases, IConfig const& config ) const;
        -: 3483:        const vectorStrings & getInvalidSpecs() const;
        -: 3484:
        -: 3485:    private:
        -: 3486:        std::vector<Filter> m_filters;
        -: 3487:        std::vector<std::string> m_invalidSpecs;
        -: 3488:
        -: 3489:        friend class TestSpecParser;
        -: 3490:        //! Serializes this test spec into a string that would be parsed into
        -: 3491:        //! equivalent test spec
        -: 3492:        void serializeTo( std::ostream& out ) const;
        -: 3493:        friend std::ostream& operator<<(std::ostream& out,
        -: 3494:                                        TestSpec const& spec) {
        -: 3495:            spec.serializeTo( out );
        -: 3496:            return out;
        -: 3497:        }
        -: 3498:    };
        -: 3499:}
        -: 3500:
        -: 3501:#ifdef __clang__
        -: 3502:#pragma clang diagnostic pop
        -: 3503:#endif
        -: 3504:
        -: 3505:#endif // CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3506:
        -: 3507:
        -: 3508:#ifndef CATCH_OPTIONAL_HPP_INCLUDED
        -: 3509:#define CATCH_OPTIONAL_HPP_INCLUDED
        -: 3510:
        -: 3511:
        -: 3512:#include <cassert>
        -: 3513:
        -: 3514:namespace Catch {
        -: 3515:
        -: 3516:    // An optional type
        -: 3517:    template<typename T>
        -: 3518:    class Optional {
        -: 3519:    public:
        -: 3520:        Optional(): nullableValue( nullptr ) {}
        -: 3521:        ~Optional() { reset(); }
        -: 3522:
        -: 3523:        Optional( T const& _value ):
        -: 3524:            nullableValue( new ( storage ) T( _value ) ) {}
        -: 3525:        Optional( T&& _value ):
        -: 3526:            nullableValue( new ( storage ) T( CATCH_MOVE( _value ) ) ) {}
        -: 3527:
        -: 3528:        Optional& operator=( T const& _value ) {
        -: 3529:            reset();
        -: 3530:            nullableValue = new ( storage ) T( _value );
        -: 3531:            return *this;
        -: 3532:        }
        -: 3533:        Optional& operator=( T&& _value ) {
        -: 3534:            reset();
        -: 3535:            nullableValue = new ( storage ) T( CATCH_MOVE( _value ) );
        -: 3536:            return *this;
        -: 3537:        }
        -: 3538:
        -: 3539:        Optional( Optional const& _other ):
        -: 3540:            nullableValue( _other ? new ( storage ) T( *_other ) : nullptr ) {}
        -: 3541:        Optional( Optional&& _other ):
        -: 3542:            nullableValue( _other ? new ( storage ) T( CATCH_MOVE( *_other ) )
        -: 3543:                                  : nullptr ) {}
        -: 3544:
        -: 3545:        Optional& operator=( Optional const& _other ) {
        -: 3546:            if ( &_other != this ) {
        -: 3547:                reset();
        -: 3548:                if ( _other ) { nullableValue = new ( storage ) T( *_other ); }
        -: 3549:            }
        -: 3550:            return *this;
        -: 3551:        }
        -: 3552:        Optional& operator=( Optional&& _other ) {
        -: 3553:            if ( &_other != this ) {
        -: 3554:                reset();
        -: 3555:                if ( _other ) {
        -: 3556:                    nullableValue = new ( storage ) T( CATCH_MOVE( *_other ) );
        -: 3557:                }
        -: 3558:            }
        -: 3559:            return *this;
        -: 3560:        }
        -: 3561:
        -: 3562:        void reset() {
        -: 3563:            if ( nullableValue ) { nullableValue->~T(); }
        -: 3564:            nullableValue = nullptr;
        -: 3565:        }
        -: 3566:
        -: 3567:        T& operator*() {
        -: 3568:            assert(nullableValue);
        -: 3569:            return *nullableValue;
        -: 3570:        }
        -: 3571:        T const& operator*() const {
        -: 3572:            assert(nullableValue);
        -: 3573:            return *nullableValue;
        -: 3574:        }
        -: 3575:        T* operator->() {
        -: 3576:            assert(nullableValue);
        -: 3577:            return nullableValue;
        -: 3578:        }
        -: 3579:        const T* operator->() const {
        -: 3580:            assert(nullableValue);
        -: 3581:            return nullableValue;
        -: 3582:        }
        -: 3583:
        -: 3584:        T valueOr( T const& defaultValue ) const {
        -: 3585:            return nullableValue ? *nullableValue : defaultValue;
        -: 3586:        }
        -: 3587:
        -: 3588:        bool some() const { return nullableValue != nullptr; }
        -: 3589:        bool none() const { return nullableValue == nullptr; }
        -: 3590:
        -: 3591:        bool operator !() const { return nullableValue == nullptr; }
        -: 3592:        explicit operator bool() const {
        -: 3593:            return some();
        -: 3594:        }
        -: 3595:
        -: 3596:        friend bool operator==(Optional const& a, Optional const& b) {
        -: 3597:            if (a.none() && b.none()) {
        -: 3598:                return true;
        -: 3599:            } else if (a.some() && b.some()) {
        -: 3600:                return *a == *b;
        -: 3601:            } else {
        -: 3602:                return false;
        -: 3603:            }
        -: 3604:        }
        -: 3605:        friend bool operator!=(Optional const& a, Optional const& b) {
        -: 3606:            return !( a == b );
        -: 3607:        }
        -: 3608:
        -: 3609:    private:
        -: 3610:        T* nullableValue;
        -: 3611:        alignas(alignof(T)) char storage[sizeof(T)];
        -: 3612:    };
        -: 3613:
        -: 3614:} // end namespace Catch
        -: 3615:
        -: 3616:#endif // CATCH_OPTIONAL_HPP_INCLUDED
        -: 3617:
        -: 3618:
        -: 3619:#ifndef CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED
        -: 3620:#define CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED
        -: 3621:
        -: 3622:#include <cstdint>
        -: 3623:
        -: 3624:namespace Catch {
        -: 3625:
        -: 3626:    enum class GenerateFrom {
        -: 3627:        Time,
        -: 3628:        RandomDevice,
        -: 3629:        //! Currently equivalent to RandomDevice, but can change at any point
        -: 3630:        Default
        -: 3631:    };
        -: 3632:
        -: 3633:    std::uint32_t generateRandomSeed(GenerateFrom from);
        -: 3634:
        -: 3635:} // end namespace Catch
        -: 3636:
        -: 3637:#endif // CATCH_RANDOM_SEED_GENERATION_HPP_INCLUDED
        -: 3638:
        -: 3639:
        -: 3640:#ifndef CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED
        -: 3641:#define CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED
        -: 3642:
        -: 3643:
        -: 3644:#include <map>
        -: 3645:#include <string>
        -: 3646:#include <vector>
        -: 3647:
        -: 3648:namespace Catch {
        -: 3649:
        -: 3650:    enum class ColourMode : std::uint8_t;
        -: 3651:
        -: 3652:    namespace Detail {
        -: 3653:        //! Splits the reporter spec into reporter name and kv-pair options
        -: 3654:        std::vector<std::string> splitReporterSpec( StringRef reporterSpec );
        -: 3655:
        -: 3656:        Optional<ColourMode> stringToColourMode( StringRef colourMode );
        -: 3657:    }
        -: 3658:
        -: 3659:    /**
        -: 3660:     * Structured reporter spec that a reporter can be created from
        -: 3661:     *
        -: 3662:     * Parsing has been validated, but semantics have not. This means e.g.
        -: 3663:     * that the colour mode is known to Catch2, but it might not be
        -: 3664:     * compiled into the binary, and the output filename might not be
        -: 3665:     * openable.
        -: 3666:     */
        -: 3667:    class ReporterSpec {
        -: 3668:        std::string m_name;
        -: 3669:        Optional<std::string> m_outputFileName;
        -: 3670:        Optional<ColourMode> m_colourMode;
        -: 3671:        std::map<std::string, std::string> m_customOptions;
        -: 3672:
        -: 3673:        friend bool operator==( ReporterSpec const& lhs,
        -: 3674:                                ReporterSpec const& rhs );
        -: 3675:        friend bool operator!=( ReporterSpec const& lhs,
        -: 3676:                                ReporterSpec const& rhs ) {
        -: 3677:            return !( lhs == rhs );
        -: 3678:        }
        -: 3679:
        -: 3680:    public:
        -: 3681:        ReporterSpec(
        -: 3682:            std::string name,
        -: 3683:            Optional<std::string> outputFileName,
        -: 3684:            Optional<ColourMode> colourMode,
        -: 3685:            std::map<std::string, std::string> customOptions );
        -: 3686:
        -: 3687:        std::string const& name() const { return m_name; }
        -: 3688:
        -: 3689:        Optional<std::string> const& outputFile() const {
        -: 3690:            return m_outputFileName;
        -: 3691:        }
        -: 3692:
        -: 3693:        Optional<ColourMode> const& colourMode() const { return m_colourMode; }
        -: 3694:
        -: 3695:        std::map<std::string, std::string> const& customOptions() const {
        -: 3696:            return m_customOptions;
        -: 3697:        }
        -: 3698:    };
        -: 3699:
        -: 3700:    /**
        -: 3701:     * Parses provided reporter spec string into
        -: 3702:     *
        -: 3703:     * Returns empty optional on errors, e.g.
        -: 3704:     *  * field that is not first and not a key+value pair
        -: 3705:     *  * duplicated keys in kv pair
        -: 3706:     *  * unknown catch reporter option
        -: 3707:     *  * empty key/value in an custom kv pair
        -: 3708:     *  * ...
        -: 3709:     */
        -: 3710:    Optional<ReporterSpec> parseReporterSpec( StringRef reporterSpec );
        -: 3711:
        -: 3712:}
        -: 3713:
        -: 3714:#endif // CATCH_REPORTER_SPEC_PARSER_HPP_INCLUDED
        -: 3715:
        -: 3716:#include <chrono>
        -: 3717:#include <map>
        -: 3718:#include <string>
        -: 3719:#include <vector>
        -: 3720:
        -: 3721:namespace Catch {
        -: 3722:
        -: 3723:    class IStream;
        -: 3724:
        -: 3725:    /**
        -: 3726:     * `ReporterSpec` but with the defaults filled in.
        -: 3727:     *
        -: 3728:     * Like `ReporterSpec`, the semantics are unchecked.
        -: 3729:     */
        -: 3730:    struct ProcessedReporterSpec {
        -: 3731:        std::string name;
        -: 3732:        std::string outputFilename;
        -: 3733:        ColourMode colourMode;
        -: 3734:        std::map<std::string, std::string> customOptions;
        -: 3735:        friend bool operator==( ProcessedReporterSpec const& lhs,
        -: 3736:                                ProcessedReporterSpec const& rhs );
        -: 3737:        friend bool operator!=( ProcessedReporterSpec const& lhs,
        -: 3738:                                ProcessedReporterSpec const& rhs ) {
        -: 3739:            return !( lhs == rhs );
        -: 3740:        }
        -: 3741:    };
        -: 3742:
        -: 3743:    struct ConfigData {
        -: 3744:
        -: 3745:        bool listTests = false;
        -: 3746:        bool listTags = false;
        -: 3747:        bool listReporters = false;
        -: 3748:        bool listListeners = false;
        -: 3749:
        -: 3750:        bool showSuccessfulTests = false;
        -: 3751:        bool shouldDebugBreak = false;
        -: 3752:        bool noThrow = false;
        -: 3753:        bool showHelp = false;
        -: 3754:        bool showInvisibles = false;
        -: 3755:        bool filenamesAsTags = false;
        -: 3756:        bool libIdentify = false;
        -: 3757:        bool allowZeroTests = false;
        -: 3758:
        -: 3759:        int abortAfter = -1;
        -: 3760:        uint32_t rngSeed = generateRandomSeed(GenerateFrom::Default);
        -: 3761:
        -: 3762:        unsigned int shardCount = 1;
        -: 3763:        unsigned int shardIndex = 0;
        -: 3764:
        -: 3765:        bool skipBenchmarks = false;
        -: 3766:        bool benchmarkNoAnalysis = false;
        -: 3767:        unsigned int benchmarkSamples = 100;
        -: 3768:        double benchmarkConfidenceInterval = 0.95;
        -: 3769:        unsigned int benchmarkResamples = 100'000;
        -: 3770:        std::chrono::milliseconds::rep benchmarkWarmupTime = 100;
        -: 3771:
        -: 3772:        Verbosity verbosity = Verbosity::Normal;
        -: 3773:        WarnAbout::What warnings = WarnAbout::Nothing;
        -: 3774:        ShowDurations showDurations = ShowDurations::DefaultForReporter;
        -: 3775:        double minDuration = -1;
        -: 3776:        TestRunOrder runOrder = TestRunOrder::Declared;
        -: 3777:        ColourMode defaultColourMode = ColourMode::PlatformDefault;
        -: 3778:        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
        -: 3779:
        -: 3780:        std::string defaultOutputFilename;
        -: 3781:        std::string name;
        -: 3782:        std::string processName;
        -: 3783:        std::vector<ReporterSpec> reporterSpecifications;
        -: 3784:
        -: 3785:        std::vector<std::string> testsOrTags;
        -: 3786:        std::vector<std::string> sectionsToRun;
        -: 3787:    };
        -: 3788:
        -: 3789:
        -: 3790:    class Config : public IConfig {
        -: 3791:    public:
        -: 3792:
        -: 3793:        Config() = default;
        -: 3794:        Config( ConfigData const& data );
        -: 3795:        ~Config() override; // = default in the cpp file
        -: 3796:
        -: 3797:        bool listTests() const;
        -: 3798:        bool listTags() const;
        -: 3799:        bool listReporters() const;
        -: 3800:        bool listListeners() const;
        -: 3801:
        -: 3802:        std::vector<ReporterSpec> const& getReporterSpecs() const;
        -: 3803:        std::vector<ProcessedReporterSpec> const&
        -: 3804:        getProcessedReporterSpecs() const;
        -: 3805:
        -: 3806:        std::vector<std::string> const& getTestsOrTags() const override;
        -: 3807:        std::vector<std::string> const& getSectionsToRun() const override;
        -: 3808:
        -: 3809:        TestSpec const& testSpec() const override;
        -: 3810:        bool hasTestFilters() const override;
        -: 3811:
        -: 3812:        bool showHelp() const;
        -: 3813:
        -: 3814:        // IConfig interface
        -: 3815:        bool allowThrows() const override;
        -: 3816:        StringRef name() const override;
        -: 3817:        bool includeSuccessfulResults() const override;
        -: 3818:        bool warnAboutMissingAssertions() const override;
        -: 3819:        bool warnAboutUnmatchedTestSpecs() const override;
        -: 3820:        bool zeroTestsCountAsSuccess() const override;
        -: 3821:        ShowDurations showDurations() const override;
        -: 3822:        double minDuration() const override;
        -: 3823:        TestRunOrder runOrder() const override;
        -: 3824:        uint32_t rngSeed() const override;
        -: 3825:        unsigned int shardCount() const override;
        -: 3826:        unsigned int shardIndex() const override;
        -: 3827:        ColourMode defaultColourMode() const override;
        -: 3828:        bool shouldDebugBreak() const override;
        -: 3829:        int abortAfter() const override;
        -: 3830:        bool showInvisibles() const override;
        -: 3831:        Verbosity verbosity() const override;
        -: 3832:        bool skipBenchmarks() const override;
        -: 3833:        bool benchmarkNoAnalysis() const override;
        -: 3834:        unsigned int benchmarkSamples() const override;
        -: 3835:        double benchmarkConfidenceInterval() const override;
        -: 3836:        unsigned int benchmarkResamples() const override;
        -: 3837:        std::chrono::milliseconds benchmarkWarmupTime() const override;
        -: 3838:
        -: 3839:    private:
        -: 3840:        // Reads Bazel env vars and applies them to the config
        -: 3841:        void readBazelEnvVars();
        -: 3842:
        -: 3843:        ConfigData m_data;
        -: 3844:        std::vector<ProcessedReporterSpec> m_processedReporterSpecs;
        -: 3845:        TestSpec m_testSpec;
        -: 3846:        bool m_hasTestFilters = false;
        -: 3847:    };
        -: 3848:} // end namespace Catch
        -: 3849:
        -: 3850:#endif // CATCH_CONFIG_HPP_INCLUDED
        -: 3851:
        -: 3852:
        -: 3853:#ifndef CATCH_GET_RANDOM_SEED_HPP_INCLUDED
        -: 3854:#define CATCH_GET_RANDOM_SEED_HPP_INCLUDED
        -: 3855:
        -: 3856:#include <cstdint>
        -: 3857:
        -: 3858:namespace Catch {
        -: 3859:    //! Returns Catch2's current RNG seed.
        -: 3860:    std::uint32_t getSeed();
        -: 3861:}
        -: 3862:
        -: 3863:#endif // CATCH_GET_RANDOM_SEED_HPP_INCLUDED
        -: 3864:
        -: 3865:
        -: 3866:#ifndef CATCH_MESSAGE_HPP_INCLUDED
        -: 3867:#define CATCH_MESSAGE_HPP_INCLUDED
        -: 3868:
        -: 3869:
        -: 3870:
        -: 3871:
        -: 3872:/** \file
        -: 3873: * Wrapper for the CATCH_CONFIG_PREFIX_MESSAGES configuration option
        -: 3874: *
        -: 3875: * CATCH_CONFIG_PREFIX_ALL can be used to avoid clashes with other macros
        -: 3876: * by prepending CATCH_. This may not be desirable if the only clashes are with
        -: 3877: * logger macros such as INFO and WARN. In this cases
        -: 3878: * CATCH_CONFIG_PREFIX_MESSAGES can be used to only prefix a small subset
        -: 3879: * of relevant macros.
        -: 3880: *
        -: 3881: */
        -: 3882:
        -: 3883:#ifndef CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED
        -: 3884:#define CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED
        -: 3885:
        -: 3886:
        -: 3887:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_PREFIX_MESSAGES)
        -: 3888:    #define CATCH_CONFIG_PREFIX_MESSAGES
        -: 3889:#endif
        -: 3890:
        -: 3891:#endif // CATCH_CONFIG_PREFIX_MESSAGES_HPP_INCLUDED
        -: 3892:
        -: 3893:
        -: 3894:#ifndef CATCH_STREAM_END_STOP_HPP_INCLUDED
        -: 3895:#define CATCH_STREAM_END_STOP_HPP_INCLUDED
        -: 3896:
        -: 3897:
        -: 3898:namespace Catch {
        -: 3899:
        -: 3900:    // Use this in variadic streaming macros to allow
        -: 3901:    //    << +StreamEndStop
        -: 3902:    // as well as
        -: 3903:    //    << stuff +StreamEndStop
        -: 3904:    struct StreamEndStop {
        -: 3905:        constexpr StringRef operator+() const { return StringRef(); }
        -: 3906:
        -: 3907:        template <typename T>
        -: 3908:        constexpr friend T const& operator+( T const& value, StreamEndStop ) {
        -: 3909:            return value;
        -: 3910:        }
        -: 3911:    };
        -: 3912:
        -: 3913:} // namespace Catch
        -: 3914:
        -: 3915:#endif // CATCH_STREAM_END_STOP_HPP_INCLUDED
        -: 3916:
        -: 3917:
        -: 3918:#ifndef CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 3919:#define CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 3920:
        -: 3921:
        -: 3922:#include <string>
        -: 3923:
        -: 3924:namespace Catch {
        -: 3925:
        -: 3926:    struct MessageInfo {
        -: 3927:        MessageInfo(    StringRef _macroName,
        -: 3928:                        SourceLineInfo const& _lineInfo,
        -: 3929:                        ResultWas::OfType _type );
        -: 3930:
        -: 3931:        StringRef macroName;
        -: 3932:        std::string message;
        -: 3933:        SourceLineInfo lineInfo;
        -: 3934:        ResultWas::OfType type;
        -: 3935:        unsigned int sequence;
        -: 3936:
        -: 3937:        bool operator == (MessageInfo const& other) const {
        -: 3938:            return sequence == other.sequence;
        -: 3939:        }
        -: 3940:        bool operator < (MessageInfo const& other) const {
        -: 3941:            return sequence < other.sequence;
        -: 3942:        }
        -: 3943:    private:
        -: 3944:        static unsigned int globalCount;
        -: 3945:    };
        -: 3946:
        -: 3947:} // end namespace Catch
        -: 3948:
        -: 3949:#endif // CATCH_MESSAGE_INFO_HPP_INCLUDED
        -: 3950:
        -: 3951:#include <string>
        -: 3952:#include <vector>
        -: 3953:
        -: 3954:namespace Catch {
        -: 3955:
        -: 3956:    struct SourceLineInfo;
        -: 3957:    class IResultCapture;
        -: 3958:
        -: 3959:    struct MessageStream {
        -: 3960:
        -: 3961:        template<typename T>
        -: 3962:        MessageStream& operator << ( T const& value ) {
        -: 3963:            m_stream << value;
        -: 3964:            return *this;
        -: 3965:        }
        -: 3966:
        -: 3967:        ReusableStringStream m_stream;
        -: 3968:    };
        -: 3969:
        -: 3970:    struct MessageBuilder : MessageStream {
        -: 3971:        MessageBuilder( StringRef macroName,
        -: 3972:                        SourceLineInfo const& lineInfo,
        -: 3973:                        ResultWas::OfType type ):
        -: 3974:            m_info(macroName, lineInfo, type) {}
        -: 3975:
        -: 3976:        template<typename T>
        -: 3977:        MessageBuilder&& operator << ( T const& value ) && {
        -: 3978:            m_stream << value;
        -: 3979:            return CATCH_MOVE(*this);
        -: 3980:        }
        -: 3981:
        -: 3982:        MessageInfo m_info;
        -: 3983:    };
        -: 3984:
        -: 3985:    class ScopedMessage {
        -: 3986:    public:
        -: 3987:        explicit ScopedMessage( MessageBuilder&& builder );
        -: 3988:        ScopedMessage( ScopedMessage& duplicate ) = delete;
        -: 3989:        ScopedMessage( ScopedMessage&& old ) noexcept;
        -: 3990:        ~ScopedMessage();
        -: 3991:
        -: 3992:        MessageInfo m_info;
        -: 3993:        bool m_moved = false;
        -: 3994:    };
        -: 3995:
        -: 3996:    class Capturer {
        -: 3997:        std::vector<MessageInfo> m_messages;
        -: 3998:        IResultCapture& m_resultCapture;
        -: 3999:        size_t m_captured = 0;
        -: 4000:    public:
        -: 4001:        Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
        -: 4002:
        -: 4003:        Capturer(Capturer const&) = delete;
        -: 4004:        Capturer& operator=(Capturer const&) = delete;
        -: 4005:
        -: 4006:        ~Capturer();
        -: 4007:
        -: 4008:        void captureValue( size_t index, std::string const& value );
        -: 4009:
        -: 4010:        template<typename T>
        -: 4011:        void captureValues( size_t index, T const& value ) {
        -: 4012:            captureValue( index, Catch::Detail::stringify( value ) );
        -: 4013:        }
        -: 4014:
        -: 4015:        template<typename T, typename... Ts>
        -: 4016:        void captureValues( size_t index, T const& value, Ts const&... values ) {
        -: 4017:            captureValue( index, Catch::Detail::stringify(value) );
        -: 4018:            captureValues( index+1, values... );
        -: 4019:        }
        -: 4020:    };
        -: 4021:
        -: 4022:} // end namespace Catch
        -: 4023:
        -: 4024:///////////////////////////////////////////////////////////////////////////////
        -: 4025:#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
        -: 4026:    do { \
        -: 4027:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
        -: 4028:        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
        -: 4029:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 4030:    } while( false )
        -: 4031:
        -: 4032:///////////////////////////////////////////////////////////////////////////////
        -: 4033:#define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
        -: 4034:    Catch::Capturer varName( macroName##_catch_sr,        \
        -: 4035:                             CATCH_INTERNAL_LINEINFO,     \
        -: 4036:                             Catch::ResultWas::Info,      \
        -: 4037:                             #__VA_ARGS__##_catch_sr );   \
        -: 4038:    varName.captureValues( 0, __VA_ARGS__ )
        -: 4039:
        -: 4040:///////////////////////////////////////////////////////////////////////////////
        -: 4041:#define INTERNAL_CATCH_INFO( macroName, log ) \
        -: 4042:    const Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )
        -: 4043:
        -: 4044:///////////////////////////////////////////////////////////////////////////////
        -: 4045:#define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
        -: 4046:    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )
        -: 4047:
        -: 4048:
        -: 4049:#if defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)
        -: 4050:
        -: 4051:  #define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
        -: 4052:  #define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )
        -: 4053:  #define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -: 4054:  #define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE", __VA_ARGS__ )
        -: 4055:
        -: 4056:#elif defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)
        -: 4057:
        -: 4058:  #define CATCH_INFO( msg )          (void)(0)
        -: 4059:  #define CATCH_UNSCOPED_INFO( msg ) (void)(0)
        -: 4060:  #define CATCH_WARN( msg )          (void)(0)
        -: 4061:  #define CATCH_CAPTURE( ... )       (void)(0)
        -: 4062:
        -: 4063:#elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && !defined(CATCH_CONFIG_DISABLE)
        -: 4064:
        -: 4065:  #define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
        -: 4066:  #define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )
        -: 4067:  #define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -: 4068:  #define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE", __VA_ARGS__ )
        -: 4069:
        -: 4070:#elif !defined(CATCH_CONFIG_PREFIX_MESSAGES) && defined(CATCH_CONFIG_DISABLE)
        -: 4071:
        -: 4072:  #define INFO( msg )          (void)(0)
        -: 4073:  #define UNSCOPED_INFO( msg ) (void)(0)
        -: 4074:  #define WARN( msg )          (void)(0)
        -: 4075:  #define CAPTURE( ... )       (void)(0)
        -: 4076:
        -: 4077:#endif // end of user facing macro declarations
        -: 4078:
        -: 4079:
        -: 4080:
        -: 4081:
        -: 4082:#endif // CATCH_MESSAGE_HPP_INCLUDED
        -: 4083:
        -: 4084:
        -: 4085:#ifndef CATCH_SECTION_INFO_HPP_INCLUDED
        -: 4086:#define CATCH_SECTION_INFO_HPP_INCLUDED
        -: 4087:
        -: 4088:
        -: 4089:
        -: 4090:#ifndef CATCH_TOTALS_HPP_INCLUDED
        -: 4091:#define CATCH_TOTALS_HPP_INCLUDED
        -: 4092:
        -: 4093:#include <cstdint>
        -: 4094:
        -: 4095:namespace Catch {
        -: 4096:
        -: 4097:    struct Counts {
        -: 4098:        Counts operator - ( Counts const& other ) const;
        -: 4099:        Counts& operator += ( Counts const& other );
        -: 4100:
        -: 4101:        std::uint64_t total() const;
        -: 4102:        bool allPassed() const;
        -: 4103:        bool allOk() const;
        -: 4104:
        -: 4105:        std::uint64_t passed = 0;
        -: 4106:        std::uint64_t failed = 0;
        -: 4107:        std::uint64_t failedButOk = 0;
        -: 4108:        std::uint64_t skipped = 0;
        -: 4109:    };
        -: 4110:
        -: 4111:    struct Totals {
        -: 4112:
        -: 4113:        Totals operator - ( Totals const& other ) const;
        -: 4114:        Totals& operator += ( Totals const& other );
        -: 4115:
        -: 4116:        Totals delta( Totals const& prevTotals ) const;
        -: 4117:
        -: 4118:        Counts assertions;
        -: 4119:        Counts testCases;
        -: 4120:    };
        -: 4121:}
        -: 4122:
        -: 4123:#endif // CATCH_TOTALS_HPP_INCLUDED
        -: 4124:
        -: 4125:#include <string>
        -: 4126:
        -: 4127:namespace Catch {
        -: 4128:
        -: 4129:    struct SectionInfo {
        -: 4130:        // The last argument is ignored, so that people can write
        -: 4131:        // SECTION("ShortName", "Proper description that is long") and
        -: 4132:        // still use the `-c` flag comfortably.
        -: 4133:        SectionInfo( SourceLineInfo const& _lineInfo, std::string _name,
        -: 4134:                    const char* const = nullptr ):
        -: 4135:            name(CATCH_MOVE(_name)),
        -: 4136:            lineInfo(_lineInfo)
        -: 4137:            {}
        -: 4138:
        -: 4139:        std::string name;
        -: 4140:        SourceLineInfo lineInfo;
        -: 4141:    };
        -: 4142:
        -: 4143:    struct SectionEndInfo {
        -: 4144:        SectionInfo sectionInfo;
        -: 4145:        Counts prevAssertions;
        -: 4146:        double durationInSeconds;
        -: 4147:    };
        -: 4148:
        -: 4149:} // end namespace Catch
        -: 4150:
        -: 4151:#endif // CATCH_SECTION_INFO_HPP_INCLUDED
        -: 4152:
        -: 4153:
        -: 4154:#ifndef CATCH_SESSION_HPP_INCLUDED
        -: 4155:#define CATCH_SESSION_HPP_INCLUDED
        -: 4156:
        -: 4157:
        -: 4158:
        -: 4159:#ifndef CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4160:#define CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4161:
        -: 4162:
        -: 4163:
        -: 4164:#ifndef CATCH_CLARA_HPP_INCLUDED
        -: 4165:#define CATCH_CLARA_HPP_INCLUDED
        -: 4166:
        -: 4167:#if defined( __clang__ )
        -: 4168:#    pragma clang diagnostic push
        -: 4169:#    pragma clang diagnostic ignored "-Wweak-vtables"
        -: 4170:#    pragma clang diagnostic ignored "-Wshadow"
        -: 4171:#    pragma clang diagnostic ignored "-Wdeprecated"
        -: 4172:#endif
        -: 4173:
        -: 4174:#if defined( __GNUC__ )
        -: 4175:#    pragma GCC diagnostic push
        -: 4176:#    pragma GCC diagnostic ignored "-Wsign-conversion"
        -: 4177:#endif
        -: 4178:
        -: 4179:#ifndef CLARA_CONFIG_OPTIONAL_TYPE
        -: 4180:#    ifdef __has_include
        -: 4181:#        if __has_include( <optional>) && __cplusplus >= 201703L
        -: 4182:#            include <optional>
        -: 4183:#            define CLARA_CONFIG_OPTIONAL_TYPE std::optional
        -: 4184:#        endif
        -: 4185:#    endif
        -: 4186:#endif
        -: 4187:
        -: 4188:
        -: 4189:#include <cassert>
        -: 4190:#include <memory>
        -: 4191:#include <ostream>
        -: 4192:#include <sstream>
        -: 4193:#include <string>
        -: 4194:#include <type_traits>
        -: 4195:#include <vector>
        -: 4196:
        -: 4197:namespace Catch {
        -: 4198:    namespace Clara {
        -: 4199:
        -: 4200:        class Args;
        -: 4201:        class Parser;
        -: 4202:
        -: 4203:        // enum of result types from a parse
        -: 4204:        enum class ParseResultType {
        -: 4205:            Matched,
        -: 4206:            NoMatch,
        -: 4207:            ShortCircuitAll,
        -: 4208:            ShortCircuitSame
        -: 4209:        };
        -: 4210:
        -: 4211:        struct accept_many_t {};
        -: 4212:        constexpr accept_many_t accept_many {};
        -: 4213:
        -: 4214:        namespace Detail {
        -: 4215:            struct fake_arg {
        -: 4216:                template <typename T>
        -: 4217:                operator T();
        -: 4218:            };
        -: 4219:
        -: 4220:            template <typename F, typename = void>
        -: 4221:            struct is_unary_function : std::false_type {};
        -: 4222:
        -: 4223:            template <typename F>
        -: 4224:            struct is_unary_function<
        -: 4225:                F,
        -: 4226:                Catch::Detail::void_t<decltype(
        -: 4227:                    std::declval<F>()( fake_arg() ) )
        -: 4228:                >
        -: 4229:            > : std::true_type {};
        -: 4230:
        -: 4231:            // Traits for extracting arg and return type of lambdas (for single
        -: 4232:            // argument lambdas)
        -: 4233:            template <typename L>
        -: 4234:            struct UnaryLambdaTraits
        -: 4235:                : UnaryLambdaTraits<decltype( &L::operator() )> {};
        -: 4236:
        -: 4237:            template <typename ClassT, typename ReturnT, typename... Args>
        -: 4238:            struct UnaryLambdaTraits<ReturnT ( ClassT::* )( Args... ) const> {
        -: 4239:                static const bool isValid = false;
        -: 4240:            };
        -: 4241:
        -: 4242:            template <typename ClassT, typename ReturnT, typename ArgT>
        -: 4243:            struct UnaryLambdaTraits<ReturnT ( ClassT::* )( ArgT ) const> {
        -: 4244:                static const bool isValid = true;
        -: 4245:                using ArgType = std::remove_const_t<std::remove_reference_t<ArgT>>;
        -: 4246:                using ReturnType = ReturnT;
        -: 4247:            };
        -: 4248:
        -: 4249:            class TokenStream;
        -: 4250:
        -: 4251:            // Wraps a token coming from a token stream. These may not directly
        -: 4252:            // correspond to strings as a single string may encode an option +
        -: 4253:            // its argument if the : or = form is used
        -: 4254:            enum class TokenType { Option, Argument };
        -: 4255:            struct Token {
        -: 4256:                TokenType type;
        -: 4257:                StringRef token;
        -: 4258:            };
        -: 4259:
        -: 4260:            // Abstracts iterators into args as a stream of tokens, with option
        -: 4261:            // arguments uniformly handled
        -: 4262:            class TokenStream {
        -: 4263:                using Iterator = std::vector<StringRef>::const_iterator;
        -: 4264:                Iterator it;
        -: 4265:                Iterator itEnd;
        -: 4266:                std::vector<Token> m_tokenBuffer;
        -: 4267:                void loadBuffer();
        -: 4268:
        -: 4269:            public:
        -: 4270:                explicit TokenStream( Args const& args );
        -: 4271:                TokenStream( Iterator it, Iterator itEnd );
        -: 4272:
        -: 4273:                explicit operator bool() const {
        -: 4274:                    return !m_tokenBuffer.empty() || it != itEnd;
        -: 4275:                }
        -: 4276:
        -: 4277:                size_t count() const {
        -: 4278:                    return m_tokenBuffer.size() + ( itEnd - it );
        -: 4279:                }
        -: 4280:
        -: 4281:                Token operator*() const {
        -: 4282:                    assert( !m_tokenBuffer.empty() );
        -: 4283:                    return m_tokenBuffer.front();
        -: 4284:                }
        -: 4285:
        -: 4286:                Token const* operator->() const {
        -: 4287:                    assert( !m_tokenBuffer.empty() );
        -: 4288:                    return &m_tokenBuffer.front();
        -: 4289:                }
        -: 4290:
        -: 4291:                TokenStream& operator++();
        -: 4292:            };
        -: 4293:
        -: 4294:            //! Denotes type of a parsing result
        -: 4295:            enum class ResultType {
        -: 4296:                Ok,          ///< No errors
        -: 4297:                LogicError,  ///< Error in user-specified arguments for
        -: 4298:                             ///< construction
        -: 4299:                RuntimeError ///< Error in parsing inputs
        -: 4300:            };
        -: 4301:
        -: 4302:            class ResultBase {
        -: 4303:            protected:
        -: 4304:                ResultBase( ResultType type ): m_type( type ) {}
        -: 4305:                virtual ~ResultBase(); // = default;
        -: 4306:
        -: 4307:
        -: 4308:                ResultBase(ResultBase const&) = default;
        -: 4309:                ResultBase& operator=(ResultBase const&) = default;
        -: 4310:                ResultBase(ResultBase&&) = default;
        -: 4311:                ResultBase& operator=(ResultBase&&) = default;
        -: 4312:
        -: 4313:                virtual void enforceOk() const = 0;
        -: 4314:
        -: 4315:                ResultType m_type;
        -: 4316:            };
        -: 4317:
        -: 4318:            template <typename T>
        -: 4319:            class ResultValueBase : public ResultBase {
        -: 4320:            public:
        -: 4321:                T const& value() const& {
        -: 4322:                    enforceOk();
        -: 4323:                    return m_value;
        -: 4324:                }
        -: 4325:                T&& value() && {
        -: 4326:                    enforceOk();
        -: 4327:                    return CATCH_MOVE( m_value );
        -: 4328:                }
        -: 4329:
        -: 4330:            protected:
        -: 4331:                ResultValueBase( ResultType type ): ResultBase( type ) {}
        -: 4332:
        -: 4333:                ResultValueBase( ResultValueBase const& other ):
        -: 4334:                    ResultBase( other ) {
        -: 4335:                    if ( m_type == ResultType::Ok )
        -: 4336:                        new ( &m_value ) T( other.m_value );
        -: 4337:                }
        -: 4338:                ResultValueBase( ResultValueBase&& other ):
        -: 4339:                    ResultBase( other ) {
        -: 4340:                    if ( m_type == ResultType::Ok )
        -: 4341:                        new ( &m_value ) T( CATCH_MOVE(other.m_value) );
        -: 4342:                }
        -: 4343:
        -: 4344:
        -: 4345:                ResultValueBase( ResultType, T const& value ):
        -: 4346:                    ResultBase( ResultType::Ok ) {
        -: 4347:                    new ( &m_value ) T( value );
        -: 4348:                }
        -: 4349:                ResultValueBase( ResultType, T&& value ):
        -: 4350:                    ResultBase( ResultType::Ok ) {
        -: 4351:                    new ( &m_value ) T( CATCH_MOVE(value) );
        -: 4352:                }
        -: 4353:
        -: 4354:                ResultValueBase& operator=( ResultValueBase const& other ) {
        -: 4355:                    if ( m_type == ResultType::Ok )
        -: 4356:                        m_value.~T();
        -: 4357:                    ResultBase::operator=( other );
        -: 4358:                    if ( m_type == ResultType::Ok )
        -: 4359:                        new ( &m_value ) T( other.m_value );
        -: 4360:                    return *this;
        -: 4361:                }
        -: 4362:                ResultValueBase& operator=( ResultValueBase&& other ) {
        -: 4363:                    if ( m_type == ResultType::Ok ) m_value.~T();
        -: 4364:                    ResultBase::operator=( other );
        -: 4365:                    if ( m_type == ResultType::Ok )
        -: 4366:                        new ( &m_value ) T( CATCH_MOVE(other.m_value) );
        -: 4367:                    return *this;
        -: 4368:                }
        -: 4369:
        -: 4370:
        -: 4371:                ~ResultValueBase() override {
        -: 4372:                    if ( m_type == ResultType::Ok )
        -: 4373:                        m_value.~T();
        -: 4374:                }
        -: 4375:
        -: 4376:                union {
        -: 4377:                    T m_value;
        -: 4378:                };
        -: 4379:            };
        -: 4380:
        -: 4381:            template <> class ResultValueBase<void> : public ResultBase {
        -: 4382:            protected:
        -: 4383:                using ResultBase::ResultBase;
        -: 4384:            };
        -: 4385:
        -: 4386:            template <typename T = void>
        -: 4387:            class BasicResult : public ResultValueBase<T> {
        -: 4388:            public:
        -: 4389:                template <typename U>
        -: 4390:                explicit BasicResult( BasicResult<U> const& other ):
        -: 4391:                    ResultValueBase<T>( other.type() ),
        -: 4392:                    m_errorMessage( other.errorMessage() ) {
        -: 4393:                    assert( type() != ResultType::Ok );
        -: 4394:                }
        -: 4395:
        -: 4396:                template <typename U>
        -: 4397:                static auto ok( U&& value ) -> BasicResult {
        -: 4398:                    return { ResultType::Ok, CATCH_FORWARD(value) };
        -: 4399:                }
        -: 4400:                static auto ok() -> BasicResult { return { ResultType::Ok }; }
        -: 4401:                static auto logicError( std::string&& message )
        -: 4402:                    -> BasicResult {
        -: 4403:                    return { ResultType::LogicError, CATCH_MOVE(message) };
        -: 4404:                }
        -: 4405:                static auto runtimeError( std::string&& message )
        -: 4406:                    -> BasicResult {
        -: 4407:                    return { ResultType::RuntimeError, CATCH_MOVE(message) };
        -: 4408:                }
        -: 4409:
        -: 4410:                explicit operator bool() const {
        -: 4411:                    return m_type == ResultType::Ok;
        -: 4412:                }
        -: 4413:                auto type() const -> ResultType { return m_type; }
        -: 4414:                auto errorMessage() const -> std::string const& {
        -: 4415:                    return m_errorMessage;
        -: 4416:                }
        -: 4417:
        -: 4418:            protected:
        -: 4419:                void enforceOk() const override {
        -: 4420:
        -: 4421:                    // Errors shouldn't reach this point, but if they do
        -: 4422:                    // the actual error message will be in m_errorMessage
        -: 4423:                    assert( m_type != ResultType::LogicError );
        -: 4424:                    assert( m_type != ResultType::RuntimeError );
        -: 4425:                    if ( m_type != ResultType::Ok )
        -: 4426:                        std::abort();
        -: 4427:                }
        -: 4428:
        -: 4429:                std::string
        -: 4430:                    m_errorMessage; // Only populated if resultType is an error
        -: 4431:
        -: 4432:                BasicResult( ResultType type,
        -: 4433:                             std::string&& message ):
        -: 4434:                    ResultValueBase<T>( type ), m_errorMessage( CATCH_MOVE(message) ) {
        -: 4435:                    assert( m_type != ResultType::Ok );
        -: 4436:                }
        -: 4437:
        -: 4438:                using ResultValueBase<T>::ResultValueBase;
        -: 4439:                using ResultBase::m_type;
        -: 4440:            };
        -: 4441:
        -: 4442:            class ParseState {
        -: 4443:            public:
        -: 4444:                ParseState( ParseResultType type,
        -: 4445:                            TokenStream remainingTokens );
        -: 4446:
        -: 4447:                ParseResultType type() const { return m_type; }
        -: 4448:                TokenStream const& remainingTokens() const& {
        -: 4449:                    return m_remainingTokens;
        -: 4450:                }
        -: 4451:                TokenStream&& remainingTokens() && {
        -: 4452:                    return CATCH_MOVE( m_remainingTokens );
        -: 4453:                }
        -: 4454:
        -: 4455:            private:
        -: 4456:                ParseResultType m_type;
        -: 4457:                TokenStream m_remainingTokens;
        -: 4458:            };
        -: 4459:
        -: 4460:            using Result = BasicResult<void>;
        -: 4461:            using ParserResult = BasicResult<ParseResultType>;
        -: 4462:            using InternalParseResult = BasicResult<ParseState>;
        -: 4463:
        -: 4464:            struct HelpColumns {
        -: 4465:                std::string left;
        -: 4466:                StringRef descriptions;
        -: 4467:            };
        -: 4468:
        -: 4469:            template <typename T>
        -: 4470:            ParserResult convertInto( std::string const& source, T& target ) {
        -: 4471:                std::stringstream ss( source );
        -: 4472:                ss >> target;
        -: 4473:                if ( ss.fail() ) {
        -: 4474:                    return ParserResult::runtimeError(
        -: 4475:                        "Unable to convert '" + source +
        -: 4476:                        "' to destination type" );
        -: 4477:                } else {
        -: 4478:                    return ParserResult::ok( ParseResultType::Matched );
        -: 4479:                }
        -: 4480:            }
        -: 4481:            ParserResult convertInto( std::string const& source,
        -: 4482:                                      std::string& target );
        -: 4483:            ParserResult convertInto( std::string const& source, bool& target );
        -: 4484:
        -: 4485:#ifdef CLARA_CONFIG_OPTIONAL_TYPE
        -: 4486:            template <typename T>
        -: 4487:            auto convertInto( std::string const& source,
        -: 4488:                              CLARA_CONFIG_OPTIONAL_TYPE<T>& target )
        -: 4489:                -> ParserResult {
        -: 4490:                T temp;
        -: 4491:                auto result = convertInto( source, temp );
        -: 4492:                if ( result )
        -: 4493:                    target = CATCH_MOVE( temp );
        -: 4494:                return result;
        -: 4495:            }
        -: 4496:#endif // CLARA_CONFIG_OPTIONAL_TYPE
        -: 4497:
        -: 4498:            struct BoundRef : Catch::Detail::NonCopyable {
        -: 4499:                virtual ~BoundRef() = default;
        -: 4500:                virtual bool isContainer() const;
        -: 4501:                virtual bool isFlag() const;
        -: 4502:            };
        -: 4503:            struct BoundValueRefBase : BoundRef {
        -: 4504:                virtual auto setValue( std::string const& arg )
        -: 4505:                    -> ParserResult = 0;
        -: 4506:            };
        -: 4507:            struct BoundFlagRefBase : BoundRef {
        -: 4508:                virtual auto setFlag( bool flag ) -> ParserResult = 0;
        -: 4509:                bool isFlag() const override;
        -: 4510:            };
        -: 4511:
        -: 4512:            template <typename T> struct BoundValueRef : BoundValueRefBase {
        -: 4513:                T& m_ref;
        -: 4514:
        -: 4515:                explicit BoundValueRef( T& ref ): m_ref( ref ) {}
        -: 4516:
        -: 4517:                ParserResult setValue( std::string const& arg ) override {
        -: 4518:                    return convertInto( arg, m_ref );
        -: 4519:                }
        -: 4520:            };
        -: 4521:
        -: 4522:            template <typename T>
        -: 4523:            struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
        -: 4524:                std::vector<T>& m_ref;
        -: 4525:
        -: 4526:                explicit BoundValueRef( std::vector<T>& ref ): m_ref( ref ) {}
        -: 4527:
        -: 4528:                auto isContainer() const -> bool override { return true; }
        -: 4529:
        -: 4530:                auto setValue( std::string const& arg )
        -: 4531:                    -> ParserResult override {
        -: 4532:                    T temp;
        -: 4533:                    auto result = convertInto( arg, temp );
        -: 4534:                    if ( result )
        -: 4535:                        m_ref.push_back( temp );
        -: 4536:                    return result;
        -: 4537:                }
        -: 4538:            };
        -: 4539:
        -: 4540:            struct BoundFlagRef : BoundFlagRefBase {
        -: 4541:                bool& m_ref;
        -: 4542:
        -: 4543:                explicit BoundFlagRef( bool& ref ): m_ref( ref ) {}
        -: 4544:
        -: 4545:                ParserResult setFlag( bool flag ) override;
        -: 4546:            };
        -: 4547:
        -: 4548:            template <typename ReturnType> struct LambdaInvoker {
        -: 4549:                static_assert(
        -: 4550:                    std::is_same<ReturnType, ParserResult>::value,
        -: 4551:                    "Lambda must return void or clara::ParserResult" );
        -: 4552:
        -: 4553:                template <typename L, typename ArgType>
        -: 4554:                static auto invoke( L const& lambda, ArgType const& arg )
        -: 4555:                    -> ParserResult {
        -: 4556:                    return lambda( arg );
        -: 4557:                }
        -: 4558:            };
        -: 4559:
        -: 4560:            template <> struct LambdaInvoker<void> {
        -: 4561:                template <typename L, typename ArgType>
        -: 4562:                static auto invoke( L const& lambda, ArgType const& arg )
        -: 4563:                    -> ParserResult {
        -: 4564:                    lambda( arg );
        -: 4565:                    return ParserResult::ok( ParseResultType::Matched );
        -: 4566:                }
        -: 4567:            };
        -: 4568:
        -: 4569:            template <typename ArgType, typename L>
        -: 4570:            auto invokeLambda( L const& lambda, std::string const& arg )
        -: 4571:                -> ParserResult {
        -: 4572:                ArgType temp{};
        -: 4573:                auto result = convertInto( arg, temp );
        -: 4574:                return !result ? result
        -: 4575:                               : LambdaInvoker<typename UnaryLambdaTraits<
        -: 4576:                                     L>::ReturnType>::invoke( lambda, temp );
        -: 4577:            }
        -: 4578:
        -: 4579:            template <typename L> struct BoundLambda : BoundValueRefBase {
        -: 4580:                L m_lambda;
        -: 4581:
        -: 4582:                static_assert(
        -: 4583:                    UnaryLambdaTraits<L>::isValid,
        -: 4584:                    "Supplied lambda must take exactly one argument" );
        -: 4585:                explicit BoundLambda( L const& lambda ): m_lambda( lambda ) {}
        -: 4586:
        -: 4587:                auto setValue( std::string const& arg )
        -: 4588:                    -> ParserResult override {
        -: 4589:                    return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>(
        -: 4590:                        m_lambda, arg );
        -: 4591:                }
        -: 4592:            };
        -: 4593:
        -: 4594:            template <typename L> struct BoundManyLambda : BoundLambda<L> {
        -: 4595:                explicit BoundManyLambda( L const& lambda ): BoundLambda<L>( lambda ) {}
        -: 4596:                bool isContainer() const override { return true; }
        -: 4597:            };
        -: 4598:
        -: 4599:            template <typename L> struct BoundFlagLambda : BoundFlagRefBase {
        -: 4600:                L m_lambda;
        -: 4601:
        -: 4602:                static_assert(
        -: 4603:                    UnaryLambdaTraits<L>::isValid,
        -: 4604:                    "Supplied lambda must take exactly one argument" );
        -: 4605:                static_assert(
        -: 4606:                    std::is_same<typename UnaryLambdaTraits<L>::ArgType,
        -: 4607:                                 bool>::value,
        -: 4608:                    "flags must be boolean" );
        -: 4609:
        -: 4610:                explicit BoundFlagLambda( L const& lambda ):
        -: 4611:                    m_lambda( lambda ) {}
        -: 4612:
        -: 4613:                auto setFlag( bool flag ) -> ParserResult override {
        -: 4614:                    return LambdaInvoker<typename UnaryLambdaTraits<
        -: 4615:                        L>::ReturnType>::invoke( m_lambda, flag );
        -: 4616:                }
        -: 4617:            };
        -: 4618:
        -: 4619:            enum class Optionality { Optional, Required };
        -: 4620:
        -: 4621:            class ParserBase {
        -: 4622:            public:
        -: 4623:                virtual ~ParserBase() = default;
        -: 4624:                virtual auto validate() const -> Result { return Result::ok(); }
        -: 4625:                virtual auto parse( std::string const& exeName,
        -: 4626:                                    TokenStream tokens ) const
        -: 4627:                    -> InternalParseResult = 0;
        -: 4628:                virtual size_t cardinality() const;
        -: 4629:
        -: 4630:                InternalParseResult parse( Args const& args ) const;
        -: 4631:            };
        -: 4632:
        -: 4633:            template <typename DerivedT>
        -: 4634:            class ComposableParserImpl : public ParserBase {
        -: 4635:            public:
        -: 4636:                template <typename T>
        -: 4637:                auto operator|( T const& other ) const -> Parser;
        -: 4638:            };
        -: 4639:
        -: 4640:            // Common code and state for Args and Opts
        -: 4641:            template <typename DerivedT>
        -: 4642:            class ParserRefImpl : public ComposableParserImpl<DerivedT> {
        -: 4643:            protected:
        -: 4644:                Optionality m_optionality = Optionality::Optional;
        -: 4645:                std::shared_ptr<BoundRef> m_ref;
        -: 4646:                StringRef m_hint;
        -: 4647:                StringRef m_description;
        -: 4648:
        -: 4649:                explicit ParserRefImpl( std::shared_ptr<BoundRef> const& ref ):
        -: 4650:                    m_ref( ref ) {}
        -: 4651:
        -: 4652:            public:
        -: 4653:                template <typename LambdaT>
        -: 4654:                ParserRefImpl( accept_many_t,
        -: 4655:                               LambdaT const& ref,
        -: 4656:                               StringRef hint ):
        -: 4657:                    m_ref( std::make_shared<BoundManyLambda<LambdaT>>( ref ) ),
        -: 4658:                    m_hint( hint ) {}
        -: 4659:
        -: 4660:                template <typename T,
        -: 4661:                          typename = typename std::enable_if_t<
        -: 4662:                              !Detail::is_unary_function<T>::value>>
        -: 4663:                ParserRefImpl( T& ref, StringRef hint ):
        -: 4664:                    m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
        -: 4665:                    m_hint( hint ) {}
        -: 4666:
        -: 4667:                template <typename LambdaT,
        -: 4668:                          typename = typename std::enable_if_t<
        -: 4669:                              Detail::is_unary_function<LambdaT>::value>>
        -: 4670:                ParserRefImpl( LambdaT const& ref, StringRef hint ):
        -: 4671:                    m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
        -: 4672:                    m_hint( hint ) {}
        -: 4673:
        -: 4674:                DerivedT& operator()( StringRef description ) & {
        -: 4675:                    m_description = description;
        -: 4676:                    return static_cast<DerivedT&>( *this );
        -: 4677:                }
        -: 4678:                DerivedT&& operator()( StringRef description ) && {
        -: 4679:                    m_description = description;
        -: 4680:                    return static_cast<DerivedT&&>( *this );
        -: 4681:                }
        -: 4682:
        -: 4683:                auto optional() -> DerivedT& {
        -: 4684:                    m_optionality = Optionality::Optional;
        -: 4685:                    return static_cast<DerivedT&>( *this );
        -: 4686:                }
        -: 4687:
        -: 4688:                auto required() -> DerivedT& {
        -: 4689:                    m_optionality = Optionality::Required;
        -: 4690:                    return static_cast<DerivedT&>( *this );
        -: 4691:                }
        -: 4692:
        -: 4693:                auto isOptional() const -> bool {
        -: 4694:                    return m_optionality == Optionality::Optional;
        -: 4695:                }
        -: 4696:
        -: 4697:                auto cardinality() const -> size_t override {
        -: 4698:                    if ( m_ref->isContainer() )
        -: 4699:                        return 0;
        -: 4700:                    else
        -: 4701:                        return 1;
        -: 4702:                }
        -: 4703:
        -: 4704:                StringRef hint() const { return m_hint; }
        -: 4705:            };
        -: 4706:
        -: 4707:        } // namespace detail
        -: 4708:
        -: 4709:
        -: 4710:        // A parser for arguments
        -: 4711:        class Arg : public Detail::ParserRefImpl<Arg> {
        -: 4712:        public:
        -: 4713:            using ParserRefImpl::ParserRefImpl;
        -: 4714:            using ParserBase::parse;
        -: 4715:
        -: 4716:            Detail::InternalParseResult
        -: 4717:                parse(std::string const&,
        -: 4718:                      Detail::TokenStream tokens) const override;
        -: 4719:        };
        -: 4720:
        -: 4721:        // A parser for options
        -: 4722:        class Opt : public Detail::ParserRefImpl<Opt> {
        -: 4723:        protected:
        -: 4724:            std::vector<StringRef> m_optNames;
        -: 4725:
        -: 4726:        public:
        -: 4727:            template <typename LambdaT>
        -: 4728:            explicit Opt(LambdaT const& ref) :
        -: 4729:                ParserRefImpl(
        -: 4730:                    std::make_shared<Detail::BoundFlagLambda<LambdaT>>(ref)) {}
        -: 4731:
        -: 4732:            explicit Opt(bool& ref);
        -: 4733:
        -: 4734:            template <typename LambdaT,
        -: 4735:                      typename = typename std::enable_if_t<
        -: 4736:                          Detail::is_unary_function<LambdaT>::value>>
        -: 4737:            Opt( LambdaT const& ref, StringRef hint ):
        -: 4738:                ParserRefImpl( ref, hint ) {}
        -: 4739:
        -: 4740:            template <typename LambdaT>
        -: 4741:            Opt( accept_many_t, LambdaT const& ref, StringRef hint ):
        -: 4742:                ParserRefImpl( accept_many, ref, hint ) {}
        -: 4743:
        -: 4744:            template <typename T,
        -: 4745:                      typename = typename std::enable_if_t<
        -: 4746:                          !Detail::is_unary_function<T>::value>>
        -: 4747:            Opt( T& ref, StringRef hint ):
        -: 4748:                ParserRefImpl( ref, hint ) {}
        -: 4749:
        -: 4750:            Opt& operator[]( StringRef optName ) & {
        -: 4751:                m_optNames.push_back(optName);
        -: 4752:                return *this;
        -: 4753:            }
        -: 4754:            Opt&& operator[]( StringRef optName ) && {
        -: 4755:                m_optNames.push_back( optName );
        -: 4756:                return CATCH_MOVE(*this);
        -: 4757:            }
        -: 4758:
        -: 4759:            Detail::HelpColumns getHelpColumns() const;
        -: 4760:
        -: 4761:            bool isMatch(StringRef optToken) const;
        -: 4762:
        -: 4763:            using ParserBase::parse;
        -: 4764:
        -: 4765:            Detail::InternalParseResult
        -: 4766:                parse(std::string const&,
        -: 4767:                      Detail::TokenStream tokens) const override;
        -: 4768:
        -: 4769:            Detail::Result validate() const override;
        -: 4770:        };
        -: 4771:
        -: 4772:        // Specifies the name of the executable
        -: 4773:        class ExeName : public Detail::ComposableParserImpl<ExeName> {
        -: 4774:            std::shared_ptr<std::string> m_name;
        -: 4775:            std::shared_ptr<Detail::BoundValueRefBase> m_ref;
        -: 4776:
        -: 4777:        public:
        -: 4778:            ExeName();
        -: 4779:            explicit ExeName(std::string& ref);
        -: 4780:
        -: 4781:            template <typename LambdaT>
        -: 4782:            explicit ExeName(LambdaT const& lambda) : ExeName() {
        -: 4783:                m_ref = std::make_shared<Detail::BoundLambda<LambdaT>>(lambda);
        -: 4784:            }
        -: 4785:
        -: 4786:            // The exe name is not parsed out of the normal tokens, but is
        -: 4787:            // handled specially
        -: 4788:            Detail::InternalParseResult
        -: 4789:                parse(std::string const&,
        -: 4790:                      Detail::TokenStream tokens) const override;
        -: 4791:
        -: 4792:            std::string const& name() const { return *m_name; }
        -: 4793:            Detail::ParserResult set(std::string const& newName);
        -: 4794:        };
        -: 4795:
        -: 4796:
        -: 4797:        // A Combined parser
        -: 4798:        class Parser : Detail::ParserBase {
        -: 4799:            mutable ExeName m_exeName;
        -: 4800:            std::vector<Opt> m_options;
        -: 4801:            std::vector<Arg> m_args;
        -: 4802:
        -: 4803:        public:
        -: 4804:
        -: 4805:            auto operator|=(ExeName const& exeName) -> Parser& {
        -: 4806:                m_exeName = exeName;
        -: 4807:                return *this;
        -: 4808:            }
        -: 4809:
        -: 4810:            auto operator|=(Arg const& arg) -> Parser& {
        -: 4811:                m_args.push_back(arg);
        -: 4812:                return *this;
        -: 4813:            }
        -: 4814:
        -: 4815:            friend Parser& operator|=( Parser& p, Opt const& opt ) {
        -: 4816:                p.m_options.push_back( opt );
        -: 4817:                return p;
        -: 4818:            }
        -: 4819:            friend Parser& operator|=( Parser& p, Opt&& opt ) {
        -: 4820:                p.m_options.push_back( CATCH_MOVE(opt) );
        -: 4821:                return p;
        -: 4822:            }
        -: 4823:
        -: 4824:            Parser& operator|=(Parser const& other);
        -: 4825:
        -: 4826:            template <typename T>
        -: 4827:            friend Parser operator|( Parser const& p, T&& rhs ) {
        -: 4828:                Parser temp( p );
        -: 4829:                temp |= rhs;
        -: 4830:                return temp;
        -: 4831:            }
        -: 4832:
        -: 4833:            template <typename T>
        -: 4834:            friend Parser operator|( Parser&& p, T&& rhs ) {
        -: 4835:                p |= CATCH_FORWARD(rhs);
        -: 4836:                return CATCH_MOVE(p);
        -: 4837:            }
        -: 4838:
        -: 4839:            std::vector<Detail::HelpColumns> getHelpColumns() const;
        -: 4840:
        -: 4841:            void writeToStream(std::ostream& os) const;
        -: 4842:
        -: 4843:            friend auto operator<<(std::ostream& os, Parser const& parser)
        -: 4844:                -> std::ostream& {
        -: 4845:                parser.writeToStream(os);
        -: 4846:                return os;
        -: 4847:            }
        -: 4848:
        -: 4849:            Detail::Result validate() const override;
        -: 4850:
        -: 4851:            using ParserBase::parse;
        -: 4852:            Detail::InternalParseResult
        -: 4853:                parse(std::string const& exeName,
        -: 4854:                      Detail::TokenStream tokens) const override;
        -: 4855:        };
        -: 4856:
        -: 4857:        /**
        -: 4858:         * Wrapper over argc + argv, assumes that the inputs outlive it
        -: 4859:         */
        -: 4860:        class Args {
        -: 4861:            friend Detail::TokenStream;
        -: 4862:            StringRef m_exeName;
        -: 4863:            std::vector<StringRef> m_args;
        -: 4864:
        -: 4865:        public:
        -: 4866:            Args(int argc, char const* const* argv);
        -: 4867:            // Helper constructor for testing
        -: 4868:            Args(std::initializer_list<StringRef> args);
        -: 4869:
        -: 4870:            StringRef exeName() const { return m_exeName; }
        -: 4871:        };
        -: 4872:
        -: 4873:
        -: 4874:        // Convenience wrapper for option parser that specifies the help option
        -: 4875:        struct Help : Opt {
        -: 4876:            Help(bool& showHelpFlag);
        -: 4877:        };
        -: 4878:
        -: 4879:        // Result type for parser operation
        -: 4880:        using Detail::ParserResult;
        -: 4881:
        -: 4882:        namespace Detail {
        -: 4883:            template <typename DerivedT>
        -: 4884:            template <typename T>
        -: 4885:            Parser
        -: 4886:                ComposableParserImpl<DerivedT>::operator|(T const& other) const {
        -: 4887:                return Parser() | static_cast<DerivedT const&>(*this) | other;
        -: 4888:            }
        -: 4889:        }
        -: 4890:
        -: 4891:    } // namespace Clara
        -: 4892:} // namespace Catch
        -: 4893:
        -: 4894:#if defined( __clang__ )
        -: 4895:#    pragma clang diagnostic pop
        -: 4896:#endif
        -: 4897:
        -: 4898:#if defined( __GNUC__ )
        -: 4899:#    pragma GCC diagnostic pop
        -: 4900:#endif
        -: 4901:
        -: 4902:#endif // CATCH_CLARA_HPP_INCLUDED
        -: 4903:
        -: 4904:namespace Catch {
        -: 4905:
        -: 4906:    struct ConfigData;
        -: 4907:
        -: 4908:    Clara::Parser makeCommandLineParser( ConfigData& config );
        -: 4909:
        -: 4910:} // end namespace Catch
        -: 4911:
        -: 4912:#endif // CATCH_COMMANDLINE_HPP_INCLUDED
        -: 4913:
        -: 4914:namespace Catch {
        -: 4915:
        -: 4916:    class Session : Detail::NonCopyable {
        -: 4917:    public:
        -: 4918:
        -: 4919:        Session();
        -: 4920:        ~Session();
        -: 4921:
        -: 4922:        void showHelp() const;
        -: 4923:        void libIdentify();
        -: 4924:
        -: 4925:        int applyCommandLine( int argc, char const * const * argv );
        -: 4926:    #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
        -: 4927:        int applyCommandLine( int argc, wchar_t const * const * argv );
        -: 4928:    #endif
        -: 4929:
        -: 4930:        void useConfigData( ConfigData const& configData );
        -: 4931:
        -: 4932:        template<typename CharT>
        -: 4933:        int run(int argc, CharT const * const argv[]) {
        -: 4934:            if (m_startupExceptions)
        -: 4935:                return 1;
        -: 4936:            int returnCode = applyCommandLine(argc, argv);
        -: 4937:            if (returnCode == 0)
        -: 4938:                returnCode = run();
        -: 4939:            return returnCode;
        -: 4940:        }
        -: 4941:
        -: 4942:        int run();
        -: 4943:
        -: 4944:        Clara::Parser const& cli() const;
        -: 4945:        void cli( Clara::Parser const& newParser );
        -: 4946:        ConfigData& configData();
        -: 4947:        Config& config();
        -: 4948:    private:
        -: 4949:        int runInternal();
        -: 4950:
        -: 4951:        Clara::Parser m_cli;
        -: 4952:        ConfigData m_configData;
        -: 4953:        Detail::unique_ptr<Config> m_config;
        -: 4954:        bool m_startupExceptions = false;
        -: 4955:    };
        -: 4956:
        -: 4957:} // end namespace Catch
        -: 4958:
        -: 4959:#endif // CATCH_SESSION_HPP_INCLUDED
        -: 4960:
        -: 4961:
        -: 4962:#ifndef CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4963:#define CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4964:
        -: 4965:
        -: 4966:#include <string>
        -: 4967:
        -: 4968:namespace Catch {
        -: 4969:
        -: 4970:    struct TagAlias {
        -: 4971:        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo):
        -: 4972:            tag(_tag),
        -: 4973:            lineInfo(_lineInfo)
        -: 4974:        {}
        -: 4975:
        -: 4976:        std::string tag;
        -: 4977:        SourceLineInfo lineInfo;
        -: 4978:    };
        -: 4979:
        -: 4980:} // end namespace Catch
        -: 4981:
        -: 4982:#endif // CATCH_TAG_ALIAS_HPP_INCLUDED
        -: 4983:
        -: 4984:
        -: 4985:#ifndef CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 4986:#define CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 4987:
        -: 4988:
        -: 4989:namespace Catch {
        -: 4990:
        -: 4991:    struct RegistrarForTagAliases {
        -: 4992:        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -: 4993:    };
        -: 4994:
        -: 4995:} // end namespace Catch
        -: 4996:
        -: 4997:#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
        -: 4998:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 4999:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 5000:    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
        -: 5001:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5002:
        -: 5003:#endif // CATCH_TAG_ALIAS_AUTOREGISTRAR_HPP_INCLUDED
        -: 5004:
        -: 5005:
        -: 5006:#ifndef CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 5007:#define CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 5008:
        -: 5009:// We need this suppression to leak, because it took until GCC 10
        -: 5010:// for the front end to handle local suppression via _Pragma properly
        -: 5011:// inside templates (so `TEMPLATE_TEST_CASE` and co).
        -: 5012:// **THIS IS DIFFERENT FOR STANDARD TESTS, WHERE GCC 9 IS SUFFICIENT**
        -: 5013:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ < 10
        -: 5014:#pragma GCC diagnostic ignored "-Wparentheses"
        -: 5015:#endif
        -: 5016:
        -: 5017:
        -: 5018:
        -: 5019:
        -: 5020:#ifndef CATCH_TEST_MACROS_HPP_INCLUDED
        -: 5021:#define CATCH_TEST_MACROS_HPP_INCLUDED
        -: 5022:
        -: 5023:
        -: 5024:
        -: 5025:#ifndef CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 5026:#define CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 5027:
        -: 5028:
        -: 5029:
        -: 5030:#ifndef CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 5031:#define CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 5032:
        -: 5033:
        -: 5034:
        -: 5035:#ifndef CATCH_DECOMPOSER_HPP_INCLUDED
        -: 5036:#define CATCH_DECOMPOSER_HPP_INCLUDED
        -: 5037:
        -: 5038:
        -: 5039:
        -: 5040:#ifndef CATCH_COMPARE_TRAITS_HPP_INCLUDED
        -: 5041:#define CATCH_COMPARE_TRAITS_HPP_INCLUDED
        -: 5042:
        -: 5043:
        -: 5044:#include <type_traits>
        -: 5045:
        -: 5046:namespace Catch {
        -: 5047:    namespace Detail {
        -: 5048:
        -: 5049:#if defined( __GNUC__ ) && !defined( __clang__ )
        -: 5050:#    pragma GCC diagnostic push
        -: 5051:    // GCC likes to complain about comparing bool with 0, in the decltype()
        -: 5052:    // that defines the comparable traits below.
        -: 5053:#    pragma GCC diagnostic ignored "-Wbool-compare"
        -: 5054:    // "ordered comparison of pointer with integer zero" same as above,
        -: 5055:    // but it does not have a separate warning flag to suppress
        -: 5056:#    pragma GCC diagnostic ignored "-Wextra"
        -: 5057:    // Did you know that comparing floats with `0` directly
        -: 5058:    // is super-duper dangerous in unevaluated context?
        -: 5059:#    pragma GCC diagnostic ignored "-Wfloat-equal"
        -: 5060:#endif
        -: 5061:
        -: 5062:#if defined( __clang__ )
        -: 5063:#    pragma clang diagnostic push
        -: 5064:    // Did you know that comparing floats with `0` directly
        -: 5065:    // is super-duper dangerous in unevaluated context?
        -: 5066:#    pragma clang diagnostic ignored "-Wfloat-equal"
        -: 5067:#endif
        -: 5068:
        -: 5069:#define CATCH_DEFINE_COMPARABLE_TRAIT( id, op )                               \
        -: 5070:    template <typename, typename, typename = void>                            \
        -: 5071:    struct is_##id##_comparable : std::false_type {};                         \
        -: 5072:    template <typename T, typename U>                                         \
        -: 5073:    struct is_##id##_comparable<                                              \
        -: 5074:        T,                                                                    \
        -: 5075:        U,                                                                    \
        -: 5076:        void_t<decltype( std::declval<T>() op std::declval<U>() )>>           \
        -: 5077:        : std::true_type {};                                                  \
        -: 5078:    template <typename, typename = void>                                      \
        -: 5079:    struct is_##id##_0_comparable : std::false_type {};                       \
        -: 5080:    template <typename T>                                                     \
        -: 5081:    struct is_##id##_0_comparable<T,                                          \
        -: 5082:                                  void_t<decltype( std::declval<T>() op 0 )>> \
        -: 5083:        : std::true_type {};
        -: 5084:
        -: 5085:        // We need all 6 pre-spaceship comparison ops: <, <=, >, >=, ==, !=
        -: 5086:        CATCH_DEFINE_COMPARABLE_TRAIT( lt, < )
        -: 5087:        CATCH_DEFINE_COMPARABLE_TRAIT( le, <= )
        -: 5088:        CATCH_DEFINE_COMPARABLE_TRAIT( gt, > )
        -: 5089:        CATCH_DEFINE_COMPARABLE_TRAIT( ge, >= )
        -: 5090:        CATCH_DEFINE_COMPARABLE_TRAIT( eq, == )
        -: 5091:        CATCH_DEFINE_COMPARABLE_TRAIT( ne, != )
        -: 5092:
        -: 5093:#undef CATCH_DEFINE_COMPARABLE_TRAIT
        -: 5094:
        -: 5095:#if defined( __GNUC__ ) && !defined( __clang__ )
        -: 5096:#    pragma GCC diagnostic pop
        -: 5097:#endif
        -: 5098:#if defined( __clang__ )
        -: 5099:#    pragma clang diagnostic pop
        -: 5100:#endif
        -: 5101:
        -: 5102:
        -: 5103:    } // namespace Detail
        -: 5104:} // namespace Catch
        -: 5105:
        -: 5106:#endif // CATCH_COMPARE_TRAITS_HPP_INCLUDED
        -: 5107:
        -: 5108:
        -: 5109:#ifndef CATCH_LOGICAL_TRAITS_HPP_INCLUDED
        -: 5110:#define CATCH_LOGICAL_TRAITS_HPP_INCLUDED
        -: 5111:
        -: 5112:#include <type_traits>
        -: 5113:
        -: 5114:namespace Catch {
        -: 5115:namespace Detail {
        -: 5116:
        -: 5117:#if defined( __cpp_lib_logical_traits ) && __cpp_lib_logical_traits >= 201510
        -: 5118:
        -: 5119:    using std::conjunction;
        -: 5120:    using std::disjunction;
        -: 5121:    using std::negation;
        -: 5122:
        -: 5123:#else
        -: 5124:
        -: 5125:    template <class...> struct conjunction : std::true_type {};
        -: 5126:    template <class B1> struct conjunction<B1> : B1 {};
        -: 5127:    template <class B1, class... Bn>
        -: 5128:    struct conjunction<B1, Bn...>
        -: 5129:        : std::conditional_t<bool( B1::value ), conjunction<Bn...>, B1> {};
        -: 5130:
        -: 5131:    template <class...> struct disjunction : std::false_type {};
        -: 5132:    template <class B1> struct disjunction<B1> : B1 {};
        -: 5133:    template <class B1, class... Bn>
        -: 5134:    struct disjunction<B1, Bn...>
        -: 5135:        : std::conditional_t<bool( B1::value ), B1, disjunction<Bn...>> {};
        -: 5136:
        -: 5137:    template <class B>
        -: 5138:    struct negation : std::integral_constant<bool, !bool(B::value)> {};
        -: 5139:
        -: 5140:#endif
        -: 5141:
        -: 5142:} // namespace Detail
        -: 5143:} // namespace Catch
        -: 5144:
        -: 5145:#endif // CATCH_LOGICAL_TRAITS_HPP_INCLUDED
        -: 5146:
        -: 5147:#include <type_traits>
        -: 5148:#include <iosfwd>
        -: 5149:
        -: 5150:/** \file
        -: 5151: * Why does decomposing look the way it does:
        -: 5152: *
        -: 5153: * Conceptually, decomposing is simple. We change `REQUIRE( a == b )` into
        -: 5154: * `Decomposer{} <= a == b`, so that `Decomposer{} <= a` is evaluated first,
        -: 5155: * and our custom operator is used for `a == b`, because `a` is transformed
        -: 5156: * into `ExprLhs<T&>` and then into `BinaryExpr<T&, U&>`.
        -: 5157: *
        -: 5158: * In practice, decomposing ends up a mess, because we have to support
        -: 5159: * various fun things.
        -: 5160: *
        -: 5161: * 1) Types that are only comparable with literal 0, and they do this by
        -: 5162: *    comparing against a magic type with pointer constructor and deleted
        -: 5163: *    other constructors. Example: `REQUIRE((a <=> b) == 0)` in libstdc++
        -: 5164: *
        -: 5165: * 2) Types that are only comparable with literal 0, and they do this by
        -: 5166: *    comparing against a magic type with consteval integer constructor.
        -: 5167: *    Example: `REQUIRE((a <=> b) == 0)` in current MSVC STL.
        -: 5168: *
        -: 5169: * 3) Types that have no linkage, and so we cannot form a reference to
        -: 5170: *    them. Example: some implementations of traits.
        -: 5171: *
        -: 5172: * 4) Starting with C++20, when the compiler sees `a == b`, it also uses
        -: 5173: *    `b == a` when constructing the overload set. For us this means that
        -: 5174: *    when the compiler handles `ExprLhs<T> == b`, it also tries to resolve
        -: 5175: *    the overload set for `b == ExprLhs<T>`.
        -: 5176: *
        -: 5177: * To accomodate these use cases, decomposer ended up rather complex.
        -: 5178: *
        -: 5179: * 1) These types are handled by adding SFINAE overloads to our comparison
        -: 5180: *    operators, checking whether `T == U` are comparable with the given
        -: 5181: *    operator, and if not, whether T (or U) are comparable with literal 0.
        -: 5182: *    If yes, the overload compares T (or U) with 0 literal inline in the
        -: 5183: *    definition.
        -: 5184: *
        -: 5185: *    Note that for extra correctness, we check  that the other type is
        -: 5186: *    either an `int` (literal 0 is captured as `int` by templates), or
        -: 5187: *    a `long` (some platforms use 0L for `NULL` and we want to support
        -: 5188: *    that for pointer comparisons).
        -: 5189: *
        -: 5190: * 2) For these types, `is_foo_comparable<T, int>` is true, but letting
        -: 5191: *    them fall into the overload that actually does `T == int` causes
        -: 5192: *    compilation error. Handling them requires that the decomposition
        -: 5193: *    is `constexpr`, so that P2564R3 applies and the `consteval` from
        -: 5194: *    their accompanying magic type is propagated through the `constexpr`
        -: 5195: *    call stack.
        -: 5196: *
        -: 5197: *    However this is not enough to handle these types automatically,
        -: 5198: *    because our default is to capture types by reference, to avoid
        -: 5199: *    runtime copies. While these references cannot become dangling,
        -: 5200: *    they outlive the constexpr context and thus the default capture
        -: 5201: *    path cannot be actually constexpr.
        -: 5202: *
        -: 5203: *    The solution is to capture these types by value, by explicitly
        -: 5204: *    specializing `Catch::capture_by_value` for them. Catch2 provides
        -: 5205: *    specialization for `std::foo_ordering`s, but users can specialize
        -: 5206: *    the trait for their own types as well.
        -: 5207: *
        -: 5208: * 3) If a type has no linkage, we also cannot capture it by reference.
        -: 5209: *    The solution is once again to capture them by value. We handle
        -: 5210: *    the common cases by using `std::is_arithmetic` as the default
        -: 5211: *    for `Catch::capture_by_value`, but that is only a some-effort
        -: 5212: *    heuristic. But as with 2), users can specialize `capture_by_value`
        -: 5213: *    for their own types as needed.
        -: 5214: *
        -: 5215: * 4) To support C++20 and make the SFINAE on our decomposing operators
        -: 5216: *    work, the SFINAE has to happen in return type, rather than in
        -: 5217: *    a template type. This is due to our use of logical type traits
        -: 5218: *    (`conjunction`/`disjunction`/`negation`), that we use to workaround
        -: 5219: *    an issue in older (9-) versions of GCC. I still blame C++20 for
        -: 5220: *    this, because without the comparison order switching, the logical
        -: 5221: *    traits could still be used in template type.
        -: 5222: *
        -: 5223: * There are also other side concerns, e.g. supporting both `REQUIRE(a)`
        -: 5224: * and `REQUIRE(a == b)`, or making `REQUIRE_THAT(a, IsEqual(b))` slot
        -: 5225: * nicely into the same expression handling logic, but these are rather
        -: 5226: * straightforward and add only a bit of complexity (e.g. common base
        -: 5227: * class for decomposed expressions).
        -: 5228: */
        -: 5229:
        -: 5230:#ifdef _MSC_VER
        -: 5231:#pragma warning(push)
        -: 5232:#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
        -: 5233:#pragma warning(disable:4018) // more "signed/unsigned mismatch"
        -: 5234:#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
        -: 5235:#pragma warning(disable:4180) // qualifier applied to function type has no meaning
        -: 5236:#pragma warning(disable:4800) // Forcing result to true or false
        -: 5237:#endif
        -: 5238:
        -: 5239:#ifdef __clang__
        -: 5240:#  pragma clang diagnostic push
        -: 5241:#  pragma clang diagnostic ignored "-Wsign-compare"
        -: 5242:#elif defined __GNUC__
        -: 5243:#  pragma GCC diagnostic push
        -: 5244:#  pragma GCC diagnostic ignored "-Wsign-compare"
        -: 5245:#endif
        -: 5246:
        -: 5247:#if defined(CATCH_CPP20_OR_GREATER) && __has_include(<compare>)
        -: 5248:#  include <compare>
        -: 5249:#    if defined( __cpp_lib_three_way_comparison ) && \
        -: 5250:            __cpp_lib_three_way_comparison >= 201907L
        -: 5251:#      define CATCH_CONFIG_CPP20_COMPARE_OVERLOADS
        -: 5252:#    endif
        -: 5253:#endif
        -: 5254:
        -: 5255:namespace Catch {
        -: 5256:
        -: 5257:    // Note: There is nothing that stops us from extending this,
        -: 5258:    //       e.g. to `std::is_scalar`, but the more encompassing
        -: 5259:    //       traits are usually also more expensive. For now we
        -: 5260:    //       keep this as it used to be and it can be changed later.
        -: 5261:    template <typename T>
        -: 5262:    struct capture_by_value
        -: 5263:        : std::integral_constant<bool, std::is_arithmetic<T>{}> {};
        -: 5264:
        -: 5265:#if defined( CATCH_CONFIG_CPP20_COMPARE_OVERLOADS )
        -: 5266:    template <>
        -: 5267:    struct capture_by_value<std::strong_ordering> : std::true_type {};
        -: 5268:    template <>
        -: 5269:    struct capture_by_value<std::weak_ordering> : std::true_type {};
        -: 5270:    template <>
        -: 5271:    struct capture_by_value<std::partial_ordering> : std::true_type {};
        -: 5272:#endif
        -: 5273:
        -: 5274:    template <typename T>
        -: 5275:    struct always_false : std::false_type {};
        -: 5276:
        -: 5277:    class ITransientExpression {
        -: 5278:        bool m_isBinaryExpression;
        -: 5279:        bool m_result;
        -: 5280:
        -: 5281:    public:
        -: 5282:        constexpr auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
        -: 5283:        constexpr auto getResult() const -> bool { return m_result; }
        -: 5284:        //! This function **has** to be overriden by the derived class.
        -: 5285:        virtual void streamReconstructedExpression( std::ostream& os ) const;
        -: 5286:
       20: 5287:        constexpr ITransientExpression( bool isBinaryExpression, bool result )
       20: 5288:        :   m_isBinaryExpression( isBinaryExpression ),
       20: 5289:            m_result( result )
       40: 5290:        {}
        -: 5291:
        -: 5292:        ITransientExpression() = default;
        -: 5293:        ITransientExpression(ITransientExpression const&) = default;
        -: 5294:        ITransientExpression& operator=(ITransientExpression const&) = default;
        -: 5295:
        -: 5296:        // We don't actually need a virtual destructor, but many static analysers
        -: 5297:        // complain if it's not here :-(
       20: 5298:        virtual ~ITransientExpression() = default;
        -: 5299:
        -: 5300:        friend std::ostream& operator<<(std::ostream& out, ITransientExpression const& expr) {
        -: 5301:            expr.streamReconstructedExpression(out);
        -: 5302:            return out;
        -: 5303:        }
        -: 5304:    };
        -: 5305:
        -: 5306:    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
        -: 5307:
        -: 5308:    template<typename LhsT, typename RhsT>
        -: 5309:    class BinaryExpr  : public ITransientExpression {
        -: 5310:        LhsT m_lhs;
        -: 5311:        StringRef m_op;
        -: 5312:        RhsT m_rhs;
        -: 5313:
        1: 5314:        void streamReconstructedExpression( std::ostream &os ) const override {
        1: 5315:            formatReconstructedExpression
        1: 5316:                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
        1: 5317:        }
        -: 5318:
        -: 5319:    public:
       36: 5320:        constexpr BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
       18: 5321:        :   ITransientExpression{ true, comparisonResult },
       18: 5322:            m_lhs( lhs ),
       18: 5323:            m_op( op ),
       18: 5324:            m_rhs( rhs )
       54: 5325:        {}
        -: 5326:
        -: 5327:        template<typename T>
        -: 5328:        auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5329:            static_assert(always_false<T>::value,
        -: 5330:            "chained comparisons are not supported inside assertions, "
        -: 5331:            "wrap the expression inside parentheses, or decompose it");
        -: 5332:        }
        -: 5333:
        -: 5334:        template<typename T>
        -: 5335:        auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5336:            static_assert(always_false<T>::value,
        -: 5337:            "chained comparisons are not supported inside assertions, "
        -: 5338:            "wrap the expression inside parentheses, or decompose it");
        -: 5339:        }
        -: 5340:
        -: 5341:        template<typename T>
        -: 5342:        auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5343:            static_assert(always_false<T>::value,
        -: 5344:            "chained comparisons are not supported inside assertions, "
        -: 5345:            "wrap the expression inside parentheses, or decompose it");
        -: 5346:        }
        -: 5347:
        -: 5348:        template<typename T>
        -: 5349:        auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5350:            static_assert(always_false<T>::value,
        -: 5351:            "chained comparisons are not supported inside assertions, "
        -: 5352:            "wrap the expression inside parentheses, or decompose it");
        -: 5353:        }
        -: 5354:
        -: 5355:        template<typename T>
        -: 5356:        auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5357:            static_assert(always_false<T>::value,
        -: 5358:            "chained comparisons are not supported inside assertions, "
        -: 5359:            "wrap the expression inside parentheses, or decompose it");
        -: 5360:        }
        -: 5361:
        -: 5362:        template<typename T>
        -: 5363:        auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5364:            static_assert(always_false<T>::value,
        -: 5365:            "chained comparisons are not supported inside assertions, "
        -: 5366:            "wrap the expression inside parentheses, or decompose it");
        -: 5367:        }
        -: 5368:
        -: 5369:        template<typename T>
        -: 5370:        auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5371:            static_assert(always_false<T>::value,
        -: 5372:            "chained comparisons are not supported inside assertions, "
        -: 5373:            "wrap the expression inside parentheses, or decompose it");
        -: 5374:        }
        -: 5375:
        -: 5376:        template<typename T>
        -: 5377:        auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
        -: 5378:            static_assert(always_false<T>::value,
        -: 5379:            "chained comparisons are not supported inside assertions, "
        -: 5380:            "wrap the expression inside parentheses, or decompose it");
        -: 5381:        }
        -: 5382:    };
        -: 5383:
        -: 5384:    template<typename LhsT>
        -: 5385:    class UnaryExpr : public ITransientExpression {
        -: 5386:        LhsT m_lhs;
        -: 5387:
    #####: 5388:        void streamReconstructedExpression( std::ostream &os ) const override {
    #####: 5389:            os << Catch::Detail::stringify( m_lhs );
    #####: 5390:        }
        -: 5391:
        -: 5392:    public:
        4: 5393:        explicit constexpr UnaryExpr( LhsT lhs )
        2: 5394:        :   ITransientExpression{ false, static_cast<bool>(lhs) },
        2: 5395:            m_lhs( lhs )
        6: 5396:        {}
        -: 5397:    };
        -: 5398:
        -: 5399:
        -: 5400:    template<typename LhsT>
        -: 5401:    class ExprLhs {
        -: 5402:        LhsT m_lhs;
        -: 5403:    public:
       40: 5404:        explicit constexpr ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
        -: 5405:
        -: 5406:#define CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( id, op )           \
        -: 5407:    template <typename RhsT>                                                   \
        -: 5408:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \
        -: 5409:        ->std::enable_if_t<                                                    \
        -: 5410:            Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \
        -: 5411:                                Detail::negation<capture_by_value<             \
        -: 5412:                                    std::remove_reference_t<RhsT>>>>::value,   \
        -: 5413:            BinaryExpr<LhsT, RhsT const&>> {                                   \
        -: 5414:        return {                                                               \
        -: 5415:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5416:    }                                                                          \
        -: 5417:    template <typename RhsT>                                                   \
        -: 5418:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5419:        ->std::enable_if_t<                                                    \
        -: 5420:            Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \
        -: 5421:                                capture_by_value<RhsT>>::value,                \
        -: 5422:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5423:        return {                                                               \
        -: 5424:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5425:    }                                                                          \
        -: 5426:    template <typename RhsT>                                                   \
        -: 5427:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5428:        ->std::enable_if_t<                                                    \
        -: 5429:            Detail::conjunction<                                               \
        -: 5430:                Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \
        -: 5431:                Detail::is_eq_0_comparable<LhsT>,                              \
        -: 5432:              /* We allow long because we want `ptr op NULL` to be accepted */ \
        -: 5433:                Detail::disjunction<std::is_same<RhsT, int>,                   \
        -: 5434:                                    std::is_same<RhsT, long>>>::value,         \
        -: 5435:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5436:        if ( rhs != 0 ) { throw_test_failure_exception(); }                    \
        -: 5437:        return {                                                               \
        -: 5438:            static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs };   \
        -: 5439:    }                                                                          \
        -: 5440:    template <typename RhsT>                                                   \
        -: 5441:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5442:        ->std::enable_if_t<                                                    \
        -: 5443:            Detail::conjunction<                                               \
        -: 5444:                Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \
        -: 5445:                Detail::is_eq_0_comparable<RhsT>,                              \
        -: 5446:              /* We allow long because we want `ptr op NULL` to be accepted */ \
        -: 5447:                Detail::disjunction<std::is_same<LhsT, int>,                   \
        -: 5448:                                    std::is_same<LhsT, long>>>::value,         \
        -: 5449:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5450:        if ( lhs.m_lhs != 0 ) { throw_test_failure_exception(); }              \
        -: 5451:        return { static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs };    \
        -: 5452:    }
        -: 5453:
       17: 5454:        CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( eq, == )
        -: 5455:        CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR( ne, != )
        -: 5456:
        -: 5457:    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_EQUALITY_OPERATOR
        -: 5458:
        -: 5459:
        -: 5460:#define CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( id, op )         \
        -: 5461:    template <typename RhsT>                                                   \
        -: 5462:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \
        -: 5463:        ->std::enable_if_t<                                                    \
        -: 5464:            Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \
        -: 5465:                                Detail::negation<capture_by_value<             \
        -: 5466:                                    std::remove_reference_t<RhsT>>>>::value,   \
        -: 5467:            BinaryExpr<LhsT, RhsT const&>> {                                   \
        -: 5468:        return {                                                               \
        -: 5469:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5470:    }                                                                          \
        -: 5471:    template <typename RhsT>                                                   \
        -: 5472:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5473:        ->std::enable_if_t<                                                    \
        -: 5474:            Detail::conjunction<Detail::is_##id##_comparable<LhsT, RhsT>,      \
        -: 5475:                                capture_by_value<RhsT>>::value,                \
        -: 5476:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5477:        return {                                                               \
        -: 5478:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5479:    }                                                                          \
        -: 5480:    template <typename RhsT>                                                   \
        -: 5481:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5482:        ->std::enable_if_t<                                                    \
        -: 5483:            Detail::conjunction<                                               \
        -: 5484:                Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \
        -: 5485:                Detail::is_##id##_0_comparable<LhsT>,                          \
        -: 5486:                std::is_same<RhsT, int>>::value,                               \
        -: 5487:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5488:        if ( rhs != 0 ) { throw_test_failure_exception(); }                    \
        -: 5489:        return {                                                               \
        -: 5490:            static_cast<bool>( lhs.m_lhs op 0 ), lhs.m_lhs, #op##_sr, rhs };   \
        -: 5491:    }                                                                          \
        -: 5492:    template <typename RhsT>                                                   \
        -: 5493:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5494:        ->std::enable_if_t<                                                    \
        -: 5495:            Detail::conjunction<                                               \
        -: 5496:                Detail::negation<Detail::is_##id##_comparable<LhsT, RhsT>>,    \
        -: 5497:                Detail::is_##id##_0_comparable<RhsT>,                          \
        -: 5498:                std::is_same<LhsT, int>>::value,                               \
        -: 5499:            BinaryExpr<LhsT, RhsT>> {                                          \
        -: 5500:        if ( lhs.m_lhs != 0 ) { throw_test_failure_exception(); }              \
        -: 5501:        return { static_cast<bool>( 0 op rhs ), lhs.m_lhs, #op##_sr, rhs };    \
        -: 5502:    }
        -: 5503:
        1: 5504:        CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( lt, < )
        -: 5505:        CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( le, <= )
        -: 5506:        CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( gt, > )
        -: 5507:        CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR( ge, >= )
        -: 5508:
        -: 5509:    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_COMPARISON_OPERATOR
        -: 5510:
        -: 5511:
        -: 5512:#define CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR( op )                        \
        -: 5513:    template <typename RhsT>                                                   \
        -: 5514:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT&& rhs )             \
        -: 5515:        ->std::enable_if_t<                                                    \
        -: 5516:            !capture_by_value<std::remove_reference_t<RhsT>>::value,           \
        -: 5517:            BinaryExpr<LhsT, RhsT const&>> {                                   \
        -: 5518:        return {                                                               \
        -: 5519:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5520:    }                                                                          \
        -: 5521:    template <typename RhsT>                                                   \
        -: 5522:    constexpr friend auto operator op( ExprLhs&& lhs, RhsT rhs )               \
        -: 5523:        ->std::enable_if_t<capture_by_value<RhsT>::value,                      \
        -: 5524:                           BinaryExpr<LhsT, RhsT>> {                           \
        -: 5525:        return {                                                               \
        -: 5526:            static_cast<bool>( lhs.m_lhs op rhs ), lhs.m_lhs, #op##_sr, rhs }; \
        -: 5527:    }
        -: 5528:
        -: 5529:        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(|)
        -: 5530:        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(&)
        -: 5531:        CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR(^)
        -: 5532:
        -: 5533:    #undef CATCH_INTERNAL_DEFINE_EXPRESSION_OPERATOR
        -: 5534:
        -: 5535:        template<typename RhsT>
        -: 5536:        friend auto operator && ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {
        -: 5537:            static_assert(always_false<RhsT>::value,
        -: 5538:            "operator&& is not supported inside assertions, "
        -: 5539:            "wrap the expression inside parentheses, or decompose it");
        -: 5540:        }
        -: 5541:
        -: 5542:        template<typename RhsT>
        -: 5543:        friend auto operator || ( ExprLhs &&, RhsT && ) -> BinaryExpr<LhsT, RhsT const&> {
        -: 5544:            static_assert(always_false<RhsT>::value,
        -: 5545:            "operator|| is not supported inside assertions, "
        -: 5546:            "wrap the expression inside parentheses, or decompose it");
        -: 5547:        }
        -: 5548:
        2: 5549:        constexpr auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
        2: 5550:            return UnaryExpr<LhsT>{ m_lhs };
        -: 5551:        }
        -: 5552:    };
        -: 5553:
        -: 5554:    struct Decomposer {
        -: 5555:        template <typename T,
        -: 5556:                  std::enable_if_t<
        -: 5557:                      !capture_by_value<std::remove_reference_t<T>>::value,
        -: 5558:                      int> = 0>
        -: 5559:        constexpr friend auto operator <= ( Decomposer &&, T && lhs ) -> ExprLhs<T const&> {
        -: 5560:            return ExprLhs<const T&>{ lhs };
        -: 5561:        }
        -: 5562:
        -: 5563:        template <typename T,
        -: 5564:                  std::enable_if_t<capture_by_value<T>::value, int> = 0>
       20: 5565:        constexpr friend auto operator <= ( Decomposer &&, T value ) -> ExprLhs<T> {
       20: 5566:            return ExprLhs<T>{ value };
        -: 5567:        }
        -: 5568:    };
        -: 5569:
        -: 5570:} // end namespace Catch
        -: 5571:
        -: 5572:#ifdef _MSC_VER
        -: 5573:#pragma warning(pop)
        -: 5574:#endif
        -: 5575:#ifdef __clang__
        -: 5576:#  pragma clang diagnostic pop
        -: 5577:#elif defined __GNUC__
        -: 5578:#  pragma GCC diagnostic pop
        -: 5579:#endif
        -: 5580:
        -: 5581:#endif // CATCH_DECOMPOSER_HPP_INCLUDED
        -: 5582:
        -: 5583:#include <string>
        -: 5584:
        -: 5585:namespace Catch {
        -: 5586:
        -: 5587:    struct AssertionReaction {
        -: 5588:        bool shouldDebugBreak = false;
        -: 5589:        bool shouldThrow = false;
        -: 5590:        bool shouldSkip = false;
        -: 5591:    };
        -: 5592:
        -: 5593:    class AssertionHandler {
        -: 5594:        AssertionInfo m_assertionInfo;
        -: 5595:        AssertionReaction m_reaction;
        -: 5596:        bool m_completed = false;
        -: 5597:        IResultCapture& m_resultCapture;
        -: 5598:
        -: 5599:    public:
        -: 5600:        AssertionHandler
        -: 5601:            (   StringRef macroName,
        -: 5602:                SourceLineInfo const& lineInfo,
        -: 5603:                StringRef capturedExpression,
        -: 5604:                ResultDisposition::Flags resultDisposition );
       40: 5605:        ~AssertionHandler() {
       20: 5606:            if ( !m_completed ) {
    #####: 5607:                m_resultCapture.handleIncomplete( m_assertionInfo );
    #####: 5608:            }
       40: 5609:        }
        -: 5610:
        -: 5611:
        -: 5612:        template<typename T>
        2: 5613:        void handleExpr( ExprLhs<T> const& expr ) {
        2: 5614:            handleExpr( expr.makeUnaryExpr() );
        2: 5615:        }
        -: 5616:        void handleExpr( ITransientExpression const& expr );
        -: 5617:
        -: 5618:        void handleMessage(ResultWas::OfType resultType, StringRef message);
        -: 5619:
        -: 5620:        void handleExceptionThrownAsExpected();
        -: 5621:        void handleUnexpectedExceptionNotThrown();
        -: 5622:        void handleExceptionNotThrownAsExpected();
        -: 5623:        void handleThrowingCallSkipped();
        -: 5624:        void handleUnexpectedInflightException();
        -: 5625:
        -: 5626:        void complete();
        -: 5627:
        -: 5628:        // query
        -: 5629:        auto allowThrows() const -> bool;
        -: 5630:    };
        -: 5631:
        -: 5632:    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str );
        -: 5633:
        -: 5634:} // namespace Catch
        -: 5635:
        -: 5636:#endif // CATCH_ASSERTION_HANDLER_HPP_INCLUDED
        -: 5637:
        -: 5638:
        -: 5639:#ifndef CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED
        -: 5640:#define CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED
        -: 5641:
        -: 5642:
        -: 5643:#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
        -: 5644:  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__##_catch_sr
        -: 5645:#else
        -: 5646:  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"_catch_sr
        -: 5647:#endif
        -: 5648:
        -: 5649:#endif // CATCH_PREPROCESSOR_INTERNAL_STRINGIFY_HPP_INCLUDED
        -: 5650:
        -: 5651:// We need this suppression to leak, because it took until GCC 10
        -: 5652:// for the front end to handle local suppression via _Pragma properly
        -: 5653:#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC) && __GNUC__ <= 9
        -: 5654:  #pragma GCC diagnostic ignored "-Wparentheses"
        -: 5655:#endif
        -: 5656:
        -: 5657:#if !defined(CATCH_CONFIG_DISABLE)
        -: 5658:
        -: 5659:#if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 5660:
        -: 5661:///////////////////////////////////////////////////////////////////////////////
        -: 5662:// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
        -: 5663:// macros.
        -: 5664:#define INTERNAL_CATCH_TRY
        -: 5665:#define INTERNAL_CATCH_CATCH( capturer )
        -: 5666:
        -: 5667:#else // CATCH_CONFIG_FAST_COMPILE
        -: 5668:
        -: 5669:#define INTERNAL_CATCH_TRY try
        -: 5670:#define INTERNAL_CATCH_CATCH( handler ) catch(...) { (handler).handleUnexpectedInflightException(); }
        -: 5671:
        -: 5672:#endif
        -: 5673:
        -: 5674:#define INTERNAL_CATCH_REACT( handler ) handler.complete();
        -: 5675:
        -: 5676:///////////////////////////////////////////////////////////////////////////////
        -: 5677:#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
        -: 5678:    do { /* NOLINT(bugprone-infinite-loop) */ \
        -: 5679:        /* The expression should not be evaluated, but warnings should hopefully be checked */ \
        -: 5680:        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
        -: 5681:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 5682:        INTERNAL_CATCH_TRY { \
        -: 5683:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5684:            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 5685:            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); /* NOLINT(bugprone-chained-comparison) */ \
        -: 5686:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5687:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -: 5688:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5689:    } while( (void)0, (false) && static_cast<const bool&>( !!(__VA_ARGS__) ) ) // the expression here is never evaluated at runtime but it forces the compiler to give it a look
        -: 5690:    // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.
        -: 5691:
        -: 5692:///////////////////////////////////////////////////////////////////////////////
        -: 5693:#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
        -: 5694:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 5695:    if( Catch::getResultCapture().lastAssertionPassed() )
        -: 5696:
        -: 5697:///////////////////////////////////////////////////////////////////////////////
        -: 5698:#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
        -: 5699:    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
        -: 5700:    if( !Catch::getResultCapture().lastAssertionPassed() )
        -: 5701:
        -: 5702:///////////////////////////////////////////////////////////////////////////////
        -: 5703:#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
        -: 5704:    do { \
        -: 5705:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
        -: 5706:        try { \
        -: 5707:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5708:            CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \
        -: 5709:            static_cast<void>(__VA_ARGS__); \
        -: 5710:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5711:            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
        -: 5712:        } \
        -: 5713:        catch( ... ) { \
        -: 5714:            catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 5715:        } \
        -: 5716:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5717:    } while( false )
        -: 5718:
        -: 5719:///////////////////////////////////////////////////////////////////////////////
        -: 5720:#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
        -: 5721:    do { \
        -: 5722:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
        -: 5723:        if( catchAssertionHandler.allowThrows() ) \
        -: 5724:            try { \
        -: 5725:                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5726:                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \
        -: 5727:                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \
        -: 5728:                static_cast<void>(__VA_ARGS__); \
        -: 5729:                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5730:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5731:            } \
        -: 5732:            catch( ... ) { \
        -: 5733:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 5734:            } \
        -: 5735:        else \
        -: 5736:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5737:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5738:    } while( false )
        -: 5739:
        -: 5740:///////////////////////////////////////////////////////////////////////////////
        -: 5741:#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
        -: 5742:    do { \
        -: 5743:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
        -: 5744:        if( catchAssertionHandler.allowThrows() ) \
        -: 5745:            try { \
        -: 5746:                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5747:                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \
        -: 5748:                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \
        -: 5749:                static_cast<void>(expr); \
        -: 5750:                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5751:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5752:            } \
        -: 5753:            catch( exceptionType const& ) { \
        -: 5754:                catchAssertionHandler.handleExceptionThrownAsExpected(); \
        -: 5755:            } \
        -: 5756:            catch( ... ) { \
        -: 5757:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -: 5758:            } \
        -: 5759:        else \
        -: 5760:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5761:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5762:    } while( false )
        -: 5763:
        -: 5764:
        -: 5765:
        -: 5766:///////////////////////////////////////////////////////////////////////////////
        -: 5767:// Although this is matcher-based, it can be used with just a string
        -: 5768:#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
        -: 5769:    do { \
        -: 5770:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 5771:        if( catchAssertionHandler.allowThrows() ) \
        -: 5772:            try { \
        -: 5773:                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 5774:                CATCH_INTERNAL_SUPPRESS_UNUSED_RESULT \
        -: 5775:                CATCH_INTERNAL_SUPPRESS_USELESS_CAST_WARNINGS \
        -: 5776:                static_cast<void>(__VA_ARGS__); \
        -: 5777:                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 5778:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -: 5779:            } \
        -: 5780:            catch( ... ) { \
        -: 5781:                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher ); \
        -: 5782:            } \
        -: 5783:        else \
        -: 5784:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -: 5785:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -: 5786:    } while( false )
        -: 5787:
        -: 5788:#endif // CATCH_CONFIG_DISABLE
        -: 5789:
        -: 5790:#endif // CATCH_TEST_MACRO_IMPL_HPP_INCLUDED
        -: 5791:
        -: 5792:
        -: 5793:#ifndef CATCH_SECTION_HPP_INCLUDED
        -: 5794:#define CATCH_SECTION_HPP_INCLUDED
        -: 5795:
        -: 5796:
        -: 5797:
        -: 5798:
        -: 5799:/** \file
        -: 5800: * Wrapper for the STATIC_ANALYSIS_SUPPORT configuration option
        -: 5801: *
        -: 5802: * Some of Catch2's macros can be defined differently to work better with
        -: 5803: * static analysis tools, like clang-tidy or coverity.
        -: 5804: * Currently the main use case is to show that `SECTION`s are executed
        -: 5805: * exclusively, and not all in one run of a `TEST_CASE`.
        -: 5806: */
        -: 5807:
        -: 5808:#ifndef CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED
        -: 5809:#define CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED
        -: 5810:
        -: 5811:
        -: 5812:#if defined(__clang_analyzer__) || defined(__COVERITY__)
        -: 5813:    #define CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT
        -: 5814:#endif
        -: 5815:
        -: 5816:#if defined( CATCH_INTERNAL_CONFIG_STATIC_ANALYSIS_SUPPORT ) && \
        -: 5817:    !defined( CATCH_CONFIG_NO_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT ) && \
        -: 5818:    !defined( CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT )
        -: 5819:#    define CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT
        -: 5820:#endif
        -: 5821:
        -: 5822:
        -: 5823:#endif // CATCH_CONFIG_STATIC_ANALYSIS_SUPPORT_HPP_INCLUDED
        -: 5824:
        -: 5825:
        -: 5826:#ifndef CATCH_TIMER_HPP_INCLUDED
        -: 5827:#define CATCH_TIMER_HPP_INCLUDED
        -: 5828:
        -: 5829:#include <cstdint>
        -: 5830:
        -: 5831:namespace Catch {
        -: 5832:
        -: 5833:    class Timer {
        -: 5834:        uint64_t m_nanoseconds = 0;
        -: 5835:    public:
        -: 5836:        void start();
        -: 5837:        auto getElapsedNanoseconds() const -> uint64_t;
        -: 5838:        auto getElapsedMicroseconds() const -> uint64_t;
        -: 5839:        auto getElapsedMilliseconds() const -> unsigned int;
        -: 5840:        auto getElapsedSeconds() const -> double;
        -: 5841:    };
        -: 5842:
        -: 5843:} // namespace Catch
        -: 5844:
        -: 5845:#endif // CATCH_TIMER_HPP_INCLUDED
        -: 5846:
        -: 5847:namespace Catch {
        -: 5848:
        -: 5849:    class Section : Detail::NonCopyable {
        -: 5850:    public:
        -: 5851:        Section( SectionInfo&& info );
        -: 5852:        Section( SourceLineInfo const& _lineInfo,
        -: 5853:                 StringRef _name,
        -: 5854:                 const char* const = nullptr );
        -: 5855:        ~Section();
        -: 5856:
        -: 5857:        // This indicates whether the section should be executed or not
        -: 5858:        explicit operator bool() const;
        -: 5859:
        -: 5860:    private:
        -: 5861:        SectionInfo m_info;
        -: 5862:
        -: 5863:        Counts m_assertions;
        -: 5864:        bool m_sectionIncluded;
        -: 5865:        Timer m_timer;
        -: 5866:    };
        -: 5867:
        -: 5868:} // end namespace Catch
        -: 5869:
        -: 5870:#if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)
        -: 5871:#    define INTERNAL_CATCH_SECTION( ... )                                 \
        -: 5872:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                         \
        -: 5873:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                  \
        -: 5874:        if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(            \
        -: 5875:                 catch_internal_Section ) =                               \
        -: 5876:                 Catch::Section( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
        -: 5877:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5878:
        -: 5879:#    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                     \
        -: 5880:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                     \
        -: 5881:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS              \
        -: 5882:        if ( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME(        \
        -: 5883:                 catch_internal_Section ) =                           \
        -: 5884:                 Catch::SectionInfo(                                  \
        -: 5885:                     CATCH_INTERNAL_LINEINFO,                         \
        -: 5886:                     ( Catch::ReusableStringStream() << __VA_ARGS__ ) \
        -: 5887:                         .str() ) )                                   \
        -: 5888:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5889:
        -: 5890:#else
        -: 5891:
        -: 5892:// These section definitions imply that at most one section at one level
        -: 5893:// will be intered (because only one section's __LINE__ can be equal to
        -: 5894:// the dummy `catchInternalSectionHint` variable from `TEST_CASE`).
        -: 5895:
        -: 5896:namespace Catch {
        -: 5897:    namespace Detail {
        -: 5898:        // Intentionally without linkage, as it should only be used as a dummy
        -: 5899:        // symbol for static analysis.
        -: 5900:        // The arguments are used as a dummy for checking warnings in the passed
        -: 5901:        // expressions.
        -: 5902:        int GetNewSectionHint( StringRef, const char* const = nullptr );
        -: 5903:    } // namespace Detail
        -: 5904:} // namespace Catch
        -: 5905:
        -: 5906:
        -: 5907:#    define INTERNAL_CATCH_SECTION( ... )                                   \
        -: 5908:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \
        -: 5909:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \
        -: 5910:        CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \
        -: 5911:        if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \
        -: 5912:                 catchInternalSectionHint,                                  \
        -: 5913:             catchInternalSectionHint =                                     \
        -: 5914:                 Catch::Detail::GetNewSectionHint(__VA_ARGS__);             \
        -: 5915:             catchInternalPreviousSectionHint == __LINE__ )                 \
        -: 5916:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5917:
        -: 5918:#    define INTERNAL_CATCH_DYNAMIC_SECTION( ... )                           \
        -: 5919:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                           \
        -: 5920:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                    \
        -: 5921:        CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                             \
        -: 5922:        if ( [[maybe_unused]] const int catchInternalPreviousSectionHint =  \
        -: 5923:                 catchInternalSectionHint,                                  \
        -: 5924:             catchInternalSectionHint = Catch::Detail::GetNewSectionHint(   \
        -: 5925:                ( Catch::ReusableStringStream() << __VA_ARGS__ ).str());    \
        -: 5926:             catchInternalPreviousSectionHint == __LINE__ )                 \
        -: 5927:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 5928:
        -: 5929:#endif
        -: 5930:
        -: 5931:
        -: 5932:#endif // CATCH_SECTION_HPP_INCLUDED
        -: 5933:
        -: 5934:
        -: 5935:#ifndef CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 5936:#define CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 5937:
        -: 5938:
        -: 5939:
        -: 5940:#ifndef CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED
        -: 5941:#define CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED
        -: 5942:
        -: 5943:namespace Catch {
        -: 5944:
        -: 5945:    class ITestInvoker {
        -: 5946:    public:
        -: 5947:        virtual void invoke() const = 0;
        -: 5948:        virtual ~ITestInvoker(); // = default
        -: 5949:    };
        -: 5950:
        -: 5951:} // namespace Catch
        -: 5952:
        -: 5953:#endif // CATCH_INTERFACES_TEST_INVOKER_HPP_INCLUDED
        -: 5954:
        -: 5955:
        -: 5956:#ifndef CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED
        -: 5957:#define CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED
        -: 5958:
        -: 5959:#define INTERNAL_CATCH_EXPAND1( param ) INTERNAL_CATCH_EXPAND2( param )
        -: 5960:#define INTERNAL_CATCH_EXPAND2( ... ) INTERNAL_CATCH_NO##__VA_ARGS__
        -: 5961:#define INTERNAL_CATCH_DEF( ... ) INTERNAL_CATCH_DEF __VA_ARGS__
        -: 5962:#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
        -: 5963:
        -: 5964:#define INTERNAL_CATCH_REMOVE_PARENS( ... ) \
        -: 5965:    INTERNAL_CATCH_EXPAND1( INTERNAL_CATCH_DEF __VA_ARGS__ )
        -: 5966:
        -: 5967:#endif // CATCH_PREPROCESSOR_REMOVE_PARENS_HPP_INCLUDED
        -: 5968:
        -: 5969:// GCC 5 and older do not properly handle disabling unused-variable warning
        -: 5970:// with a _Pragma. This means that we have to leak the suppression to the
        -: 5971:// user code as well :-(
        -: 5972:#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
        -: 5973:#pragma GCC diagnostic ignored "-Wunused-variable"
        -: 5974:#endif
        -: 5975:
        -: 5976:
        -: 5977:
        -: 5978:namespace Catch {
        -: 5979:
        -: 5980:template<typename C>
        -: 5981:class TestInvokerAsMethod : public ITestInvoker {
        -: 5982:    void (C::*m_testAsMethod)();
        -: 5983:public:
        -: 5984:    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
        -: 5985:
        -: 5986:    void invoke() const override {
        -: 5987:        C obj;
        -: 5988:        (obj.*m_testAsMethod)();
        -: 5989:    }
        -: 5990:};
        -: 5991:
        -: 5992:Detail::unique_ptr<ITestInvoker> makeTestInvoker( void(*testAsFunction)() );
        -: 5993:
        -: 5994:template<typename C>
        -: 5995:Detail::unique_ptr<ITestInvoker> makeTestInvoker( void (C::*testAsMethod)() ) {
        -: 5996:    return Detail::make_unique<TestInvokerAsMethod<C>>( testAsMethod );
        -: 5997:}
        -: 5998:
        -: 5999:struct NameAndTags {
       32: 6000:    constexpr NameAndTags( StringRef name_ = StringRef(),
        -: 6001:                           StringRef tags_ = StringRef() ) noexcept:
       32: 6002:        name( name_ ), tags( tags_ ) {}
        -: 6003:    StringRef name;
        -: 6004:    StringRef tags;
        -: 6005:};
        -: 6006:
        -: 6007:struct AutoReg : Detail::NonCopyable {
        -: 6008:    AutoReg( Detail::unique_ptr<ITestInvoker> invoker, SourceLineInfo const& lineInfo, StringRef classOrMethod, NameAndTags const& nameAndTags ) noexcept;
        -: 6009:};
        -: 6010:
        -: 6011:} // end namespace Catch
        -: 6012:
        -: 6013:#if defined(CATCH_CONFIG_DISABLE)
        -: 6014:    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
        -: 6015:        static inline void TestName()
        -: 6016:    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
        -: 6017:        namespace{                        \
        -: 6018:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
        -: 6019:                void test();              \
        -: 6020:            };                            \
        -: 6021:        }                                 \
        -: 6022:        void TestName::test()
        -: 6023:#endif
        -: 6024:
        -: 6025:
        -: 6026:#if !defined(CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT)
        -: 6027:
        -: 6028:    ///////////////////////////////////////////////////////////////////////////////
        -: 6029:    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        -: 6030:        static void TestName(); \
        -: 6031:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6032:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6033:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6034:        namespace{ const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
        -: 6035:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6036:        static void TestName()
        -: 6037:    #define INTERNAL_CATCH_TESTCASE( ... ) \
        -: 6038:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__ )
        -: 6039:
        -: 6040:#else  // ^^ !CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT | vv CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT
        -: 6041:
        -: 6042:
        -: 6043:// Dummy registrator for the dumy test case macros
        -: 6044:namespace Catch {
        -: 6045:    namespace Detail {
        -: 6046:        struct DummyUse {
        -: 6047:            DummyUse( void ( * )( int ), Catch::NameAndTags const& );
        -: 6048:        };
        -: 6049:    } // namespace Detail
        -: 6050:} // namespace Catch
        -: 6051:
        -: 6052:// Note that both the presence of the argument and its exact name are
        -: 6053:// necessary for the section support.
        -: 6054:
        -: 6055:// We provide a shadowed variable so that a `SECTION` inside non-`TEST_CASE`
        -: 6056:// tests can compile. The redefined `TEST_CASE` shadows this with param.
        -: 6057:static int catchInternalSectionHint = 0;
        -: 6058:
        -: 6059:#    define INTERNAL_CATCH_TESTCASE2( fname, ... )                         \
        -: 6060:        static void fname( int );                                          \
        -: 6061:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                          \
        -: 6062:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                           \
        -: 6063:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS                   \
        -: 6064:        static const Catch::Detail::DummyUse INTERNAL_CATCH_UNIQUE_NAME(   \
        -: 6065:            dummyUser )( &(fname), Catch::NameAndTags{ __VA_ARGS__ } );    \
        -: 6066:        CATCH_INTERNAL_SUPPRESS_SHADOW_WARNINGS                            \
        -: 6067:        static void fname( [[maybe_unused]] int catchInternalSectionHint ) \
        -: 6068:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 6069:#    define INTERNAL_CATCH_TESTCASE( ... ) \
        -: 6070:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( dummyFunction ), __VA_ARGS__ )
        -: 6071:
        -: 6072:
        -: 6073:#endif // CATCH_CONFIG_EXPERIMENTAL_STATIC_ANALYSIS_SUPPORT
        -: 6074:
        -: 6075:    ///////////////////////////////////////////////////////////////////////////////
        -: 6076:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        -: 6077:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6078:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6079:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6080:        namespace{ \
        -: 6081:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
        -: 6082:                void test(); \
        -: 6083:            }; \
        -: 6084:            const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \
        -: 6085:            Catch::makeTestInvoker( &TestName::test ),                    \
        -: 6086:            CATCH_INTERNAL_LINEINFO,                                      \
        -: 6087:            #ClassName##_catch_sr,                                        \
        -: 6088:            Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -: 6089:        } \
        -: 6090:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6091:        void TestName::test()
        -: 6092:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        -: 6093:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), ClassName, __VA_ARGS__ )
        -: 6094:
        -: 6095:
        -: 6096:    ///////////////////////////////////////////////////////////////////////////////
        -: 6097:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        -: 6098:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6099:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6100:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6101:        namespace {                                                           \
        -: 6102:        const Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( \
        -: 6103:            Catch::makeTestInvoker( &QualifiedMethod ),                   \
        -: 6104:            CATCH_INTERNAL_LINEINFO,                                      \
        -: 6105:            "&" #QualifiedMethod##_catch_sr,                              \
        -: 6106:            Catch::NameAndTags{ __VA_ARGS__ } );                          \
        -: 6107:    } /* NOLINT */ \
        -: 6108:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -: 6109:
        -: 6110:
        -: 6111:    ///////////////////////////////////////////////////////////////////////////////
        -: 6112:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        -: 6113:        do { \
        -: 6114:            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6115:            CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6116:            CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6117:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
        -: 6118:            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6119:        } while(false)
        -: 6120:
        -: 6121:
        -: 6122:#endif // CATCH_TEST_REGISTRY_HPP_INCLUDED
        -: 6123:
        -: 6124:
        -: 6125:// All of our user-facing macros support configuration toggle, that
        -: 6126:// forces them to be defined prefixed with CATCH_. We also like to
        -: 6127:// support another toggle that can minimize (disable) their implementation.
        -: 6128:// Given this, we have 4 different configuration options below
        -: 6129:
        -: 6130:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 6131:
        -: 6132:  #define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6133:  #define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 6134:
        -: 6135:  #define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6136:  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -: 6137:  #define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6138:
        -: 6139:  #define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6140:  #define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 6141:  #define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6142:  #define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6143:  #define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6144:
        -: 6145:  #define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6146:  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -: 6147:  #define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6148:
        -: 6149:  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -: 6150:  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6151:  #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -: 6152:  #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -: 6153:  #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -: 6154:  #define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
        -: 6155:  #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6156:  #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6157:  #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6158:  #define CATCH_SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6159:
        -: 6160:
        -: 6161:  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
        -: 6162:    #define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
        -: 6163:    #define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )
        -: 6164:    #define CATCH_STATIC_CHECK( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
        -: 6165:    #define CATCH_STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )
        -: 6166:  #else
        -: 6167:    #define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
        -: 6168:    #define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
        -: 6169:    #define CATCH_STATIC_CHECK( ... )       CATCH_CHECK( __VA_ARGS__ )
        -: 6170:    #define CATCH_STATIC_CHECK_FALSE( ... ) CATCH_CHECK_FALSE( __VA_ARGS__ )
        -: 6171:  #endif
        -: 6172:
        -: 6173:
        -: 6174:  // "BDD-style" convenience wrappers
        -: 6175:  #define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
        -: 6176:  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -: 6177:  #define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
        -: 6178:  #define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
        -: 6179:  #define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
        -: 6180:  #define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
        -: 6181:  #define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
        -: 6182:  #define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
        -: 6183:
        -: 6184:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) // ^^ prefixed, implemented | vv prefixed, disabled
        -: 6185:
        -: 6186:  #define CATCH_REQUIRE( ... )        (void)(0)
        -: 6187:  #define CATCH_REQUIRE_FALSE( ... )  (void)(0)
        -: 6188:
        -: 6189:  #define CATCH_REQUIRE_THROWS( ... ) (void)(0)
        -: 6190:  #define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 6191:  #define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
        -: 6192:
        -: 6193:  #define CATCH_CHECK( ... )         (void)(0)
        -: 6194:  #define CATCH_CHECK_FALSE( ... )   (void)(0)
        -: 6195:  #define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
        -: 6196:  #define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
        -: 6197:  #define CATCH_CHECK_NOFAIL( ... )  (void)(0)
        -: 6198:
        -: 6199:  #define CATCH_CHECK_THROWS( ... )  (void)(0)
        -: 6200:  #define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 6201:  #define CATCH_CHECK_NOTHROW( ... ) (void)(0)
        -: 6202:
        -: 6203:  #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))
        -: 6204:  #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))
        -: 6205:  #define CATCH_METHOD_AS_TEST_CASE( method, ... )
        -: 6206:  #define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -: 6207:  #define CATCH_SECTION( ... )
        -: 6208:  #define CATCH_DYNAMIC_SECTION( ... )
        -: 6209:  #define CATCH_FAIL( ... ) (void)(0)
        -: 6210:  #define CATCH_FAIL_CHECK( ... ) (void)(0)
        -: 6211:  #define CATCH_SUCCEED( ... ) (void)(0)
        -: 6212:  #define CATCH_SKIP( ... ) (void)(0)
        -: 6213:
        -: 6214:  #define CATCH_STATIC_REQUIRE( ... )       (void)(0)
        -: 6215:  #define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
        -: 6216:  #define CATCH_STATIC_CHECK( ... )       (void)(0)
        -: 6217:  #define CATCH_STATIC_CHECK_FALSE( ... ) (void)(0)
        -: 6218:
        -: 6219:  // "BDD-style" convenience wrappers
        -: 6220:  #define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))
        -: 6221:  #define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )
        -: 6222:  #define CATCH_GIVEN( desc )
        -: 6223:  #define CATCH_AND_GIVEN( desc )
        -: 6224:  #define CATCH_WHEN( desc )
        -: 6225:  #define CATCH_AND_WHEN( desc )
        -: 6226:  #define CATCH_THEN( desc )
        -: 6227:  #define CATCH_AND_THEN( desc )
        -: 6228:
        -: 6229:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE) // ^^ prefixed, disabled | vv unprefixed, implemented
        -: 6230:
        -: 6231:  #define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
        -: 6232:  #define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 6233:
        -: 6234:  #define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6235:  #define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -: 6236:  #define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6237:
        -: 6238:  #define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6239:  #define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
        -: 6240:  #define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6241:  #define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6242:  #define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
        -: 6243:
        -: 6244:  #define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6245:  #define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -: 6246:  #define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6247:
        -: 6248:  #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -: 6249:  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6250:  #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -: 6251:  #define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -: 6252:  #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -: 6253:  #define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
        -: 6254:  #define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6255:  #define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6256:  #define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -: 6257:  #define SKIP( ... ) INTERNAL_CATCH_MSG( "SKIP", Catch::ResultWas::ExplicitSkip, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -: 6258:
        -: 6259:
        -: 6260:  #if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
        -: 6261:    #define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
        -: 6262:    #define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )
        -: 6263:    #define STATIC_CHECK( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
        -: 6264:    #define STATIC_CHECK_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )
        -: 6265:  #else
        -: 6266:    #define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
        -: 6267:    #define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
        -: 6268:    #define STATIC_CHECK( ... )       CHECK( __VA_ARGS__ )
        -: 6269:    #define STATIC_CHECK_FALSE( ... ) CHECK_FALSE( __VA_ARGS__ )
        -: 6270:  #endif
        -: 6271:
        -: 6272:  // "BDD-style" convenience wrappers
        -: 6273:  #define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
        -: 6274:  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -: 6275:  #define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
        -: 6276:  #define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
        -: 6277:  #define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
        -: 6278:  #define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
        -: 6279:  #define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
        -: 6280:  #define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
        -: 6281:
        -: 6282:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE) // ^^ unprefixed, implemented | vv unprefixed, disabled
        -: 6283:
        -: 6284:  #define REQUIRE( ... )       (void)(0)
        -: 6285:  #define REQUIRE_FALSE( ... ) (void)(0)
        -: 6286:
        -: 6287:  #define REQUIRE_THROWS( ... ) (void)(0)
        -: 6288:  #define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 6289:  #define REQUIRE_NOTHROW( ... ) (void)(0)
        -: 6290:
        -: 6291:  #define CHECK( ... ) (void)(0)
        -: 6292:  #define CHECK_FALSE( ... ) (void)(0)
        -: 6293:  #define CHECKED_IF( ... ) if (__VA_ARGS__)
        -: 6294:  #define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
        -: 6295:  #define CHECK_NOFAIL( ... ) (void)(0)
        -: 6296:
        -: 6297:  #define CHECK_THROWS( ... )  (void)(0)
        -: 6298:  #define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
        -: 6299:  #define CHECK_NOTHROW( ... ) (void)(0)
        -: 6300:
        -: 6301:  #define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), __VA_ARGS__)
        -: 6302:  #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ))
        -: 6303:  #define METHOD_AS_TEST_CASE( method, ... )
        -: 6304:  #define REGISTER_TEST_CASE( Function, ... ) (void)(0)
        -: 6305:  #define SECTION( ... )
        -: 6306:  #define DYNAMIC_SECTION( ... )
        -: 6307:  #define FAIL( ... ) (void)(0)
        -: 6308:  #define FAIL_CHECK( ... ) (void)(0)
        -: 6309:  #define SUCCEED( ... ) (void)(0)
        -: 6310:  #define SKIP( ... ) (void)(0)
        -: 6311:
        -: 6312:  #define STATIC_REQUIRE( ... )       (void)(0)
        -: 6313:  #define STATIC_REQUIRE_FALSE( ... ) (void)(0)
        -: 6314:  #define STATIC_CHECK( ... )       (void)(0)
        -: 6315:  #define STATIC_CHECK_FALSE( ... ) (void)(0)
        -: 6316:
        -: 6317:  // "BDD-style" convenience wrappers
        -: 6318:  #define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ) )
        -: 6319:  #define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEST_ ), className )
        -: 6320:
        -: 6321:  #define GIVEN( desc )
        -: 6322:  #define AND_GIVEN( desc )
        -: 6323:  #define WHEN( desc )
        -: 6324:  #define AND_WHEN( desc )
        -: 6325:  #define THEN( desc )
        -: 6326:  #define AND_THEN( desc )
        -: 6327:
        -: 6328:#endif // ^^ unprefixed, disabled
        -: 6329:
        -: 6330:// end of user facing macros
        -: 6331:
        -: 6332:#endif // CATCH_TEST_MACROS_HPP_INCLUDED
        -: 6333:
        -: 6334:
        -: 6335:#ifndef CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 6336:#define CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 6337:
        -: 6338:
        -: 6339:
        -: 6340:#ifndef CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 6341:#define CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 6342:
        -: 6343:
        -: 6344:#if defined(__GNUC__)
        -: 6345:// We need to silence "empty __VA_ARGS__ warning", and using just _Pragma does not work
        -: 6346:#pragma GCC system_header
        -: 6347:#endif
        -: 6348:
        -: 6349:
        -: 6350:#define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
        -: 6351:#define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
        -: 6352:#define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
        -: 6353:#define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
        -: 6354:#define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
        -: 6355:#define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))
        -: 6356:
        -: 6357:#ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6358:#define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
        -: 6359:// MSVC needs more evaluations
        -: 6360:#define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
        -: 6361:#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
        -: 6362:#else
        -: 6363:#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
        -: 6364:#endif
        -: 6365:
        -: 6366:#define CATCH_REC_END(...)
        -: 6367:#define CATCH_REC_OUT
        -: 6368:
        -: 6369:#define CATCH_EMPTY()
        -: 6370:#define CATCH_DEFER(id) id CATCH_EMPTY()
        -: 6371:
        -: 6372:#define CATCH_REC_GET_END2() 0, CATCH_REC_END
        -: 6373:#define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
        -: 6374:#define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
        -: 6375:#define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
        -: 6376:#define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
        -: 6377:#define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)
        -: 6378:
        -: 6379:#define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
        -: 6380:#define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
        -: 6381:#define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
        -: 6382:
        -: 6383:#define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 6384:#define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 6385:#define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
        -: 6386:
        -: 6387:// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,
        -: 6388:// and passes userdata as the first parameter to each invocation,
        -: 6389:// e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)
        -: 6390:#define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
        -: 6391:
        -: 6392:#define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
        -: 6393:
        -: 6394:#define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
        -: 6395:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6396:#define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
        -: 6397:#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
        -: 6398:#else
        -: 6399:// MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
        -: 6400:#define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
        -: 6401:#define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
        -: 6402:#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
        -: 6403:#endif
        -: 6404:
        -: 6405:#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
        -: 6406:#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)
        -: 6407:
        -: 6408:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6409:#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())
        -: 6410:#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
        -: 6411:#else
        -: 6412:#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))
        -: 6413:#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
        -: 6414:#endif
        -: 6415:
        -: 6416:#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
        -: 6417:    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)
        -: 6418:
        -: 6419:#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
        -: 6420:#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
        -: 6421:#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
        -: 6422:#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
        -: 6423:#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
        -: 6424:#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
        -: 6425:#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _3, _4, _5, _6)
        -: 6426:#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
        -: 6427:#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
        -: 6428:#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
        -: 6429:#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)
        -: 6430:
        -: 6431:#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
        -: 6432:
        -: 6433:#define INTERNAL_CATCH_TYPE_GEN\
        -: 6434:    template<typename...> struct TypeList {};\
        -: 6435:    template<typename...Ts>\
        -: 6436:    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\
        -: 6437:    template<template<typename...> class...> struct TemplateTypeList{};\
        -: 6438:    template<template<typename...> class...Cs>\
        -: 6439:    constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> { return {}; }\
        -: 6440:    template<typename...>\
        -: 6441:    struct append;\
        -: 6442:    template<typename...>\
        -: 6443:    struct rewrap;\
        -: 6444:    template<template<typename...> class, typename...>\
        -: 6445:    struct create;\
        -: 6446:    template<template<typename...> class, typename>\
        -: 6447:    struct convert;\
        -: 6448:    \
        -: 6449:    template<typename T> \
        -: 6450:    struct append<T> { using type = T; };\
        -: 6451:    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\
        -: 6452:    struct append<L1<E1...>, L2<E2...>, Rest...> { using type = typename append<L1<E1...,E2...>, Rest...>::type; };\
        -: 6453:    template< template<typename...> class L1, typename...E1, typename...Rest>\
        -: 6454:    struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> { using type = L1<E1...>; };\
        -: 6455:    \
        -: 6456:    template< template<typename...> class Container, template<typename...> class List, typename...elems>\
        -: 6457:    struct rewrap<TemplateTypeList<Container>, List<elems...>> { using type = TypeList<Container<elems...>>; };\
        -: 6458:    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\
        -: 6459:    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> { using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; };\
        -: 6460:    \
        -: 6461:    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\
        -: 6462:    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; };\
        -: 6463:    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\
        -: 6464:    struct convert<Final, List<Ts...>> { using type = typename append<Final<>,TypeList<Ts>...>::type; };
        -: 6465:
        -: 6466:#define INTERNAL_CATCH_NTTP_1(signature, ...)\
        -: 6467:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\
        -: 6468:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6469:    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \
        -: 6470:    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList{};\
        -: 6471:    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\
        -: 6472:    constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> { return {}; } \
        -: 6473:    \
        -: 6474:    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6475:    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> { using type = TypeList<Container<__VA_ARGS__>>; };\
        -: 6476:    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\
        -: 6477:    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> { using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; };\
        -: 6478:    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\
        -: 6479:    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; };
        -: 6480:
        -: 6481:#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
        -: 6482:#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
        -: 6483:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6484:    static void TestName()
        -: 6485:#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
        -: 6486:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6487:    static void TestName()
        -: 6488:
        -: 6489:#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
        -: 6490:#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
        -: 6491:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6492:    static void TestName()
        -: 6493:#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
        -: 6494:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6495:    static void TestName()
        -: 6496:
        -: 6497:#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
        -: 6498:    template<typename Type>\
        -: 6499:    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\
        -: 6500:    {\
        -: 6501:        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
        -: 6502:    }
        -: 6503:
        -: 6504:#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
        -: 6505:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6506:    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\
        -: 6507:    {\
        -: 6508:        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
        -: 6509:    }
        -: 6510:
        -: 6511:#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
        -: 6512:    template<typename Type>\
        -: 6513:    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
        -: 6514:    {\
        -: 6515:        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
        -: 6516:    }
        -: 6517:
        -: 6518:#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
        -: 6519:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
        -: 6520:    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
        -: 6521:    {\
        -: 6522:        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
        -: 6523:    }
        -: 6524:
        -: 6525:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
        -: 6526:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
        -: 6527:    template<typename TestType> \
        -: 6528:    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \
        -: 6529:        void test();\
        -: 6530:    }
        -: 6531:
        -: 6532:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
        -: 6533:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
        -: 6534:    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \
        -: 6535:        void test();\
        -: 6536:    }
        -: 6537:
        -: 6538:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
        -: 6539:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
        -: 6540:    template<typename TestType> \
        -: 6541:    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()
        -: 6542:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
        -: 6543:    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
        -: 6544:    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()
        -: 6545:
        -: 6546:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6547:#define INTERNAL_CATCH_NTTP_0
        -: 6548:#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
        -: 6549:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
        -: 6550:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
        -: 6551:#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
        -: 6552:#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
        -: 6553:#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
        -: 6554:#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
        -: 6555:#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
        -: 6556:#else
        -: 6557:#define INTERNAL_CATCH_NTTP_0(signature)
        -: 6558:#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
        -: 6559:#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
        -: 6560:#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
        -: 6561:#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
        -: 6562:#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
        -: 6563:#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
        -: 6564:#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
        -: 6565:#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
        -: 6566:#endif
        -: 6567:
        -: 6568:#endif // CATCH_PREPROCESSOR_HPP_INCLUDED
        -: 6569:
        -: 6570:
        -: 6571:// GCC 5 and older do not properly handle disabling unused-variable warning
        -: 6572:// with a _Pragma. This means that we have to leak the suppression to the
        -: 6573:// user code as well :-(
        -: 6574:#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ <= 5
        -: 6575:#pragma GCC diagnostic ignored "-Wunused-variable"
        -: 6576:#endif
        -: 6577:
        -: 6578:#if defined(CATCH_CONFIG_DISABLE)
        -: 6579:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
        -: 6580:        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6581:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
        -: 6582:        namespace{                                                                                  \
        -: 6583:            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
        -: 6584:            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 6585:        }                                                                                           \
        -: 6586:        }                                                                                           \
        -: 6587:        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6588:
        -: 6589:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6590:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
        -: 6591:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )
        -: 6592:    #else
        -: 6593:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
        -: 6594:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
        -: 6595:    #endif
        -: 6596:
        -: 6597:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6598:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
        -: 6599:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )
        -: 6600:    #else
        -: 6601:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
        -: 6602:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6603:    #endif
        -: 6604:
        -: 6605:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6606:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
        -: 6607:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 6608:    #else
        -: 6609:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
        -: 6610:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
        -: 6611:    #endif
        -: 6612:
        -: 6613:    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6614:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
        -: 6615:            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6616:    #else
        -: 6617:        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
        -: 6618:            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6619:    #endif
        -: 6620:#endif
        -: 6621:
        -: 6622:
        -: 6623:    ///////////////////////////////////////////////////////////////////////////////
        -: 6624:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
        -: 6625:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6626:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6627:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6628:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6629:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6630:        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \
        -: 6631:        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 6632:        namespace {\
        -: 6633:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
        -: 6634:            INTERNAL_CATCH_TYPE_GEN\
        -: 6635:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6636:            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6637:            template<typename...Types> \
        -: 6638:            struct TestName{\
        -: 6639:                TestName(){\
        -: 6640:                    size_t index = 0;                                    \
        -: 6641:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)}; /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */\
        -: 6642:                    using expander = size_t[]; /* NOLINT(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,hicpp-avoid-c-arrays) */\
        -: 6643:                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++)... };/* NOLINT */ \
        -: 6644:                }\
        -: 6645:            };\
        -: 6646:            static const int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6647:            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
        -: 6648:            return 0;\
        -: 6649:        }();\
        -: 6650:        }\
        -: 6651:        }\
        -: 6652:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6653:        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6654:
        -: 6655:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6656:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        -: 6657:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ )
        -: 6658:#else
        -: 6659:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
        -: 6660:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
        -: 6661:#endif
        -: 6662:
        -: 6663:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6664:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        -: 6665:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ )
        -: 6666:#else
        -: 6667:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
        -: 6668:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6669:#endif
        -: 6670:
        -: 6671:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
        -: 6672:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
        -: 6673:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
        -: 6674:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
        -: 6675:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS       \
        -: 6676:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6677:        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \
        -: 6678:        template<typename TestType> static void TestFuncName();       \
        -: 6679:        namespace {\
        -: 6680:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
        -: 6681:            INTERNAL_CATCH_TYPE_GEN                                                  \
        -: 6682:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
        -: 6683:            template<typename... Types>                               \
        -: 6684:            struct TestName {                                         \
        -: 6685:                void reg_tests() {                                          \
        -: 6686:                    size_t index = 0;                                    \
        -: 6687:                    using expander = size_t[];                           \
        -: 6688:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
        -: 6689:                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
        -: 6690:                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
        -: 6691:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags } ), index++)... };/* NOLINT */\
        -: 6692:                }                                                     \
        -: 6693:            };                                                        \
        -: 6694:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
        -: 6695:                using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \
        -: 6696:                TestInit t;                                           \
        -: 6697:                t.reg_tests();                                        \
        -: 6698:                return 0;                                             \
        -: 6699:            }();                                                      \
        -: 6700:        }                                                             \
        -: 6701:        }                                                             \
        -: 6702:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        -: 6703:        template<typename TestType>                                   \
        -: 6704:        static void TestFuncName()
        -: 6705:
        -: 6706:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6707:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        -: 6708:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T,__VA_ARGS__)
        -: 6709:#else
        -: 6710:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
        -: 6711:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, typename T, __VA_ARGS__ ) )
        -: 6712:#endif
        -: 6713:
        -: 6714:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6715:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        -: 6716:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__)
        -: 6717:#else
        -: 6718:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
        -: 6719:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6720:#endif
        -: 6721:
        -: 6722:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
        -: 6723:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6724:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6725:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6726:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6727:        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \
        -: 6728:        template<typename TestType> static void TestFunc();       \
        -: 6729:        namespace {\
        -: 6730:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
        -: 6731:        INTERNAL_CATCH_TYPE_GEN\
        -: 6732:        template<typename... Types>                               \
        -: 6733:        struct TestName {                                         \
        -: 6734:            void reg_tests() {                                          \
        -: 6735:                size_t index = 0;                                    \
        -: 6736:                using expander = size_t[];                           \
        -: 6737:                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags } ), index++)... };/* NOLINT */\
        -: 6738:            }                                                     \
        -: 6739:        };\
        -: 6740:        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
        -: 6741:                using TestInit = typename convert<TestName, TmplList>::type; \
        -: 6742:                TestInit t;                                           \
        -: 6743:                t.reg_tests();                                        \
        -: 6744:                return 0;                                             \
        -: 6745:            }();                                                      \
        -: 6746:        }}\
        -: 6747:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
        -: 6748:        template<typename TestType>                                   \
        -: 6749:        static void TestFunc()
        -: 6750:
        -: 6751:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
        -: 6752:        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), Name, Tags, TmplList )
        -: 6753:
        -: 6754:
        -: 6755:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
        -: 6756:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6757:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6758:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6759:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6760:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6761:        namespace {\
        -: 6762:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
        -: 6763:            INTERNAL_CATCH_TYPE_GEN\
        -: 6764:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6765:            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
        -: 6766:            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6767:            template<typename...Types> \
        -: 6768:            struct TestNameClass{\
        -: 6769:                TestNameClass(){\
        -: 6770:                    size_t index = 0;                                    \
        -: 6771:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
        -: 6772:                    using expander = size_t[];\
        -: 6773:                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++)... };/* NOLINT */ \
        -: 6774:                }\
        -: 6775:            };\
        -: 6776:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6777:                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
        -: 6778:                return 0;\
        -: 6779:        }();\
        -: 6780:        }\
        -: 6781:        }\
        -: 6782:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6783:        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
        -: 6784:
        -: 6785:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6786:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        -: 6787:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 6788:#else
        -: 6789:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
        -: 6790:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
        -: 6791:#endif
        -: 6792:
        -: 6793:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6794:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        -: 6795:        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6796:#else
        -: 6797:    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
        -: 6798:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_CLASS_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
        -: 6799:#endif
        -: 6800:
        -: 6801:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
        -: 6802:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6803:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6804:        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
        -: 6805:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6806:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6807:        template<typename TestType> \
        -: 6808:            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
        -: 6809:                void test();\
        -: 6810:            };\
        -: 6811:        namespace {\
        -: 6812:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
        -: 6813:            INTERNAL_CATCH_TYPE_GEN                  \
        -: 6814:            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
        -: 6815:            template<typename...Types>\
        -: 6816:            struct TestNameClass{\
        -: 6817:                void reg_tests(){\
        -: 6818:                    std::size_t index = 0;\
        -: 6819:                    using expander = std::size_t[];\
        -: 6820:                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
        -: 6821:                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
        -: 6822:                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
        -: 6823:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + '<' + std::string(types_list[index % num_types]) + '>', Tags } ), index++)... };/* NOLINT */ \
        -: 6824:                }\
        -: 6825:            };\
        -: 6826:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6827:                using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\
        -: 6828:                TestInit t;\
        -: 6829:                t.reg_tests();\
        -: 6830:                return 0;\
        -: 6831:            }(); \
        -: 6832:        }\
        -: 6833:        }\
        -: 6834:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6835:        template<typename TestType> \
        -: 6836:        void TestName<TestType>::test()
        -: 6837:
        -: 6838:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6839:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        -: 6840:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
        -: 6841:#else
        -: 6842:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
        -: 6843:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
        -: 6844:#endif
        -: 6845:
        -: 6846:#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6847:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        -: 6848:        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
        -: 6849:#else
        -: 6850:    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
        -: 6851:        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
        -: 6852:#endif
        -: 6853:
        -: 6854:    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
        -: 6855:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 6856:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 6857:        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
        -: 6858:        CATCH_INTERNAL_SUPPRESS_UNUSED_VARIABLE_WARNINGS \
        -: 6859:        CATCH_INTERNAL_SUPPRESS_COMMA_WARNINGS \
        -: 6860:        template<typename TestType> \
        -: 6861:        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
        -: 6862:            void test();\
        -: 6863:        };\
        -: 6864:        namespace {\
        -: 6865:        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
        -: 6866:            INTERNAL_CATCH_TYPE_GEN\
        -: 6867:            template<typename...Types>\
        -: 6868:            struct TestNameClass{\
        -: 6869:                void reg_tests(){\
        -: 6870:                    size_t index = 0;\
        -: 6871:                    using expander = size_t[];\
        -: 6872:                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName##_catch_sr, Catch::NameAndTags{ Name " - " INTERNAL_CATCH_STRINGIZE(TmplList) " - " + std::to_string(index), Tags } ), index++)... };/* NOLINT */ \
        -: 6873:                }\
        -: 6874:            };\
        -: 6875:            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
        -: 6876:                using TestInit = typename convert<TestNameClass, TmplList>::type;\
        -: 6877:                TestInit t;\
        -: 6878:                t.reg_tests();\
        -: 6879:                return 0;\
        -: 6880:            }(); \
        -: 6881:        }}\
        -: 6882:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 6883:        template<typename TestType> \
        -: 6884:        void TestName<TestType>::test()
        -: 6885:
        -: 6886:#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
        -: 6887:        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), INTERNAL_CATCH_UNIQUE_NAME( CATCH2_INTERNAL_TEMPLATE_TEST_ ), ClassName, Name, Tags, TmplList )
        -: 6888:
        -: 6889:
        -: 6890:#endif // CATCH_TEMPLATE_TEST_REGISTRY_HPP_INCLUDED
        -: 6891:
        -: 6892:
        -: 6893:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 6894:
        -: 6895:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6896:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6897:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6898:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6899:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6900:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
        -: 6901:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6902:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6903:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6904:    #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
        -: 6905:    #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6906:  #else
        -: 6907:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
        -: 6908:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6909:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6910:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6911:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
        -: 6912:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6913:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6914:    #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6915:    #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
        -: 6916:    #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6917:  #endif
        -: 6918:
        -: 6919:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 6920:
        -: 6921:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6922:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
        -: 6923:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
        -: 6924:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
        -: 6925:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
        -: 6926:  #else
        -: 6927:    #define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
        -: 6928:    #define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
        -: 6929:    #define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6930:    #define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6931:  #endif
        -: 6932:
        -: 6933:  // When disabled, these can be shared between proper preprocessor and MSVC preprocessor
        -: 6934:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6935:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6936:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6937:  #define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6938:  #define CATCH_TEMPLATE_LIST_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE(__VA_ARGS__)
        -: 6939:  #define CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6940:
        -: 6941:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -: 6942:
        -: 6943:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6944:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6945:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6946:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6947:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6948:    #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
        -: 6949:    #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
        -: 6950:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6951:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
        -: 6952:    #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
        -: 6953:    #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6954:  #else
        -: 6955:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
        -: 6956:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6957:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6958:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6959:    #define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
        -: 6960:    #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
        -: 6961:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6962:    #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
        -: 6963:    #define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
        -: 6964:    #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
        -: 6965:  #endif
        -: 6966:
        -: 6967:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -: 6968:
        -: 6969:  #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
        -: 6970:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
        -: 6971:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
        -: 6972:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
        -: 6973:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
        -: 6974:  #else
        -: 6975:    #define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
        -: 6976:    #define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
        -: 6977:    #define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6978:    #define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
        -: 6979:  #endif
        -: 6980:
        -: 6981:  // When disabled, these can be shared between proper preprocessor and MSVC preprocessor
        -: 6982:  #define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6983:  #define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
        -: 6984:  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6985:  #define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6986:  #define TEMPLATE_LIST_TEST_CASE( ... ) TEMPLATE_TEST_CASE(__VA_ARGS__)
        -: 6987:  #define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -: 6988:
        -: 6989:#endif // end of user facing macro declarations
        -: 6990:
        -: 6991:
        -: 6992:#endif // CATCH_TEMPLATE_TEST_MACROS_HPP_INCLUDED
        -: 6993:
        -: 6994:
        -: 6995:#ifndef CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 6996:#define CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 6997:
        -: 6998:
        -: 6999:
        -: 7000:#include <cstdint>
        -: 7001:#include <string>
        -: 7002:#include <vector>
        -: 7003:
        -: 7004:#ifdef __clang__
        -: 7005:#pragma clang diagnostic push
        -: 7006:#pragma clang diagnostic ignored "-Wpadded"
        -: 7007:#endif
        -: 7008:
        -: 7009:namespace Catch {
        -: 7010:
        -: 7011:    /**
        -: 7012:     * A **view** of a tag string that provides case insensitive comparisons
        -: 7013:     *
        -: 7014:     * Note that in Catch2 internals, the square brackets around tags are
        -: 7015:     * not a part of tag's representation, so e.g. "[cool-tag]" is represented
        -: 7016:     * as "cool-tag" internally.
        -: 7017:     */
        -: 7018:    struct Tag {
        -: 7019:        constexpr Tag(StringRef original_):
        -: 7020:            original(original_)
        -: 7021:        {}
        -: 7022:        StringRef original;
        -: 7023:
        -: 7024:        friend bool operator< ( Tag const& lhs, Tag const& rhs );
        -: 7025:        friend bool operator==( Tag const& lhs, Tag const& rhs );
        -: 7026:    };
        -: 7027:
        -: 7028:    class ITestInvoker;
        -: 7029:    struct NameAndTags;
        -: 7030:
        -: 7031:    enum class TestCaseProperties : uint8_t {
        -: 7032:        None = 0,
        -: 7033:        IsHidden = 1 << 1,
        -: 7034:        ShouldFail = 1 << 2,
        -: 7035:        MayFail = 1 << 3,
        -: 7036:        Throws = 1 << 4,
        -: 7037:        NonPortable = 1 << 5,
        -: 7038:        Benchmark = 1 << 6
        -: 7039:    };
        -: 7040:
        -: 7041:    /**
        -: 7042:     * Various metadata about the test case.
        -: 7043:     *
        -: 7044:     * A test case is uniquely identified by its (class)name and tags
        -: 7045:     * combination, with source location being ignored, and other properties
        -: 7046:     * being determined from tags.
        -: 7047:     *
        -: 7048:     * Tags are kept sorted.
        -: 7049:     */
        -: 7050:    struct TestCaseInfo : Detail::NonCopyable {
        -: 7051:
        -: 7052:        TestCaseInfo(StringRef _className,
        -: 7053:                     NameAndTags const& _nameAndTags,
        -: 7054:                     SourceLineInfo const& _lineInfo);
        -: 7055:
        -: 7056:        bool isHidden() const;
        -: 7057:        bool throws() const;
        -: 7058:        bool okToFail() const;
        -: 7059:        bool expectedToFail() const;
        -: 7060:
        -: 7061:        // Adds the tag(s) with test's filename (for the -# flag)
        -: 7062:        void addFilenameTag();
        -: 7063:
        -: 7064:        //! Orders by name, classname and tags
        -: 7065:        friend bool operator<( TestCaseInfo const& lhs,
        -: 7066:                               TestCaseInfo const& rhs );
        -: 7067:
        -: 7068:
        -: 7069:        std::string tagsAsString() const;
        -: 7070:
        -: 7071:        std::string name;
        -: 7072:        StringRef className;
        -: 7073:    private:
        -: 7074:        std::string backingTags;
        -: 7075:        // Internally we copy tags to the backing storage and then add
        -: 7076:        // refs to this storage to the tags vector.
        -: 7077:        void internalAppendTag(StringRef tagString);
        -: 7078:    public:
        -: 7079:        std::vector<Tag> tags;
        -: 7080:        SourceLineInfo lineInfo;
        -: 7081:        TestCaseProperties properties = TestCaseProperties::None;
        -: 7082:    };
        -: 7083:
        -: 7084:    /**
        -: 7085:     * Wrapper over the test case information and the test case invoker
        -: 7086:     *
        -: 7087:     * Does not own either, and is specifically made to be cheap
        -: 7088:     * to copy around.
        -: 7089:     */
        -: 7090:    class TestCaseHandle {
        -: 7091:        TestCaseInfo* m_info;
        -: 7092:        ITestInvoker* m_invoker;
        -: 7093:    public:
        -: 7094:        TestCaseHandle(TestCaseInfo* info, ITestInvoker* invoker) :
        -: 7095:            m_info(info), m_invoker(invoker) {}
        -: 7096:
        -: 7097:        void invoke() const {
        -: 7098:            m_invoker->invoke();
        -: 7099:        }
        -: 7100:
        -: 7101:        TestCaseInfo const& getTestCaseInfo() const;
        -: 7102:    };
        -: 7103:
        -: 7104:    Detail::unique_ptr<TestCaseInfo>
        -: 7105:    makeTestCaseInfo( StringRef className,
        -: 7106:                      NameAndTags const& nameAndTags,
        -: 7107:                      SourceLineInfo const& lineInfo );
        -: 7108:}
        -: 7109:
        -: 7110:#ifdef __clang__
        -: 7111:#pragma clang diagnostic pop
        -: 7112:#endif
        -: 7113:
        -: 7114:#endif // CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 7115:
        -: 7116:
        -: 7117:#ifndef CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 7118:#define CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 7119:
        -: 7120:
        -: 7121:
        -: 7122:#ifndef CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 7123:#define CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 7124:
        -: 7125:
        -: 7126:#include <string>
        -: 7127:#include <vector>
        -: 7128:
        -: 7129:namespace Catch {
        -: 7130:    using exceptionTranslateFunction = std::string(*)();
        -: 7131:
        -: 7132:    class IExceptionTranslator;
        -: 7133:    using ExceptionTranslators = std::vector<Detail::unique_ptr<IExceptionTranslator const>>;
        -: 7134:
        -: 7135:    class IExceptionTranslator {
        -: 7136:    public:
        -: 7137:        virtual ~IExceptionTranslator(); // = default
        -: 7138:        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
        -: 7139:    };
        -: 7140:
        -: 7141:    class IExceptionTranslatorRegistry {
        -: 7142:    public:
        -: 7143:        virtual ~IExceptionTranslatorRegistry(); // = default
        -: 7144:        virtual std::string translateActiveException() const = 0;
        -: 7145:    };
        -: 7146:
        -: 7147:} // namespace Catch
        -: 7148:
        -: 7149:#endif // CATCH_INTERFACES_EXCEPTION_HPP_INCLUDED
        -: 7150:
        -: 7151:#include <exception>
        -: 7152:
        -: 7153:namespace Catch {
        -: 7154:    namespace Detail {
        -: 7155:        void registerTranslatorImpl(
        -: 7156:            Detail::unique_ptr<IExceptionTranslator>&& translator );
        -: 7157:    }
        -: 7158:
        -: 7159:    class ExceptionTranslatorRegistrar {
        -: 7160:        template<typename T>
        -: 7161:        class ExceptionTranslator : public IExceptionTranslator {
        -: 7162:        public:
        -: 7163:
        -: 7164:            ExceptionTranslator( std::string(*translateFunction)( T const& ) )
        -: 7165:            : m_translateFunction( translateFunction )
        -: 7166:            {}
        -: 7167:
        -: 7168:            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
        -: 7169:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 7170:                try {
        -: 7171:                    if( it == itEnd )
        -: 7172:                        std::rethrow_exception(std::current_exception());
        -: 7173:                    else
        -: 7174:                        return (*it)->translate( it+1, itEnd );
        -: 7175:                }
        -: 7176:                catch( T const& ex ) {
        -: 7177:                    return m_translateFunction( ex );
        -: 7178:                }
        -: 7179:#else
        -: 7180:                return "You should never get here!";
        -: 7181:#endif
        -: 7182:            }
        -: 7183:
        -: 7184:        protected:
        -: 7185:            std::string(*m_translateFunction)( T const& );
        -: 7186:        };
        -: 7187:
        -: 7188:    public:
        -: 7189:        template<typename T>
        -: 7190:        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T const& ) ) {
        -: 7191:            Detail::registerTranslatorImpl(
        -: 7192:                Detail::make_unique<ExceptionTranslator<T>>(
        -: 7193:                    translateFunction ) );
        -: 7194:        }
        -: 7195:    };
        -: 7196:
        -: 7197:} // namespace Catch
        -: 7198:
        -: 7199:///////////////////////////////////////////////////////////////////////////////
        -: 7200:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
        -: 7201:    static std::string translatorName( signature ); \
        -: 7202:    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
        -: 7203:    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
        -: 7204:    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
        -: 7205:    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
        -: 7206:    static std::string translatorName( signature )
        -: 7207:
        -: 7208:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 7209:
        -: 7210:#if defined(CATCH_CONFIG_DISABLE)
        -: 7211:    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
        -: 7212:            static std::string translatorName( signature )
        -: 7213:#endif
        -: 7214:
        -: 7215:
        -: 7216:// This macro is always prefixed
        -: 7217:#if !defined(CATCH_CONFIG_DISABLE)
        -: 7218:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
        -: 7219:#else
        -: 7220:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 7221:#endif
        -: 7222:
        -: 7223:
        -: 7224:#endif // CATCH_TRANSLATE_EXCEPTION_HPP_INCLUDED
        -: 7225:
        -: 7226:
        -: 7227:#ifndef CATCH_VERSION_HPP_INCLUDED
        -: 7228:#define CATCH_VERSION_HPP_INCLUDED
        -: 7229:
        -: 7230:#include <iosfwd>
        -: 7231:
        -: 7232:namespace Catch {
        -: 7233:
        -: 7234:    // Versioning information
        -: 7235:    struct Version {
        -: 7236:        Version( Version const& ) = delete;
        -: 7237:        Version& operator=( Version const& ) = delete;
        -: 7238:        Version(    unsigned int _majorVersion,
        -: 7239:                    unsigned int _minorVersion,
        -: 7240:                    unsigned int _patchNumber,
        -: 7241:                    char const * const _branchName,
        -: 7242:                    unsigned int _buildNumber );
        -: 7243:
        -: 7244:        unsigned int const majorVersion;
        -: 7245:        unsigned int const minorVersion;
        -: 7246:        unsigned int const patchNumber;
        -: 7247:
        -: 7248:        // buildNumber is only used if branchName is not null
        -: 7249:        char const * const branchName;
        -: 7250:        unsigned int const buildNumber;
        -: 7251:
        -: 7252:        friend std::ostream& operator << ( std::ostream& os, Version const& version );
        -: 7253:    };
        -: 7254:
        -: 7255:    Version const& libraryVersion();
        -: 7256:}
        -: 7257:
        -: 7258:#endif // CATCH_VERSION_HPP_INCLUDED
        -: 7259:
        -: 7260:
        -: 7261:#ifndef CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 7262:#define CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 7263:
        -: 7264:#define CATCH_VERSION_MAJOR 3
        -: 7265:#define CATCH_VERSION_MINOR 5
        -: 7266:#define CATCH_VERSION_PATCH 3
        -: 7267:
        -: 7268:#endif // CATCH_VERSION_MACROS_HPP_INCLUDED
        -: 7269:
        -: 7270:
        -: 7271:/** \file
        -: 7272: * This is a convenience header for Catch2's Generator support. It includes
        -: 7273: * **all** of Catch2 headers related to generators.
        -: 7274: *
        -: 7275: * Generally the Catch2 users should use specific includes they need,
        -: 7276: * but this header can be used instead for ease-of-experimentation, or
        -: 7277: * just plain convenience, at the cost of (significantly) increased
        -: 7278: * compilation times.
        -: 7279: *
        -: 7280: * When a new header is added to either the `generators` folder,
        -: 7281: * or to the corresponding internal subfolder, it should be added here.
        -: 7282: */
        -: 7283:
        -: 7284:#ifndef CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 7285:#define CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 7286:
        -: 7287:
        -: 7288:
        -: 7289:#ifndef CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 7290:#define CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 7291:
        -: 7292:#include <exception>
        -: 7293:
        -: 7294:namespace Catch {
        -: 7295:
        -: 7296:    // Exception type to be thrown when a Generator runs into an error,
        -: 7297:    // e.g. it cannot initialize the first return value based on
        -: 7298:    // runtime information
        -: 7299:    class GeneratorException : public std::exception {
        -: 7300:        const char* const m_msg = "";
        -: 7301:
        -: 7302:    public:
        -: 7303:        GeneratorException(const char* msg):
        -: 7304:            m_msg(msg)
        -: 7305:        {}
        -: 7306:
        -: 7307:        const char* what() const noexcept override final;
        -: 7308:    };
        -: 7309:
        -: 7310:} // end namespace Catch
        -: 7311:
        -: 7312:#endif // CATCH_GENERATOR_EXCEPTION_HPP_INCLUDED
        -: 7313:
        -: 7314:
        -: 7315:#ifndef CATCH_GENERATORS_HPP_INCLUDED
        -: 7316:#define CATCH_GENERATORS_HPP_INCLUDED
        -: 7317:
        -: 7318:
        -: 7319:
        -: 7320:#ifndef CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 7321:#define CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 7322:
        -: 7323:
        -: 7324:#include <string>
        -: 7325:
        -: 7326:namespace Catch {
        -: 7327:
        -: 7328:    namespace Generators {
        -: 7329:        class GeneratorUntypedBase {
        -: 7330:            // Caches result from `toStringImpl`, assume that when it is an
        -: 7331:            // empty string, the cache is invalidated.
        -: 7332:            mutable std::string m_stringReprCache;
        -: 7333:
        -: 7334:            // Counts based on `next` returning true
        -: 7335:            std::size_t m_currentElementIndex = 0;
        -: 7336:
        -: 7337:            /**
        -: 7338:             * Attempts to move the generator to the next element
        -: 7339:             *
        -: 7340:             * Returns true iff the move succeeded (and a valid element
        -: 7341:             * can be retrieved).
        -: 7342:             */
        -: 7343:            virtual bool next() = 0;
        -: 7344:
        -: 7345:            //! Customization point for `currentElementAsString`
        -: 7346:            virtual std::string stringifyImpl() const = 0;
        -: 7347:
        -: 7348:        public:
        -: 7349:            GeneratorUntypedBase() = default;
        -: 7350:            // Generation of copy ops is deprecated (and Clang will complain)
        -: 7351:            // if there is a user destructor defined
        -: 7352:            GeneratorUntypedBase(GeneratorUntypedBase const&) = default;
        -: 7353:            GeneratorUntypedBase& operator=(GeneratorUntypedBase const&) = default;
        -: 7354:
        -: 7355:            virtual ~GeneratorUntypedBase(); // = default;
        -: 7356:
        -: 7357:            /**
        -: 7358:             * Attempts to move the generator to the next element
        -: 7359:             *
        -: 7360:             * Serves as a non-virtual interface to `next`, so that the
        -: 7361:             * top level interface can provide sanity checking and shared
        -: 7362:             * features.
        -: 7363:             *
        -: 7364:             * As with `next`, returns true iff the move succeeded and
        -: 7365:             * the generator has new valid element to provide.
        -: 7366:             */
        -: 7367:            bool countedNext();
        -: 7368:
        -: 7369:            std::size_t currentElementIndex() const { return m_currentElementIndex; }
        -: 7370:
        -: 7371:            /**
        -: 7372:             * Returns generator's current element as user-friendly string.
        -: 7373:             *
        -: 7374:             * By default returns string equivalent to calling
        -: 7375:             * `Catch::Detail::stringify` on the current element, but generators
        -: 7376:             * can customize their implementation as needed.
        -: 7377:             *
        -: 7378:             * Not thread-safe due to internal caching.
        -: 7379:             *
        -: 7380:             * The returned ref is valid only until the generator instance
        -: 7381:             * is destructed, or it moves onto the next element, whichever
        -: 7382:             * comes first.
        -: 7383:             */
        -: 7384:            StringRef currentElementAsString() const;
        -: 7385:        };
        -: 7386:        using GeneratorBasePtr = Catch::Detail::unique_ptr<GeneratorUntypedBase>;
        -: 7387:
        -: 7388:    } // namespace Generators
        -: 7389:
        -: 7390:    class IGeneratorTracker {
        -: 7391:    public:
        -: 7392:        virtual ~IGeneratorTracker(); // = default;
        -: 7393:        virtual auto hasGenerator() const -> bool = 0;
        -: 7394:        virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
        -: 7395:        virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
        -: 7396:    };
        -: 7397:
        -: 7398:} // namespace Catch
        -: 7399:
        -: 7400:#endif // CATCH_INTERFACES_GENERATORTRACKER_HPP_INCLUDED
        -: 7401:
        -: 7402:#include <vector>
        -: 7403:#include <tuple>
        -: 7404:
        -: 7405:namespace Catch {
        -: 7406:
        -: 7407:namespace Generators {
        -: 7408:
        -: 7409:namespace Detail {
        -: 7410:
        -: 7411:    //! Throws GeneratorException with the provided message
        -: 7412:    [[noreturn]]
        -: 7413:    void throw_generator_exception(char const * msg);
        -: 7414:
        -: 7415:} // end namespace detail
        -: 7416:
        -: 7417:    template<typename T>
        -: 7418:    class IGenerator : public GeneratorUntypedBase {
        -: 7419:        std::string stringifyImpl() const override {
        -: 7420:            return ::Catch::Detail::stringify( get() );
        -: 7421:        }
        -: 7422:
        -: 7423:    public:
        -: 7424:        // Returns the current element of the generator
        -: 7425:        //
        -: 7426:        // \Precondition The generator is either freshly constructed,
        -: 7427:        // or the last call to `next()` returned true
        -: 7428:        virtual T const& get() const = 0;
        -: 7429:        using type = T;
        -: 7430:    };
        -: 7431:
        -: 7432:    template <typename T>
        -: 7433:    using GeneratorPtr = Catch::Detail::unique_ptr<IGenerator<T>>;
        -: 7434:
        -: 7435:    template <typename T>
        -: 7436:    class GeneratorWrapper final {
        -: 7437:        GeneratorPtr<T> m_generator;
        -: 7438:    public:
        -: 7439:        //! Takes ownership of the passed pointer.
        -: 7440:        GeneratorWrapper(IGenerator<T>* generator):
        -: 7441:            m_generator(generator) {}
        -: 7442:        GeneratorWrapper(GeneratorPtr<T> generator):
        -: 7443:            m_generator(CATCH_MOVE(generator)) {}
        -: 7444:
        -: 7445:        T const& get() const {
        -: 7446:            return m_generator->get();
        -: 7447:        }
        -: 7448:        bool next() {
        -: 7449:            return m_generator->countedNext();
        -: 7450:        }
        -: 7451:    };
        -: 7452:
        -: 7453:
        -: 7454:    template<typename T>
        -: 7455:    class SingleValueGenerator final : public IGenerator<T> {
        -: 7456:        T m_value;
        -: 7457:    public:
        -: 7458:        SingleValueGenerator(T const& value) :
        -: 7459:            m_value(value)
        -: 7460:        {}
        -: 7461:        SingleValueGenerator(T&& value):
        -: 7462:            m_value(CATCH_MOVE(value))
        -: 7463:        {}
        -: 7464:
        -: 7465:        T const& get() const override {
        -: 7466:            return m_value;
        -: 7467:        }
        -: 7468:        bool next() override {
        -: 7469:            return false;
        -: 7470:        }
        -: 7471:    };
        -: 7472:
        -: 7473:    template<typename T>
        -: 7474:    class FixedValuesGenerator final : public IGenerator<T> {
        -: 7475:        static_assert(!std::is_same<T, bool>::value,
        -: 7476:            "FixedValuesGenerator does not support bools because of std::vector<bool>"
        -: 7477:            "specialization, use SingleValue Generator instead.");
        -: 7478:        std::vector<T> m_values;
        -: 7479:        size_t m_idx = 0;
        -: 7480:    public:
        -: 7481:        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
        -: 7482:
        -: 7483:        T const& get() const override {
        -: 7484:            return m_values[m_idx];
        -: 7485:        }
        -: 7486:        bool next() override {
        -: 7487:            ++m_idx;
        -: 7488:            return m_idx < m_values.size();
        -: 7489:        }
        -: 7490:    };
        -: 7491:
        -: 7492:    template <typename T, typename DecayedT = std::decay_t<T>>
        -: 7493:    GeneratorWrapper<DecayedT> value( T&& value ) {
        -: 7494:        return GeneratorWrapper<DecayedT>(
        -: 7495:            Catch::Detail::make_unique<SingleValueGenerator<DecayedT>>(
        -: 7496:                CATCH_FORWARD( value ) ) );
        -: 7497:    }
        -: 7498:    template <typename T>
        -: 7499:    GeneratorWrapper<T> values(std::initializer_list<T> values) {
        -: 7500:        return GeneratorWrapper<T>(Catch::Detail::make_unique<FixedValuesGenerator<T>>(values));
        -: 7501:    }
        -: 7502:
        -: 7503:    template<typename T>
        -: 7504:    class Generators : public IGenerator<T> {
        -: 7505:        std::vector<GeneratorWrapper<T>> m_generators;
        -: 7506:        size_t m_current = 0;
        -: 7507:
        -: 7508:        void add_generator( GeneratorWrapper<T>&& generator ) {
        -: 7509:            m_generators.emplace_back( CATCH_MOVE( generator ) );
        -: 7510:        }
        -: 7511:        void add_generator( T const& val ) {
        -: 7512:            m_generators.emplace_back( value( val ) );
        -: 7513:        }
        -: 7514:        void add_generator( T&& val ) {
        -: 7515:            m_generators.emplace_back( value( CATCH_MOVE( val ) ) );
        -: 7516:        }
        -: 7517:        template <typename U>
        -: 7518:        std::enable_if_t<!std::is_same<std::decay_t<U>, T>::value>
        -: 7519:        add_generator( U&& val ) {
        -: 7520:            add_generator( T( CATCH_FORWARD( val ) ) );
        -: 7521:        }
        -: 7522:
        -: 7523:        template <typename U> void add_generators( U&& valueOrGenerator ) {
        -: 7524:            add_generator( CATCH_FORWARD( valueOrGenerator ) );
        -: 7525:        }
        -: 7526:
        -: 7527:        template <typename U, typename... Gs>
        -: 7528:        void add_generators( U&& valueOrGenerator, Gs&&... moreGenerators ) {
        -: 7529:            add_generator( CATCH_FORWARD( valueOrGenerator ) );
        -: 7530:            add_generators( CATCH_FORWARD( moreGenerators )... );
        -: 7531:        }
        -: 7532:
        -: 7533:    public:
        -: 7534:        template <typename... Gs>
        -: 7535:        Generators(Gs &&... moreGenerators) {
        -: 7536:            m_generators.reserve(sizeof...(Gs));
        -: 7537:            add_generators(CATCH_FORWARD(moreGenerators)...);
        -: 7538:        }
        -: 7539:
        -: 7540:        T const& get() const override {
        -: 7541:            return m_generators[m_current].get();
        -: 7542:        }
        -: 7543:
        -: 7544:        bool next() override {
        -: 7545:            if (m_current >= m_generators.size()) {
        -: 7546:                return false;
        -: 7547:            }
        -: 7548:            const bool current_status = m_generators[m_current].next();
        -: 7549:            if (!current_status) {
        -: 7550:                ++m_current;
        -: 7551:            }
        -: 7552:            return m_current < m_generators.size();
        -: 7553:        }
        -: 7554:    };
        -: 7555:
        -: 7556:
        -: 7557:    template <typename... Ts>
        -: 7558:    GeneratorWrapper<std::tuple<std::decay_t<Ts>...>>
        -: 7559:    table( std::initializer_list<std::tuple<std::decay_t<Ts>...>> tuples ) {
        -: 7560:        return values<std::tuple<Ts...>>( tuples );
        -: 7561:    }
        -: 7562:
        -: 7563:    // Tag type to signal that a generator sequence should convert arguments to a specific type
        -: 7564:    template <typename T>
        -: 7565:    struct as {};
        -: 7566:
        -: 7567:    template<typename T, typename... Gs>
        -: 7568:    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
        -: 7569:        return Generators<T>(CATCH_MOVE(generator), CATCH_FORWARD(moreGenerators)...);
        -: 7570:    }
        -: 7571:    template<typename T>
        -: 7572:    auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
        -: 7573:        return Generators<T>(CATCH_MOVE(generator));
        -: 7574:    }
        -: 7575:    template<typename T, typename... Gs>
        -: 7576:    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<std::decay_t<T>> {
        -: 7577:        return makeGenerators( value( CATCH_FORWARD( val ) ), CATCH_FORWARD( moreGenerators )... );
        -: 7578:    }
        -: 7579:    template<typename T, typename U, typename... Gs>
        -: 7580:    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
        -: 7581:        return makeGenerators( value( T( CATCH_FORWARD( val ) ) ), CATCH_FORWARD( moreGenerators )... );
        -: 7582:    }
        -: 7583:
        -: 7584:    IGeneratorTracker* acquireGeneratorTracker( StringRef generatorName,
        -: 7585:                                                SourceLineInfo const& lineInfo );
        -: 7586:    IGeneratorTracker* createGeneratorTracker( StringRef generatorName,
        -: 7587:                                               SourceLineInfo lineInfo,
        -: 7588:                                               GeneratorBasePtr&& generator );
        -: 7589:
        -: 7590:    template<typename L>
        -: 7591:    auto generate( StringRef generatorName, SourceLineInfo const& lineInfo, L const& generatorExpression ) -> typename decltype(generatorExpression())::type {
        -: 7592:        using UnderlyingType = typename decltype(generatorExpression())::type;
        -: 7593:
        -: 7594:        IGeneratorTracker* tracker = acquireGeneratorTracker( generatorName, lineInfo );
        -: 7595:        // Creation of tracker is delayed after generator creation, so
        -: 7596:        // that constructing generator can fail without breaking everything.
        -: 7597:        if (!tracker) {
        -: 7598:            tracker = createGeneratorTracker(
        -: 7599:                generatorName,
        -: 7600:                lineInfo,
        -: 7601:                Catch::Detail::make_unique<Generators<UnderlyingType>>(
        -: 7602:                    generatorExpression() ) );
        -: 7603:        }
        -: 7604:
        -: 7605:        auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker->getGenerator() );
        -: 7606:        return generator.get();
        -: 7607:    }
        -: 7608:
        -: 7609:} // namespace Generators
        -: 7610:} // namespace Catch
        -: 7611:
        -: 7612:#define CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL( ... ) #__VA_ARGS__##_catch_sr
        -: 7613:#define CATCH_INTERNAL_GENERATOR_STRINGIZE(...) CATCH_INTERNAL_GENERATOR_STRINGIZE_IMPL(__VA_ARGS__)
        -: 7614:
        -: 7615:#define GENERATE( ... ) \
        -: 7616:    Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 7617:                                 CATCH_INTERNAL_LINEINFO, \
        -: 7618:                                 [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 7619:#define GENERATE_COPY( ... ) \
        -: 7620:    Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 7621:                                 CATCH_INTERNAL_LINEINFO, \
        -: 7622:                                 [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 7623:#define GENERATE_REF( ... ) \
        -: 7624:    Catch::Generators::generate( CATCH_INTERNAL_GENERATOR_STRINGIZE(INTERNAL_CATCH_UNIQUE_NAME(generator)), \
        -: 7625:                                 CATCH_INTERNAL_LINEINFO, \
        -: 7626:                                 [&]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
        -: 7627:
        -: 7628:#endif // CATCH_GENERATORS_HPP_INCLUDED
        -: 7629:
        -: 7630:
        -: 7631:#ifndef CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 7632:#define CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 7633:
        -: 7634:
        -: 7635:#include <cassert>
        -: 7636:
        -: 7637:namespace Catch {
        -: 7638:namespace Generators {
        -: 7639:
        -: 7640:    template <typename T>
        -: 7641:    class TakeGenerator final : public IGenerator<T> {
        -: 7642:        GeneratorWrapper<T> m_generator;
        -: 7643:        size_t m_returned = 0;
        -: 7644:        size_t m_target;
        -: 7645:    public:
        -: 7646:        TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
        -: 7647:            m_generator(CATCH_MOVE(generator)),
        -: 7648:            m_target(target)
        -: 7649:        {
        -: 7650:            assert(target != 0 && "Empty generators are not allowed");
        -: 7651:        }
        -: 7652:        T const& get() const override {
        -: 7653:            return m_generator.get();
        -: 7654:        }
        -: 7655:        bool next() override {
        -: 7656:            ++m_returned;
        -: 7657:            if (m_returned >= m_target) {
        -: 7658:                return false;
        -: 7659:            }
        -: 7660:
        -: 7661:            const auto success = m_generator.next();
        -: 7662:            // If the underlying generator does not contain enough values
        -: 7663:            // then we cut short as well
        -: 7664:            if (!success) {
        -: 7665:                m_returned = m_target;
        -: 7666:            }
        -: 7667:            return success;
        -: 7668:        }
        -: 7669:    };
        -: 7670:
        -: 7671:    template <typename T>
        -: 7672:    GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
        -: 7673:        return GeneratorWrapper<T>(Catch::Detail::make_unique<TakeGenerator<T>>(target, CATCH_MOVE(generator)));
        -: 7674:    }
        -: 7675:
        -: 7676:
        -: 7677:    template <typename T, typename Predicate>
        -: 7678:    class FilterGenerator final : public IGenerator<T> {
        -: 7679:        GeneratorWrapper<T> m_generator;
        -: 7680:        Predicate m_predicate;
        -: 7681:    public:
        -: 7682:        template <typename P = Predicate>
        -: 7683:        FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
        -: 7684:            m_generator(CATCH_MOVE(generator)),
        -: 7685:            m_predicate(CATCH_FORWARD(pred))
        -: 7686:        {
        -: 7687:            if (!m_predicate(m_generator.get())) {
        -: 7688:                // It might happen that there are no values that pass the
        -: 7689:                // filter. In that case we throw an exception.
        -: 7690:                auto has_initial_value = next();
        -: 7691:                if (!has_initial_value) {
        -: 7692:                    Detail::throw_generator_exception("No valid value found in filtered generator");
        -: 7693:                }
        -: 7694:            }
        -: 7695:        }
        -: 7696:
        -: 7697:        T const& get() const override {
        -: 7698:            return m_generator.get();
        -: 7699:        }
        -: 7700:
        -: 7701:        bool next() override {
        -: 7702:            bool success = m_generator.next();
        -: 7703:            if (!success) {
        -: 7704:                return false;
        -: 7705:            }
        -: 7706:            while (!m_predicate(m_generator.get()) && (success = m_generator.next()) == true);
        -: 7707:            return success;
        -: 7708:        }
        -: 7709:    };
        -: 7710:
        -: 7711:
        -: 7712:    template <typename T, typename Predicate>
        -: 7713:    GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
        -: 7714:        return GeneratorWrapper<T>(Catch::Detail::make_unique<FilterGenerator<T, Predicate>>(CATCH_FORWARD(pred), CATCH_MOVE(generator)));
        -: 7715:    }
        -: 7716:
        -: 7717:    template <typename T>
        -: 7718:    class RepeatGenerator final : public IGenerator<T> {
        -: 7719:        static_assert(!std::is_same<T, bool>::value,
        -: 7720:            "RepeatGenerator currently does not support bools"
        -: 7721:            "because of std::vector<bool> specialization");
        -: 7722:        GeneratorWrapper<T> m_generator;
        -: 7723:        mutable std::vector<T> m_returned;
        -: 7724:        size_t m_target_repeats;
        -: 7725:        size_t m_current_repeat = 0;
        -: 7726:        size_t m_repeat_index = 0;
        -: 7727:    public:
        -: 7728:        RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
        -: 7729:            m_generator(CATCH_MOVE(generator)),
        -: 7730:            m_target_repeats(repeats)
        -: 7731:        {
        -: 7732:            assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
        -: 7733:        }
        -: 7734:
        -: 7735:        T const& get() const override {
        -: 7736:            if (m_current_repeat == 0) {
        -: 7737:                m_returned.push_back(m_generator.get());
        -: 7738:                return m_returned.back();
        -: 7739:            }
        -: 7740:            return m_returned[m_repeat_index];
        -: 7741:        }
        -: 7742:
        -: 7743:        bool next() override {
        -: 7744:            // There are 2 basic cases:
        -: 7745:            // 1) We are still reading the generator
        -: 7746:            // 2) We are reading our own cache
        -: 7747:
        -: 7748:            // In the first case, we need to poke the underlying generator.
        -: 7749:            // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
        -: 7750:            if (m_current_repeat == 0) {
        -: 7751:                const auto success = m_generator.next();
        -: 7752:                if (!success) {
        -: 7753:                    ++m_current_repeat;
        -: 7754:                }
        -: 7755:                return m_current_repeat < m_target_repeats;
        -: 7756:            }
        -: 7757:
        -: 7758:            // In the second case, we need to move indices forward and check that we haven't run up against the end
        -: 7759:            ++m_repeat_index;
        -: 7760:            if (m_repeat_index == m_returned.size()) {
        -: 7761:                m_repeat_index = 0;
        -: 7762:                ++m_current_repeat;
        -: 7763:            }
        -: 7764:            return m_current_repeat < m_target_repeats;
        -: 7765:        }
        -: 7766:    };
        -: 7767:
        -: 7768:    template <typename T>
        -: 7769:    GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
        -: 7770:        return GeneratorWrapper<T>(Catch::Detail::make_unique<RepeatGenerator<T>>(repeats, CATCH_MOVE(generator)));
        -: 7771:    }
        -: 7772:
        -: 7773:    template <typename T, typename U, typename Func>
        -: 7774:    class MapGenerator final : public IGenerator<T> {
        -: 7775:        // TBD: provide static assert for mapping function, for friendly error message
        -: 7776:        GeneratorWrapper<U> m_generator;
        -: 7777:        Func m_function;
        -: 7778:        // To avoid returning dangling reference, we have to save the values
        -: 7779:        T m_cache;
        -: 7780:    public:
        -: 7781:        template <typename F2 = Func>
        -: 7782:        MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
        -: 7783:            m_generator(CATCH_MOVE(generator)),
        -: 7784:            m_function(CATCH_FORWARD(function)),
        -: 7785:            m_cache(m_function(m_generator.get()))
        -: 7786:        {}
        -: 7787:
        -: 7788:        T const& get() const override {
        -: 7789:            return m_cache;
        -: 7790:        }
        -: 7791:        bool next() override {
        -: 7792:            const auto success = m_generator.next();
        -: 7793:            if (success) {
        -: 7794:                m_cache = m_function(m_generator.get());
        -: 7795:            }
        -: 7796:            return success;
        -: 7797:        }
        -: 7798:    };
        -: 7799:
        -: 7800:    template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
        -: 7801:    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        -: 7802:        return GeneratorWrapper<T>(
        -: 7803:            Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))
        -: 7804:        );
        -: 7805:    }
        -: 7806:
        -: 7807:    template <typename T, typename U, typename Func>
        -: 7808:    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
        -: 7809:        return GeneratorWrapper<T>(
        -: 7810:            Catch::Detail::make_unique<MapGenerator<T, U, Func>>(CATCH_FORWARD(function), CATCH_MOVE(generator))
        -: 7811:        );
        -: 7812:    }
        -: 7813:
        -: 7814:    template <typename T>
        -: 7815:    class ChunkGenerator final : public IGenerator<std::vector<T>> {
        -: 7816:        std::vector<T> m_chunk;
        -: 7817:        size_t m_chunk_size;
        -: 7818:        GeneratorWrapper<T> m_generator;
        -: 7819:        bool m_used_up = false;
        -: 7820:    public:
        -: 7821:        ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
        -: 7822:            m_chunk_size(size), m_generator(CATCH_MOVE(generator))
        -: 7823:        {
        -: 7824:            m_chunk.reserve(m_chunk_size);
        -: 7825:            if (m_chunk_size != 0) {
        -: 7826:                m_chunk.push_back(m_generator.get());
        -: 7827:                for (size_t i = 1; i < m_chunk_size; ++i) {
        -: 7828:                    if (!m_generator.next()) {
        -: 7829:                        Detail::throw_generator_exception("Not enough values to initialize the first chunk");
        -: 7830:                    }
        -: 7831:                    m_chunk.push_back(m_generator.get());
        -: 7832:                }
        -: 7833:            }
        -: 7834:        }
        -: 7835:        std::vector<T> const& get() const override {
        -: 7836:            return m_chunk;
        -: 7837:        }
        -: 7838:        bool next() override {
        -: 7839:            m_chunk.clear();
        -: 7840:            for (size_t idx = 0; idx < m_chunk_size; ++idx) {
        -: 7841:                if (!m_generator.next()) {
        -: 7842:                    return false;
        -: 7843:                }
        -: 7844:                m_chunk.push_back(m_generator.get());
        -: 7845:            }
        -: 7846:            return true;
        -: 7847:        }
        -: 7848:    };
        -: 7849:
        -: 7850:    template <typename T>
        -: 7851:    GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
        -: 7852:        return GeneratorWrapper<std::vector<T>>(
        -: 7853:            Catch::Detail::make_unique<ChunkGenerator<T>>(size, CATCH_MOVE(generator))
        -: 7854:        );
        -: 7855:    }
        -: 7856:
        -: 7857:} // namespace Generators
        -: 7858:} // namespace Catch
        -: 7859:
        -: 7860:
        -: 7861:#endif // CATCH_GENERATORS_ADAPTERS_HPP_INCLUDED
        -: 7862:
        -: 7863:
        -: 7864:#ifndef CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 7865:#define CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 7866:
        -: 7867:
        -: 7868:
        -: 7869:#ifndef CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7870:#define CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7871:
        -: 7872:#include <cstdint>
        -: 7873:
        -: 7874:namespace Catch {
        -: 7875:
        -: 7876:    // This is a simple implementation of C++11 Uniform Random Number
        -: 7877:    // Generator. It does not provide all operators, because Catch2
        -: 7878:    // does not use it, but it should behave as expected inside stdlib's
        -: 7879:    // distributions.
        -: 7880:    // The implementation is based on the PCG family (http://pcg-random.org)
        -: 7881:    class SimplePcg32 {
        -: 7882:        using state_type = std::uint64_t;
        -: 7883:    public:
        -: 7884:        using result_type = std::uint32_t;
        -: 7885:        static constexpr result_type (min)() {
        -: 7886:            return 0;
        -: 7887:        }
        -: 7888:        static constexpr result_type (max)() {
        -: 7889:            return static_cast<result_type>(-1);
        -: 7890:        }
        -: 7891:
        -: 7892:        // Provide some default initial state for the default constructor
        -: 7893:        SimplePcg32():SimplePcg32(0xed743cc4U) {}
        -: 7894:
        -: 7895:        explicit SimplePcg32(result_type seed_);
        -: 7896:
        -: 7897:        void seed(result_type seed_);
        -: 7898:        void discard(uint64_t skip);
        -: 7899:
        -: 7900:        result_type operator()();
        -: 7901:
        -: 7902:    private:
        -: 7903:        friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
        -: 7904:        friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
        -: 7905:
        -: 7906:        // In theory we also need operator<< and operator>>
        -: 7907:        // In practice we do not use them, so we will skip them for now
        -: 7908:
        -: 7909:
        -: 7910:        std::uint64_t m_state;
        -: 7911:        // This part of the state determines which "stream" of the numbers
        -: 7912:        // is chosen -- we take it as a constant for Catch2, so we only
        -: 7913:        // need to deal with seeding the main state.
        -: 7914:        // Picked by reading 8 bytes from `/dev/random` :-)
        -: 7915:        static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
        -: 7916:    };
        -: 7917:
        -: 7918:} // end namespace Catch
        -: 7919:
        -: 7920:#endif // CATCH_RANDOM_NUMBER_GENERATOR_HPP_INCLUDED
        -: 7921:
        -: 7922:
        -: 7923:
        -: 7924:#ifndef CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED
        -: 7925:#define CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED
        -: 7926:
        -: 7927:
        -: 7928:
        -: 7929:
        -: 7930:#ifndef CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED
        -: 7931:#define CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED
        -: 7932:
        -: 7933:#include <climits>
        -: 7934:#include <cstddef>
        -: 7935:#include <cstdint>
        -: 7936:#include <type_traits>
        -: 7937:
        -: 7938:namespace Catch {
        -: 7939:    namespace Detail {
        -: 7940:
        -: 7941:        template <std::size_t>
        -: 7942:        struct SizedUnsignedType;
        -: 7943:#define SizedUnsignedTypeHelper( TYPE )        \
        -: 7944:    template <>                                \
        -: 7945:    struct SizedUnsignedType<sizeof( TYPE )> { \
        -: 7946:        using type = TYPE;                     \
        -: 7947:    }
        -: 7948:
        -: 7949:        SizedUnsignedTypeHelper( std::uint8_t );
        -: 7950:        SizedUnsignedTypeHelper( std::uint16_t );
        -: 7951:        SizedUnsignedTypeHelper( std::uint32_t );
        -: 7952:        SizedUnsignedTypeHelper( std::uint64_t );
        -: 7953:#undef SizedUnsignedTypeHelper
        -: 7954:
        -: 7955:        template <std::size_t sz>
        -: 7956:        using SizedUnsignedType_t = typename SizedUnsignedType<sz>::type;
        -: 7957:
        -: 7958:        template <typename T>
        -: 7959:        using DoubleWidthUnsignedType_t = SizedUnsignedType_t<2 * sizeof( T )>;
        -: 7960:
        -: 7961:        template <typename T>
        -: 7962:        struct ExtendedMultResult {
        -: 7963:            T upper;
        -: 7964:            T lower;
        -: 7965:            bool operator==( ExtendedMultResult const& rhs ) const {
        -: 7966:                return upper == rhs.upper && lower == rhs.lower;
        -: 7967:            }
        -: 7968:        };
        -: 7969:
        -: 7970:        // Returns 128 bit result of multiplying lhs and rhs
        -: 7971:        constexpr ExtendedMultResult<std::uint64_t>
        -: 7972:        extendedMult( std::uint64_t lhs, std::uint64_t rhs ) {
        -: 7973:            // We use the simple long multiplication approach for
        -: 7974:            // correctness, we can use platform specific builtins
        -: 7975:            // for performance later.
        -: 7976:
        -: 7977:            // Split the lhs and rhs into two 32bit "digits", so that we can
        -: 7978:            // do 64 bit arithmetic to handle carry bits.
        -: 7979:            //            32b    32b    32b    32b
        -: 7980:            //     lhs                  L1     L2
        -: 7981:            //   * rhs                  R1     R2
        -: 7982:            //            ------------------------
        -: 7983:            //                       |  R2 * L2  |
        -: 7984:            //                 |  R2 * L1  |
        -: 7985:            //                 |  R1 * L2  |
        -: 7986:            //           |  R1 * L1  |
        -: 7987:            //           -------------------------
        -: 7988:            //           |  a  |  b  |  c  |  d  |
        -: 7989:
        -: 7990:#define CarryBits( x ) ( x >> 32 )
        -: 7991:#define Digits( x ) ( x & 0xFF'FF'FF'FF )
        -: 7992:
        -: 7993:            auto r2l2 = Digits( rhs ) * Digits( lhs );
        -: 7994:            auto r2l1 = Digits( rhs ) * CarryBits( lhs );
        -: 7995:            auto r1l2 = CarryBits( rhs ) * Digits( lhs );
        -: 7996:            auto r1l1 = CarryBits( rhs ) * CarryBits( lhs );
        -: 7997:
        -: 7998:            // Sum to columns first
        -: 7999:            auto d = Digits( r2l2 );
        -: 8000:            auto c = CarryBits( r2l2 ) + Digits( r2l1 ) + Digits( r1l2 );
        -: 8001:            auto b = CarryBits( r2l1 ) + CarryBits( r1l2 ) + Digits( r1l1 );
        -: 8002:            auto a = CarryBits( r1l1 );
        -: 8003:
        -: 8004:            // Propagate carries between columns
        -: 8005:            c += CarryBits( d );
        -: 8006:            b += CarryBits( c );
        -: 8007:            a += CarryBits( b );
        -: 8008:
        -: 8009:            // Remove the used carries
        -: 8010:            c = Digits( c );
        -: 8011:            b = Digits( b );
        -: 8012:            a = Digits( a );
        -: 8013:
        -: 8014:#undef CarryBits
        -: 8015:#undef Digits
        -: 8016:
        -: 8017:            return {
        -: 8018:                a << 32 | b, // upper 64 bits
        -: 8019:                c << 32 | d  // lower 64 bits
        -: 8020:            };
        -: 8021:        }
        -: 8022:
        -: 8023:        template <typename UInt>
        -: 8024:        constexpr ExtendedMultResult<UInt> extendedMult( UInt lhs, UInt rhs ) {
        -: 8025:            static_assert( std::is_unsigned<UInt>::value,
        -: 8026:                           "extendedMult can only handle unsigned integers" );
        -: 8027:            static_assert( sizeof( UInt ) < sizeof( std::uint64_t ),
        -: 8028:                           "Generic extendedMult can only handle types smaller "
        -: 8029:                           "than uint64_t" );
        -: 8030:            using WideType = DoubleWidthUnsignedType_t<UInt>;
        -: 8031:
        -: 8032:            auto result = WideType( lhs ) * WideType( rhs );
        -: 8033:            return {
        -: 8034:                static_cast<UInt>( result >> ( CHAR_BIT * sizeof( UInt ) ) ),
        -: 8035:                static_cast<UInt>( result & UInt( -1 ) ) };
        -: 8036:        }
        -: 8037:
        -: 8038:
        -: 8039:        template <typename TargetType,
        -: 8040:                  typename Generator>
        -: 8041:            std::enable_if_t<sizeof(typename Generator::result_type) >= sizeof(TargetType),
        -: 8042:            TargetType> fillBitsFrom(Generator& gen) {
        -: 8043:            using gresult_type = typename Generator::result_type;
        -: 8044:            static_assert( std::is_unsigned<TargetType>::value, "Only unsigned integers are supported" );
        -: 8045:            static_assert( Generator::min() == 0 &&
        -: 8046:                           Generator::max() == static_cast<gresult_type>( -1 ),
        -: 8047:                           "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)" );
        -: 8048:
        -: 8049:            // We want to return the top bits from a generator, as they are
        -: 8050:            // usually considered higher quality.
        -: 8051:            constexpr auto generated_bits = sizeof( gresult_type ) * CHAR_BIT;
        -: 8052:            constexpr auto return_bits = sizeof( TargetType ) * CHAR_BIT;
        -: 8053:
        -: 8054:            return static_cast<TargetType>( gen() >>
        -: 8055:                                            ( generated_bits - return_bits) );
        -: 8056:        }
        -: 8057:
        -: 8058:        template <typename TargetType,
        -: 8059:                  typename Generator>
        -: 8060:            std::enable_if_t<sizeof(typename Generator::result_type) < sizeof(TargetType),
        -: 8061:            TargetType> fillBitsFrom(Generator& gen) {
        -: 8062:            using gresult_type = typename Generator::result_type;
        -: 8063:            static_assert( std::is_unsigned<TargetType>::value,
        -: 8064:                           "Only unsigned integers are supported" );
        -: 8065:            static_assert( Generator::min() == 0 &&
        -: 8066:                           Generator::max() == static_cast<gresult_type>( -1 ),
        -: 8067:                           "Generator must be able to output all numbers in its result type (effectively it must be a random bit generator)" );
        -: 8068:
        -: 8069:            constexpr auto generated_bits = sizeof( gresult_type ) * CHAR_BIT;
        -: 8070:            constexpr auto return_bits = sizeof( TargetType ) * CHAR_BIT;
        -: 8071:            std::size_t filled_bits = 0;
        -: 8072:            TargetType ret = 0;
        -: 8073:            do {
        -: 8074:                ret <<= generated_bits;
        -: 8075:                ret |= gen();
        -: 8076:                filled_bits += generated_bits;
        -: 8077:            } while ( filled_bits < return_bits );
        -: 8078:
        -: 8079:            return ret;
        -: 8080:        }
        -: 8081:
        -: 8082:        /*
        -: 8083:         * Transposes numbers into unsigned type while keeping their ordering
        -: 8084:         *
        -: 8085:         * This means that signed types are changed so that the ordering is
        -: 8086:         * [INT_MIN, ..., -1, 0, ..., INT_MAX], rather than order we would
        -: 8087:         * get by simple casting ([0, ..., INT_MAX, INT_MIN, ..., -1])
        -: 8088:         */
        -: 8089:        template <typename OriginalType, typename UnsignedType>
        -: 8090:        std::enable_if_t<std::is_signed<OriginalType>::value, UnsignedType>
        -: 8091:        transposeToNaturalOrder( UnsignedType in ) {
        -: 8092:            static_assert(
        -: 8093:                sizeof( OriginalType ) == sizeof( UnsignedType ),
        -: 8094:                "reordering requires the same sized types on both sides" );
        -: 8095:            static_assert( std::is_unsigned<UnsignedType>::value,
        -: 8096:                           "Input type must be unsigned" );
        -: 8097:            // Assuming 2s complement (standardized in current C++), the
        -: 8098:            // positive and negative numbers are already internally ordered,
        -: 8099:            // and their difference is in the top bit. Swapping it orders
        -: 8100:            // them the desired way.
        -: 8101:            constexpr auto highest_bit =
        -: 8102:                UnsignedType( 1 ) << ( sizeof( UnsignedType ) * CHAR_BIT - 1 );
        -: 8103:            return static_cast<UnsignedType>( in ^ highest_bit );
        -: 8104:        }
        -: 8105:
        -: 8106:
        -: 8107:
        -: 8108:        template <typename OriginalType,
        -: 8109:                  typename UnsignedType>
        -: 8110:        std::enable_if_t<std::is_unsigned<OriginalType>::value, UnsignedType>
        -: 8111:            transposeToNaturalOrder(UnsignedType in) {
        -: 8112:            static_assert(
        -: 8113:                sizeof( OriginalType ) == sizeof( UnsignedType ),
        -: 8114:                "reordering requires the same sized types on both sides" );
        -: 8115:            static_assert( std::is_unsigned<UnsignedType>::value, "Input type must be unsigned" );
        -: 8116:            // No reordering is needed for unsigned -> unsigned
        -: 8117:            return in;
        -: 8118:        }
        -: 8119:    } // namespace Detail
        -: 8120:} // namespace Catch
        -: 8121:
        -: 8122:#endif // CATCH_RANDOM_INTEGER_HELPERS_HPP_INCLUDED
        -: 8123:
        -: 8124:namespace Catch {
        -: 8125:
        -: 8126:    namespace Detail {
        -: 8127:        // Indirection to enable make_unsigned<bool> behaviour.
        -: 8128:        template <typename T>
        -: 8129:        struct make_unsigned {
        -: 8130:            using type = std::make_unsigned_t<T>;
        -: 8131:        };
        -: 8132:
        -: 8133:        template <>
        -: 8134:        struct make_unsigned<bool> {
        -: 8135:            using type = uint8_t;
        -: 8136:        };
        -: 8137:
        -: 8138:        template <typename T>
        -: 8139:        using make_unsigned_t = typename make_unsigned<T>::type;
        -: 8140:    }
        -: 8141:
        -: 8142:/**
        -: 8143: * Implementation of uniform distribution on integers.
        -: 8144: *
        -: 8145: * Unlike `std::uniform_int_distribution`, this implementation supports
        -: 8146: * various 1 byte integral types, including bool (but you should not
        -: 8147: * actually use it for bools).
        -: 8148: *
        -: 8149: * The underlying algorithm is based on the one described in "Fast Random
        -: 8150: * Integer Generation in an Interval" by Daniel Lemire, but has been
        -: 8151: * optimized under the assumption of reuse of the same distribution object.
        -: 8152: */
        -: 8153:template <typename IntegerType>
        -: 8154:class uniform_integer_distribution {
        -: 8155:    static_assert(std::is_integral<IntegerType>::value, "...");
        -: 8156:
        -: 8157:    using UnsignedIntegerType = Detail::make_unsigned_t<IntegerType>;
        -: 8158:
        -: 8159:    // Only the left bound is stored, and we store it converted to its
        -: 8160:    // unsigned image. This avoids having to do the conversions inside
        -: 8161:    // the operator(), at the cost of having to do the conversion in
        -: 8162:    // the a() getter. The right bound is only needed in the b() getter,
        -: 8163:    // so we recompute it there from other stored data.
        -: 8164:    UnsignedIntegerType m_a;
        -: 8165:
        -: 8166:    // How many different values are there in [a, b]. a == b => 1, can be 0 for distribution over all values in the type.
        -: 8167:    UnsignedIntegerType m_ab_distance;
        -: 8168:
        -: 8169:    // We hoisted this out of the main generation function. Technically,
        -: 8170:    // this means that using this distribution will be slower than Lemire's
        -: 8171:    // algorithm if this distribution instance will be used only few times,
        -: 8172:    // but it will be faster if it is used many times. Since Catch2 uses
        -: 8173:    // distributions only to implement random generators, we assume that each
        -: 8174:    // distribution will be reused many times and this is an optimization.
        -: 8175:    UnsignedIntegerType m_rejection_threshold = 0;
        -: 8176:
        -: 8177:    UnsignedIntegerType computeDistance(IntegerType a, IntegerType b) const {
        -: 8178:        // This overflows and returns 0 if a == 0 and b == TYPE_MAX.
        -: 8179:        // We handle that later when generating the number.
        -: 8180:        return transposeTo(b) - transposeTo(a) + 1;
        -: 8181:    }
        -: 8182:
        -: 8183:    static UnsignedIntegerType computeRejectionThreshold(UnsignedIntegerType ab_distance) {
        -: 8184:        // distance == 0 means that we will return all possible values from
        -: 8185:        // the type's range, and that we shouldn't reject anything.
        -: 8186:        if ( ab_distance == 0 ) { return 0; }
        -: 8187:        return ( ~ab_distance + 1 ) % ab_distance;
        -: 8188:    }
        -: 8189:
        -: 8190:    static UnsignedIntegerType transposeTo(IntegerType in) {
        -: 8191:        return Detail::transposeToNaturalOrder<IntegerType>(
        -: 8192:            static_cast<UnsignedIntegerType>( in ) );
        -: 8193:    }
        -: 8194:    static IntegerType transposeBack(UnsignedIntegerType in) {
        -: 8195:        return static_cast<IntegerType>(
        -: 8196:            Detail::transposeToNaturalOrder<IntegerType>(in) );
        -: 8197:    }
        -: 8198:
        -: 8199:public:
        -: 8200:    using result_type = IntegerType;
        -: 8201:
        -: 8202:    uniform_integer_distribution( IntegerType a, IntegerType b ):
        -: 8203:        m_a( transposeTo(a) ),
        -: 8204:        m_ab_distance( computeDistance(a, b) ),
        -: 8205:        m_rejection_threshold( computeRejectionThreshold(m_ab_distance) ) {
        -: 8206:        assert( a <= b );
        -: 8207:    }
        -: 8208:
        -: 8209:    template <typename Generator>
        -: 8210:    result_type operator()( Generator& g ) {
        -: 8211:        // All possible values of result_type are valid.
        -: 8212:        if ( m_ab_distance == 0 ) {
        -: 8213:            return transposeBack( Detail::fillBitsFrom<UnsignedIntegerType>( g ) );
        -: 8214:        }
        -: 8215:
        -: 8216:        auto random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );
        -: 8217:        auto emul = Detail::extendedMult( random_number, m_ab_distance );
        -: 8218:        // Unlike Lemire's algorithm we skip the ab_distance check, since
        -: 8219:        // we precomputed the rejection threshold, which is always tighter.
        -: 8220:        while (emul.lower < m_rejection_threshold) {
        -: 8221:            random_number = Detail::fillBitsFrom<UnsignedIntegerType>( g );
        -: 8222:            emul = Detail::extendedMult( random_number, m_ab_distance );
        -: 8223:        }
        -: 8224:
        -: 8225:        return transposeBack(m_a + emul.upper);
        -: 8226:    }
        -: 8227:
        -: 8228:    result_type a() const { return transposeBack(m_a); }
        -: 8229:    result_type b() const { return transposeBack(m_ab_distance + m_a - 1); }
        -: 8230:};
        -: 8231:
        -: 8232:} // end namespace Catch
        -: 8233:
        -: 8234:#endif // CATCH_UNIFORM_INTEGER_DISTRIBUTION_HPP_INCLUDED
        -: 8235:
        -: 8236:
        -: 8237:
        -: 8238:#ifndef CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED
        -: 8239:#define CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED
        -: 8240:
        -: 8241:
        -: 8242:
        -: 8243:
        -: 8244:#ifndef CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 8245:#define CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 8246:
        -: 8247:
        -: 8248:
        -: 8249:#ifndef CATCH_POLYFILLS_HPP_INCLUDED
        -: 8250:#define CATCH_POLYFILLS_HPP_INCLUDED
        -: 8251:
        -: 8252:namespace Catch {
        -: 8253:
        -: 8254:    bool isnan(float f);
        -: 8255:    bool isnan(double d);
        -: 8256:
        -: 8257:    float nextafter(float x, float y);
        -: 8258:    double nextafter(double x, double y);
        -: 8259:
        -: 8260:}
        -: 8261:
        -: 8262:#endif // CATCH_POLYFILLS_HPP_INCLUDED
        -: 8263:
        -: 8264:#include <cassert>
        -: 8265:#include <cmath>
        -: 8266:#include <cstdint>
        -: 8267:#include <limits>
        -: 8268:#include <type_traits>
        -: 8269:
        -: 8270:namespace Catch {
        -: 8271:
        -: 8272:    namespace Detail {
        -: 8273:        /**
        -: 8274:         * Returns the largest magnitude of 1-ULP distance inside the [a, b] range.
        -: 8275:         *
        -: 8276:         * Assumes `a < b`.
        -: 8277:         */
        -: 8278:        template <typename FloatType>
        -: 8279:        FloatType gamma(FloatType a, FloatType b) {
        -: 8280:            static_assert( std::is_floating_point<FloatType>::value,
        -: 8281:                           "gamma returns the largest ULP magnitude within "
        -: 8282:                           "floating point range [a, b]. This only makes sense "
        -: 8283:                           "for floating point types" );
        -: 8284:            assert( a <= b );
        -: 8285:
        -: 8286:            const auto gamma_up = Catch::nextafter( a, std::numeric_limits<FloatType>::infinity() ) - a;
        -: 8287:            const auto gamma_down = b - Catch::nextafter( b, -std::numeric_limits<FloatType>::infinity() );
        -: 8288:
        -: 8289:            return gamma_up < gamma_down ? gamma_down : gamma_up;
        -: 8290:        }
        -: 8291:
        -: 8292:        template <typename FloatingPoint>
        -: 8293:        struct DistanceTypePicker;
        -: 8294:        template <>
        -: 8295:        struct DistanceTypePicker<float> {
        -: 8296:            using type = std::uint32_t;
        -: 8297:        };
        -: 8298:        template <>
        -: 8299:        struct DistanceTypePicker<double> {
        -: 8300:            using type = std::uint64_t;
        -: 8301:        };
        -: 8302:
        -: 8303:        template <typename T>
        -: 8304:        using DistanceType = typename DistanceTypePicker<T>::type;
        -: 8305:
        -: 8306:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 8307:#    pragma GCC diagnostic push
        -: 8308:#    pragma GCC diagnostic ignored "-Wfloat-equal"
        -: 8309:#endif
        -: 8310:        /**
        -: 8311:         * Computes the number of equi-distant floats in [a, b]
        -: 8312:         *
        -: 8313:         * Since not every range can be split into equidistant floats
        -: 8314:         * exactly, we actually compute ceil(b/distance - a/distance),
        -: 8315:         * because in those cases we want to overcount.
        -: 8316:         *
        -: 8317:         * Uses modified Dekker's FastTwoSum algorithm to handle rounding.
        -: 8318:         */
        -: 8319:        template <typename FloatType>
        -: 8320:        DistanceType<FloatType>
        -: 8321:        count_equidistant_floats( FloatType a, FloatType b, FloatType distance ) {
        -: 8322:            assert( a <= b );
        -: 8323:            // We get distance as gamma for our uniform float distribution,
        -: 8324:            // so this will round perfectly.
        -: 8325:            const auto ag = a / distance;
        -: 8326:            const auto bg = b / distance;
        -: 8327:
        -: 8328:            const auto s = bg - ag;
        -: 8329:            const auto err = ( std::fabs( a ) <= std::fabs( b ) )
        -: 8330:                                 ? -ag - ( s - bg )
        -: 8331:                                 : bg - ( s + ag );
        -: 8332:            const auto ceil_s = static_cast<DistanceType<FloatType>>( std::ceil( s ) );
        -: 8333:
        -: 8334:            return ( ceil_s != s ) ? ceil_s : ceil_s + ( err > 0 );
        -: 8335:        }
        -: 8336:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 8337:#    pragma GCC diagnostic pop
        -: 8338:#endif
        -: 8339:
        -: 8340:    }
        -: 8341:
        -: 8342:} // end namespace Catch
        -: 8343:
        -: 8344:#endif // CATCH_RANDOM_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 8345:
        -: 8346:#include <cmath>
        -: 8347:#include <type_traits>
        -: 8348:
        -: 8349:namespace Catch {
        -: 8350:
        -: 8351:    namespace Detail {
        -: 8352:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 8353:#    pragma GCC diagnostic push
        -: 8354:#    pragma GCC diagnostic ignored "-Wfloat-equal"
        -: 8355:#endif
        -: 8356:        // The issue with overflow only happens with maximal ULP and HUGE
        -: 8357:        // distance, e.g. when generating numbers in [-inf, inf] for given
        -: 8358:        // type. So we only check for the largest possible ULP in the
        -: 8359:        // type, and return something that does not overflow to inf in 1 mult.
        -: 8360:        constexpr std::uint64_t calculate_max_steps_in_one_go(double gamma) {
        -: 8361:            if ( gamma == 1.99584030953472e+292 ) { return 9007199254740991; }
        -: 8362:            return static_cast<std::uint64_t>( -1 );
        -: 8363:        }
        -: 8364:        constexpr std::uint32_t calculate_max_steps_in_one_go(float gamma) {
        -: 8365:            if ( gamma == 2.028241e+31f ) { return 16777215; }
        -: 8366:            return static_cast<std::uint32_t>( -1 );
        -: 8367:        }
        -: 8368:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 8369:#    pragma GCC diagnostic pop
        -: 8370:#endif
        -: 8371:    }
        -: 8372:
        -: 8373:/**
        -: 8374: * Implementation of uniform distribution on floating point numbers.
        -: 8375: *
        -: 8376: * Note that we support only `float` and `double` types, because these
        -: 8377: * usually mean the same thing across different platform. `long double`
        -: 8378: * varies wildly by platform and thus we cannot provide reproducible
        -: 8379: * implementation. Also note that we don't implement all parts of
        -: 8380: * distribution per standard: this distribution is not serializable, nor
        -: 8381: * can the range be arbitrarily reset.
        -: 8382: *
        -: 8383: * The implementation also uses different approach than the one taken by
        -: 8384: * `std::uniform_real_distribution`, where instead of generating a number
        -: 8385: * between [0, 1) and then multiplying the range bounds with it, we first
        -: 8386: * split the [a, b] range into a set of equidistributed floating point
        -: 8387: * numbers, and then use uniform int distribution to pick which one to
        -: 8388: * return.
        -: 8389: *
        -: 8390: * This has the advantage of guaranteeing uniformity (the multiplication
        -: 8391: * method loses uniformity due to rounding when multiplying floats), except
        -: 8392: * for small non-uniformity at one side of the interval, where we have
        -: 8393: * to deal with the fact that not every interval is splittable into
        -: 8394: * equidistributed floats.
        -: 8395: *
        -: 8396: * Based on "Drawing random floating-point numbers from an interval" by
        -: 8397: * Frederic Goualard.
        -: 8398: */
        -: 8399:template <typename FloatType>
        -: 8400:class uniform_floating_point_distribution {
        -: 8401:    static_assert(std::is_floating_point<FloatType>::value, "...");
        -: 8402:    static_assert(!std::is_same<FloatType, long double>::value,
        -: 8403:                  "We do not support long double due to inconsistent behaviour between platforms");
        -: 8404:
        -: 8405:    using WidthType = Detail::DistanceType<FloatType>;
        -: 8406:
        -: 8407:    FloatType m_a, m_b;
        -: 8408:    FloatType m_ulp_magnitude;
        -: 8409:    WidthType m_floats_in_range;
        -: 8410:    uniform_integer_distribution<WidthType> m_int_dist;
        -: 8411:
        -: 8412:    // In specific cases, we can overflow into `inf` when computing the
        -: 8413:    // `steps * g` offset. To avoid this, we don't offset by more than this
        -: 8414:    // in one multiply + addition.
        -: 8415:    WidthType m_max_steps_in_one_go;
        -: 8416:    // We don't want to do the magnitude check every call to `operator()`
        -: 8417:    bool m_a_has_leq_magnitude;
        -: 8418:
        -: 8419:public:
        -: 8420:    using result_type = FloatType;
        -: 8421:
        -: 8422:    uniform_floating_point_distribution( FloatType a, FloatType b ):
        -: 8423:        m_a( a ),
        -: 8424:        m_b( b ),
        -: 8425:        m_ulp_magnitude( Detail::gamma( m_a, m_b ) ),
        -: 8426:        m_floats_in_range( Detail::count_equidistant_floats( m_a, m_b, m_ulp_magnitude ) ),
        -: 8427:        m_int_dist(0, m_floats_in_range),
        -: 8428:        m_max_steps_in_one_go( Detail::calculate_max_steps_in_one_go(m_ulp_magnitude)),
        -: 8429:        m_a_has_leq_magnitude(std::fabs(m_a) <= std::fabs(m_b))
        -: 8430:    {
        -: 8431:        assert( a <= b );
        -: 8432:    }
        -: 8433:
        -: 8434:    template <typename Generator>
        -: 8435:    result_type operator()( Generator& g ) {
        -: 8436:        WidthType steps = m_int_dist( g );
        -: 8437:        if ( m_a_has_leq_magnitude ) {
        -: 8438:            if ( steps == m_floats_in_range ) { return m_a; }
        -: 8439:            auto b = m_b;
        -: 8440:            while (steps > m_max_steps_in_one_go) {
        -: 8441:                b -= m_max_steps_in_one_go * m_ulp_magnitude;
        -: 8442:                steps -= m_max_steps_in_one_go;
        -: 8443:            }
        -: 8444:            return b - steps * m_ulp_magnitude;
        -: 8445:        } else {
        -: 8446:            if ( steps == m_floats_in_range ) { return m_b; }
        -: 8447:            auto a = m_a;
        -: 8448:            while (steps > m_max_steps_in_one_go) {
        -: 8449:                a += m_max_steps_in_one_go * m_ulp_magnitude;
        -: 8450:                steps -= m_max_steps_in_one_go;
        -: 8451:            }
        -: 8452:            return a + steps * m_ulp_magnitude;
        -: 8453:        }
        -: 8454:    }
        -: 8455:
        -: 8456:    result_type a() const { return m_a; }
        -: 8457:    result_type b() const { return m_b; }
        -: 8458:};
        -: 8459:
        -: 8460:} // end namespace Catch
        -: 8461:
        -: 8462:#endif // CATCH_UNIFORM_FLOATING_POINT_DISTRIBUTION_HPP_INCLUDED
        -: 8463:
        -: 8464:namespace Catch {
        -: 8465:namespace Generators {
        -: 8466:namespace Detail {
        -: 8467:    // Returns a suitable seed for a random floating generator based off
        -: 8468:    // the primary internal rng. It does so by taking current value from
        -: 8469:    // the rng and returning it as the seed.
        -: 8470:    std::uint32_t getSeed();
        -: 8471:}
        -: 8472:
        -: 8473:template <typename Float>
        -: 8474:class RandomFloatingGenerator final : public IGenerator<Float> {
        -: 8475:    Catch::SimplePcg32 m_rng;
        -: 8476:    Catch::uniform_floating_point_distribution<Float> m_dist;
        -: 8477:    Float m_current_number;
        -: 8478:public:
        -: 8479:    RandomFloatingGenerator( Float a, Float b, std::uint32_t seed ):
        -: 8480:        m_rng(seed),
        -: 8481:        m_dist(a, b) {
        -: 8482:        static_cast<void>(next());
        -: 8483:    }
        -: 8484:
        -: 8485:    Float const& get() const override {
        -: 8486:        return m_current_number;
        -: 8487:    }
        -: 8488:    bool next() override {
        -: 8489:        m_current_number = m_dist(m_rng);
        -: 8490:        return true;
        -: 8491:    }
        -: 8492:};
        -: 8493:
        -: 8494:template <>
        -: 8495:class RandomFloatingGenerator<long double> final : public IGenerator<long double> {
        -: 8496:    // We still rely on <random> for this specialization, but we don't
        -: 8497:    // want to drag it into the header.
        -: 8498:    struct PImpl;
        -: 8499:    Catch::Detail::unique_ptr<PImpl> m_pimpl;
        -: 8500:    long double m_current_number;
        -: 8501:
        -: 8502:public:
        -: 8503:    RandomFloatingGenerator( long double a, long double b, std::uint32_t seed );
        -: 8504:
        -: 8505:    long double const& get() const override { return m_current_number; }
        -: 8506:    bool next() override;
        -: 8507:
        -: 8508:    ~RandomFloatingGenerator() override; // = default
        -: 8509:};
        -: 8510:
        -: 8511:template <typename Integer>
        -: 8512:class RandomIntegerGenerator final : public IGenerator<Integer> {
        -: 8513:    Catch::SimplePcg32 m_rng;
        -: 8514:    Catch::uniform_integer_distribution<Integer> m_dist;
        -: 8515:    Integer m_current_number;
        -: 8516:public:
        -: 8517:    RandomIntegerGenerator( Integer a, Integer b, std::uint32_t seed ):
        -: 8518:        m_rng(seed),
        -: 8519:        m_dist(a, b) {
        -: 8520:        static_cast<void>(next());
        -: 8521:    }
        -: 8522:
        -: 8523:    Integer const& get() const override {
        -: 8524:        return m_current_number;
        -: 8525:    }
        -: 8526:    bool next() override {
        -: 8527:        m_current_number = m_dist(m_rng);
        -: 8528:        return true;
        -: 8529:    }
        -: 8530:};
        -: 8531:
        -: 8532:template <typename T>
        -: 8533:std::enable_if_t<std::is_integral<T>::value, GeneratorWrapper<T>>
        -: 8534:random(T a, T b) {
        -: 8535:    return GeneratorWrapper<T>(
        -: 8536:        Catch::Detail::make_unique<RandomIntegerGenerator<T>>(a, b, Detail::getSeed())
        -: 8537:    );
        -: 8538:}
        -: 8539:
        -: 8540:template <typename T>
        -: 8541:std::enable_if_t<std::is_floating_point<T>::value,
        -: 8542:GeneratorWrapper<T>>
        -: 8543:random(T a, T b) {
        -: 8544:    return GeneratorWrapper<T>(
        -: 8545:        Catch::Detail::make_unique<RandomFloatingGenerator<T>>(a, b, Detail::getSeed())
        -: 8546:    );
        -: 8547:}
        -: 8548:
        -: 8549:
        -: 8550:} // namespace Generators
        -: 8551:} // namespace Catch
        -: 8552:
        -: 8553:
        -: 8554:#endif // CATCH_GENERATORS_RANDOM_HPP_INCLUDED
        -: 8555:
        -: 8556:
        -: 8557:#ifndef CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 8558:#define CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 8559:
        -: 8560:
        -: 8561:#include <iterator>
        -: 8562:#include <type_traits>
        -: 8563:
        -: 8564:namespace Catch {
        -: 8565:namespace Generators {
        -: 8566:
        -: 8567:
        -: 8568:template <typename T>
        -: 8569:class RangeGenerator final : public IGenerator<T> {
        -: 8570:    T m_current;
        -: 8571:    T m_end;
        -: 8572:    T m_step;
        -: 8573:    bool m_positive;
        -: 8574:
        -: 8575:public:
        -: 8576:    RangeGenerator(T const& start, T const& end, T const& step):
        -: 8577:        m_current(start),
        -: 8578:        m_end(end),
        -: 8579:        m_step(step),
        -: 8580:        m_positive(m_step > T(0))
        -: 8581:    {
        -: 8582:        assert(m_current != m_end && "Range start and end cannot be equal");
        -: 8583:        assert(m_step != T(0) && "Step size cannot be zero");
        -: 8584:        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
        -: 8585:    }
        -: 8586:
        -: 8587:    RangeGenerator(T const& start, T const& end):
        -: 8588:        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
        -: 8589:    {}
        -: 8590:
        -: 8591:    T const& get() const override {
        -: 8592:        return m_current;
        -: 8593:    }
        -: 8594:
        -: 8595:    bool next() override {
        -: 8596:        m_current += m_step;
        -: 8597:        return (m_positive) ? (m_current < m_end) : (m_current > m_end);
        -: 8598:    }
        -: 8599:};
        -: 8600:
        -: 8601:template <typename T>
        -: 8602:GeneratorWrapper<T> range(T const& start, T const& end, T const& step) {
        -: 8603:    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
        -: 8604:    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end, step));
        -: 8605:}
        -: 8606:
        -: 8607:template <typename T>
        -: 8608:GeneratorWrapper<T> range(T const& start, T const& end) {
        -: 8609:    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
        -: 8610:    return GeneratorWrapper<T>(Catch::Detail::make_unique<RangeGenerator<T>>(start, end));
        -: 8611:}
        -: 8612:
        -: 8613:
        -: 8614:template <typename T>
        -: 8615:class IteratorGenerator final : public IGenerator<T> {
        -: 8616:    static_assert(!std::is_same<T, bool>::value,
        -: 8617:        "IteratorGenerator currently does not support bools"
        -: 8618:        "because of std::vector<bool> specialization");
        -: 8619:
        -: 8620:    std::vector<T> m_elems;
        -: 8621:    size_t m_current = 0;
        -: 8622:public:
        -: 8623:    template <typename InputIterator, typename InputSentinel>
        -: 8624:    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
        -: 8625:        if (m_elems.empty()) {
        -: 8626:            Detail::throw_generator_exception("IteratorGenerator received no valid values");
        -: 8627:        }
        -: 8628:    }
        -: 8629:
        -: 8630:    T const& get() const override {
        -: 8631:        return m_elems[m_current];
        -: 8632:    }
        -: 8633:
        -: 8634:    bool next() override {
        -: 8635:        ++m_current;
        -: 8636:        return m_current != m_elems.size();
        -: 8637:    }
        -: 8638:};
        -: 8639:
        -: 8640:template <typename InputIterator,
        -: 8641:          typename InputSentinel,
        -: 8642:          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
        -: 8643:GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) {
        -: 8644:    return GeneratorWrapper<ResultType>(Catch::Detail::make_unique<IteratorGenerator<ResultType>>(from, to));
        -: 8645:}
        -: 8646:
        -: 8647:template <typename Container>
        -: 8648:auto from_range(Container const& cnt) {
        -: 8649:    using std::begin;
        -: 8650:    using std::end;
        -: 8651:    return from_range( begin( cnt ), end( cnt ) );
        -: 8652:}
        -: 8653:
        -: 8654:
        -: 8655:} // namespace Generators
        -: 8656:} // namespace Catch
        -: 8657:
        -: 8658:
        -: 8659:#endif // CATCH_GENERATORS_RANGE_HPP_INCLUDED
        -: 8660:
        -: 8661:#endif // CATCH_GENERATORS_ALL_HPP_INCLUDED
        -: 8662:
        -: 8663:
        -: 8664:/** \file
        -: 8665: * This is a convenience header for Catch2's interfaces. It includes
        -: 8666: * **all** of Catch2 headers related to interfaces.
        -: 8667: *
        -: 8668: * Generally the Catch2 users should use specific includes they need,
        -: 8669: * but this header can be used instead for ease-of-experimentation, or
        -: 8670: * just plain convenience, at the cost of somewhat increased compilation
        -: 8671: * times.
        -: 8672: *
        -: 8673: * When a new header is added to either the `interfaces` folder, or to
        -: 8674: * the corresponding internal subfolder, it should be added here.
        -: 8675: */
        -: 8676:
        -: 8677:
        -: 8678:#ifndef CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 8679:#define CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 8680:
        -: 8681:
        -: 8682:
        -: 8683:#ifndef CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -: 8684:#define CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -: 8685:
        -: 8686:
        -: 8687:
        -: 8688:#ifndef CATCH_TEST_RUN_INFO_HPP_INCLUDED
        -: 8689:#define CATCH_TEST_RUN_INFO_HPP_INCLUDED
        -: 8690:
        -: 8691:
        -: 8692:namespace Catch {
        -: 8693:
        -: 8694:    struct TestRunInfo {
        -: 8695:        constexpr TestRunInfo(StringRef _name) : name(_name) {}
        -: 8696:        StringRef name;
        -: 8697:    };
        -: 8698:
        -: 8699:} // end namespace Catch
        -: 8700:
        -: 8701:#endif // CATCH_TEST_RUN_INFO_HPP_INCLUDED
        -: 8702:
        -: 8703:#include <map>
        -: 8704:#include <string>
        -: 8705:#include <vector>
        -: 8706:#include <iosfwd>
        -: 8707:
        -: 8708:namespace Catch {
        -: 8709:
        -: 8710:    struct ReporterDescription;
        -: 8711:    struct ListenerDescription;
        -: 8712:    struct TagInfo;
        -: 8713:    struct TestCaseInfo;
        -: 8714:    class TestCaseHandle;
        -: 8715:    class IConfig;
        -: 8716:    class IStream;
        -: 8717:    enum class ColourMode : std::uint8_t;
        -: 8718:
        -: 8719:    struct ReporterConfig {
        -: 8720:        ReporterConfig( IConfig const* _fullConfig,
        -: 8721:                        Detail::unique_ptr<IStream> _stream,
        -: 8722:                        ColourMode colourMode,
        -: 8723:                        std::map<std::string, std::string> customOptions );
        -: 8724:
        -: 8725:        ReporterConfig( ReporterConfig&& ) = default;
        -: 8726:        ReporterConfig& operator=( ReporterConfig&& ) = default;
        -: 8727:        ~ReporterConfig(); // = default
        -: 8728:
        -: 8729:        Detail::unique_ptr<IStream> takeStream() &&;
        -: 8730:        IConfig const* fullConfig() const;
        -: 8731:        ColourMode colourMode() const;
        -: 8732:        std::map<std::string, std::string> const& customOptions() const;
        -: 8733:
        -: 8734:    private:
        -: 8735:        Detail::unique_ptr<IStream> m_stream;
        -: 8736:        IConfig const* m_fullConfig;
        -: 8737:        ColourMode m_colourMode;
        -: 8738:        std::map<std::string, std::string> m_customOptions;
        -: 8739:    };
        -: 8740:
        -: 8741:    struct AssertionStats {
        -: 8742:        AssertionStats( AssertionResult const& _assertionResult,
        -: 8743:                        std::vector<MessageInfo> const& _infoMessages,
        -: 8744:                        Totals const& _totals );
        -: 8745:
        -: 8746:        AssertionStats( AssertionStats const& )              = default;
        -: 8747:        AssertionStats( AssertionStats && )                  = default;
        -: 8748:        AssertionStats& operator = ( AssertionStats const& ) = delete;
        -: 8749:        AssertionStats& operator = ( AssertionStats && )     = delete;
        -: 8750:
        -: 8751:        AssertionResult assertionResult;
        -: 8752:        std::vector<MessageInfo> infoMessages;
        -: 8753:        Totals totals;
        -: 8754:    };
        -: 8755:
        -: 8756:    struct SectionStats {
        -: 8757:        SectionStats(   SectionInfo&& _sectionInfo,
        -: 8758:                        Counts const& _assertions,
        -: 8759:                        double _durationInSeconds,
        -: 8760:                        bool _missingAssertions );
        -: 8761:
        -: 8762:        SectionInfo sectionInfo;
        -: 8763:        Counts assertions;
        -: 8764:        double durationInSeconds;
        -: 8765:        bool missingAssertions;
        -: 8766:    };
        -: 8767:
        -: 8768:    struct TestCaseStats {
        -: 8769:        TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 8770:                        Totals const& _totals,
        -: 8771:                        std::string&& _stdOut,
        -: 8772:                        std::string&& _stdErr,
        -: 8773:                        bool _aborting );
        -: 8774:
        -: 8775:        TestCaseInfo const * testInfo;
        -: 8776:        Totals totals;
        -: 8777:        std::string stdOut;
        -: 8778:        std::string stdErr;
        -: 8779:        bool aborting;
        -: 8780:    };
        -: 8781:
        -: 8782:    struct TestRunStats {
        -: 8783:        TestRunStats(   TestRunInfo const& _runInfo,
        -: 8784:                        Totals const& _totals,
        -: 8785:                        bool _aborting );
        -: 8786:
        -: 8787:        TestRunInfo runInfo;
        -: 8788:        Totals totals;
        -: 8789:        bool aborting;
        -: 8790:    };
        -: 8791:
        -: 8792:    //! By setting up its preferences, a reporter can modify Catch2's behaviour
        -: 8793:    //! in some regards, e.g. it can request Catch2 to capture writes to
        -: 8794:    //! stdout/stderr during test execution, and pass them to the reporter.
        -: 8795:    struct ReporterPreferences {
        -: 8796:        //! Catch2 should redirect writes to stdout and pass them to the
        -: 8797:        //! reporter
        -: 8798:        bool shouldRedirectStdOut = false;
        -: 8799:        //! Catch2 should call `Reporter::assertionEnded` even for passing
        -: 8800:        //! assertions
        -: 8801:        bool shouldReportAllAssertions = false;
        -: 8802:    };
        -: 8803:
        -: 8804:    /**
        -: 8805:     * The common base for all reporters and event listeners
        -: 8806:     *
        -: 8807:     * Implementing classes must also implement:
        -: 8808:     *
        -: 8809:     *     //! User-friendly description of the reporter/listener type
        -: 8810:     *     static std::string getDescription()
        -: 8811:     *
        -: 8812:     * Generally shouldn't be derived from by users of Catch2 directly,
        -: 8813:     * instead they should derive from one of the utility bases that
        -: 8814:     * derive from this class.
        -: 8815:     */
        -: 8816:    class IEventListener {
        -: 8817:    protected:
        -: 8818:        //! Derived classes can set up their preferences here
        -: 8819:        ReporterPreferences m_preferences;
        -: 8820:        //! The test run's config as filled in from CLI and defaults
        -: 8821:        IConfig const* m_config;
        -: 8822:
        -: 8823:    public:
        -: 8824:        IEventListener( IConfig const* config ): m_config( config ) {}
        -: 8825:
        -: 8826:        virtual ~IEventListener(); // = default;
        -: 8827:
        -: 8828:        // Implementing class must also provide the following static methods:
        -: 8829:        // static std::string getDescription();
        -: 8830:
        -: 8831:        ReporterPreferences const& getPreferences() const {
        -: 8832:            return m_preferences;
        -: 8833:        }
        -: 8834:
        -: 8835:        //! Called when no test cases match provided test spec
        -: 8836:        virtual void noMatchingTestCases( StringRef unmatchedSpec ) = 0;
        -: 8837:        //! Called for all invalid test specs from the cli
        -: 8838:        virtual void reportInvalidTestSpec( StringRef invalidArgument ) = 0;
        -: 8839:
        -: 8840:        /**
        -: 8841:         * Called once in a testing run before tests are started
        -: 8842:         *
        -: 8843:         * Not called if tests won't be run (e.g. only listing will happen)
        -: 8844:         */
        -: 8845:        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        -: 8846:
        -: 8847:        //! Called _once_ for each TEST_CASE, no matter how many times it is entered
        -: 8848:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        -: 8849:        //! Called _every time_ a TEST_CASE is entered, including repeats (due to sections)
        -: 8850:        virtual void testCasePartialStarting( TestCaseInfo const& testInfo, uint64_t partNumber ) = 0;
        -: 8851:        //! Called when a `SECTION` is being entered. Not called for skipped sections
        -: 8852:        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
        -: 8853:
        -: 8854:        //! Called when user-code is being probed before the actual benchmark runs
        -: 8855:        virtual void benchmarkPreparing( StringRef benchmarkName ) = 0;
        -: 8856:        //! Called after probe but before the user-code is being benchmarked
        -: 8857:        virtual void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) = 0;
        -: 8858:        //! Called with the benchmark results if benchmark successfully finishes
        -: 8859:        virtual void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) = 0;
        -: 8860:        //! Called if running the benchmarks fails for any reason
        -: 8861:        virtual void benchmarkFailed( StringRef benchmarkName ) = 0;
        -: 8862:
        -: 8863:        //! Called before assertion success/failure is evaluated
        -: 8864:        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
        -: 8865:
        -: 8866:        //! Called after assertion was fully evaluated
        -: 8867:        virtual void assertionEnded( AssertionStats const& assertionStats ) = 0;
        -: 8868:
        -: 8869:        //! Called after a `SECTION` has finished running
        -: 8870:        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        -: 8871:        //! Called _every time_ a TEST_CASE is entered, including repeats (due to sections)
        -: 8872:        virtual void testCasePartialEnded(TestCaseStats const& testCaseStats, uint64_t partNumber ) = 0;
        -: 8873:        //! Called _once_ for each TEST_CASE, no matter how many times it is entered
        -: 8874:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        -: 8875:        /**
        -: 8876:         * Called once after all tests in a testing run are finished
        -: 8877:         *
        -: 8878:         * Not called if tests weren't run (e.g. only listings happened)
        -: 8879:         */
        -: 8880:        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
        -: 8881:
        -: 8882:        /**
        -: 8883:         * Called with test cases that are skipped due to the test run aborting.
        -: 8884:         * NOT called for test cases that are explicitly skipped using the `SKIP` macro.
        -: 8885:         *
        -: 8886:         * Deprecated - will be removed in the next major release.
        -: 8887:         */
        -: 8888:        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
        -: 8889:
        -: 8890:        //! Called if a fatal error (signal/structured exception) occurred
        -: 8891:        virtual void fatalErrorEncountered( StringRef error ) = 0;
        -: 8892:
        -: 8893:        //! Writes out information about provided reporters using reporter-specific format
        -: 8894:        virtual void listReporters(std::vector<ReporterDescription> const& descriptions) = 0;
        -: 8895:        //! Writes out the provided listeners descriptions using reporter-specific format
        -: 8896:        virtual void listListeners(std::vector<ListenerDescription> const& descriptions) = 0;
        -: 8897:        //! Writes out information about provided tests using reporter-specific format
        -: 8898:        virtual void listTests(std::vector<TestCaseHandle> const& tests) = 0;
        -: 8899:        //! Writes out information about the provided tags using reporter-specific format
        -: 8900:        virtual void listTags(std::vector<TagInfo> const& tags) = 0;
        -: 8901:    };
        -: 8902:    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;
        -: 8903:
        -: 8904:} // end namespace Catch
        -: 8905:
        -: 8906:#endif // CATCH_INTERFACES_REPORTER_HPP_INCLUDED
        -: 8907:
        -: 8908:
        -: 8909:#ifndef CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 8910:#define CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 8911:
        -: 8912:
        -: 8913:#include <string>
        -: 8914:
        -: 8915:namespace Catch {
        -: 8916:
        -: 8917:    struct ReporterConfig;
        -: 8918:    class IConfig;
        -: 8919:    class IEventListener;
        -: 8920:    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;
        -: 8921:
        -: 8922:
        -: 8923:    class IReporterFactory {
        -: 8924:    public:
        -: 8925:        virtual ~IReporterFactory(); // = default
        -: 8926:
        -: 8927:        virtual IEventListenerPtr
        -: 8928:        create( ReporterConfig&& config ) const = 0;
        -: 8929:        virtual std::string getDescription() const = 0;
        -: 8930:    };
        -: 8931:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -: 8932:
        -: 8933:    class EventListenerFactory {
        -: 8934:    public:
        -: 8935:        virtual ~EventListenerFactory(); // = default
        -: 8936:        virtual IEventListenerPtr create( IConfig const* config ) const = 0;
        -: 8937:        //! Return a meaningful name for the listener, e.g. its type name
        -: 8938:        virtual StringRef getName() const = 0;
        -: 8939:        //! Return listener's description if available
        -: 8940:        virtual std::string getDescription() const = 0;
        -: 8941:    };
        -: 8942:} // namespace Catch
        -: 8943:
        -: 8944:#endif // CATCH_INTERFACES_REPORTER_FACTORY_HPP_INCLUDED
        -: 8945:
        -: 8946:
        -: 8947:#ifndef CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8948:#define CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8949:
        -: 8950:#include <string>
        -: 8951:
        -: 8952:namespace Catch {
        -: 8953:
        -: 8954:    struct TagAlias;
        -: 8955:
        -: 8956:    class ITagAliasRegistry {
        -: 8957:    public:
        -: 8958:        virtual ~ITagAliasRegistry(); // = default
        -: 8959:        // Nullptr if not present
        -: 8960:        virtual TagAlias const* find( std::string const& alias ) const = 0;
        -: 8961:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
        -: 8962:
        -: 8963:        static ITagAliasRegistry const& get();
        -: 8964:    };
        -: 8965:
        -: 8966:} // end namespace Catch
        -: 8967:
        -: 8968:#endif // CATCH_INTERFACES_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 8969:
        -: 8970:
        -: 8971:#ifndef CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 8972:#define CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 8973:
        -: 8974:#include <vector>
        -: 8975:
        -: 8976:namespace Catch {
        -: 8977:
        -: 8978:    struct TestCaseInfo;
        -: 8979:    class TestCaseHandle;
        -: 8980:    class IConfig;
        -: 8981:
        -: 8982:    class ITestCaseRegistry {
        -: 8983:    public:
        -: 8984:        virtual ~ITestCaseRegistry(); // = default
        -: 8985:        // TODO: this exists only for adding filenames to test cases -- let's expose this in a saner way later
        -: 8986:        virtual std::vector<TestCaseInfo* > const& getAllInfos() const = 0;
        -: 8987:        virtual std::vector<TestCaseHandle> const& getAllTests() const = 0;
        -: 8988:        virtual std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const = 0;
        -: 8989:    };
        -: 8990:
        -: 8991:}
        -: 8992:
        -: 8993:#endif // CATCH_INTERFACES_TESTCASE_HPP_INCLUDED
        -: 8994:
        -: 8995:#endif // CATCH_INTERFACES_ALL_HPP_INCLUDED
        -: 8996:
        -: 8997:
        -: 8998:#ifndef CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED
        -: 8999:#define CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED
        -: 9000:
        -: 9001:
        -: 9002:namespace Catch {
        -: 9003:    namespace Detail {
        -: 9004:        //! Provides case-insensitive `op<` semantics when called
        -: 9005:        struct CaseInsensitiveLess {
        -: 9006:            bool operator()( StringRef lhs,
        -: 9007:                             StringRef rhs ) const;
        -: 9008:        };
        -: 9009:
        -: 9010:        //! Provides case-insensitive `op==` semantics when called
        -: 9011:        struct CaseInsensitiveEqualTo {
        -: 9012:            bool operator()( StringRef lhs,
        -: 9013:                             StringRef rhs ) const;
        -: 9014:        };
        -: 9015:
        -: 9016:    } // namespace Detail
        -: 9017:} // namespace Catch
        -: 9018:
        -: 9019:#endif // CATCH_CASE_INSENSITIVE_COMPARISONS_HPP_INCLUDED
        -: 9020:
        -: 9021:
        -: 9022:
        -: 9023:/** \file
        -: 9024: * Wrapper for ANDROID_LOGWRITE configuration option
        -: 9025: *
        -: 9026: * We want to default to enabling it when compiled for android, but
        -: 9027: * users of the library should also be able to disable it if they want
        -: 9028: * to.
        -: 9029: */
        -: 9030:
        -: 9031:#ifndef CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED
        -: 9032:#define CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED
        -: 9033:
        -: 9034:
        -: 9035:#if defined(__ANDROID__)
        -: 9036:#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
        -: 9037:#endif
        -: 9038:
        -: 9039:
        -: 9040:#if defined( CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE ) && \
        -: 9041:    !defined( CATCH_CONFIG_NO_ANDROID_LOGWRITE ) &&      \
        -: 9042:    !defined( CATCH_CONFIG_ANDROID_LOGWRITE )
        -: 9043:#    define CATCH_CONFIG_ANDROID_LOGWRITE
        -: 9044:#endif
        -: 9045:
        -: 9046:#endif // CATCH_CONFIG_ANDROID_LOGWRITE_HPP_INCLUDED
        -: 9047:
        -: 9048:
        -: 9049:
        -: 9050:/** \file
        -: 9051: * Wrapper for UNCAUGHT_EXCEPTIONS configuration option
        -: 9052: *
        -: 9053: * For some functionality, Catch2 requires to know whether there is
        -: 9054: * an active exception. Because `std::uncaught_exception` is deprecated
        -: 9055: * in C++17, we want to use `std::uncaught_exceptions` if possible.
        -: 9056: */
        -: 9057:
        -: 9058:#ifndef CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 9059:#define CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 9060:
        -: 9061:
        -: 9062:#if defined(_MSC_VER)
        -: 9063:#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
        -: 9064:#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 9065:#  endif
        -: 9066:#endif
        -: 9067:
        -: 9068:
        -: 9069:#include <exception>
        -: 9070:
        -: 9071:#if defined(__cpp_lib_uncaught_exceptions) \
        -: 9072:    && !defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -: 9073:
        -: 9074:#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 9075:#endif // __cpp_lib_uncaught_exceptions
        -: 9076:
        -: 9077:
        -: 9078:#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) \
        -: 9079:    && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) \
        -: 9080:    && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
        -: 9081:
        -: 9082:#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
        -: 9083:#endif
        -: 9084:
        -: 9085:
        -: 9086:#endif // CATCH_CONFIG_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -: 9087:
        -: 9088:
        -: 9089:#ifndef CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 9090:#define CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 9091:
        -: 9092:
        -: 9093:#include <iosfwd>
        -: 9094:#include <cstdint>
        -: 9095:
        -: 9096:namespace Catch {
        -: 9097:
        -: 9098:    enum class ColourMode : std::uint8_t;
        -: 9099:    class IStream;
        -: 9100:
        -: 9101:    struct Colour {
        -: 9102:        enum Code {
        -: 9103:            None = 0,
        -: 9104:
        -: 9105:            White,
        -: 9106:            Red,
        -: 9107:            Green,
        -: 9108:            Blue,
        -: 9109:            Cyan,
        -: 9110:            Yellow,
        -: 9111:            Grey,
        -: 9112:
        -: 9113:            Bright = 0x10,
        -: 9114:
        -: 9115:            BrightRed = Bright | Red,
        -: 9116:            BrightGreen = Bright | Green,
        -: 9117:            LightGrey = Bright | Grey,
        -: 9118:            BrightWhite = Bright | White,
        -: 9119:            BrightYellow = Bright | Yellow,
        -: 9120:
        -: 9121:            // By intention
        -: 9122:            FileName = LightGrey,
        -: 9123:            Warning = BrightYellow,
        -: 9124:            ResultError = BrightRed,
        -: 9125:            ResultSuccess = BrightGreen,
        -: 9126:            ResultExpectedFailure = Warning,
        -: 9127:
        -: 9128:            Error = BrightRed,
        -: 9129:            Success = Green,
        -: 9130:            Skip = LightGrey,
        -: 9131:
        -: 9132:            OriginalExpression = Cyan,
        -: 9133:            ReconstructedExpression = BrightYellow,
        -: 9134:
        -: 9135:            SecondaryText = LightGrey,
        -: 9136:            Headers = White
        -: 9137:        };
        -: 9138:    };
        -: 9139:
        -: 9140:    class ColourImpl {
        -: 9141:    protected:
        -: 9142:        //! The associated stream of this ColourImpl instance
        -: 9143:        IStream* m_stream;
        -: 9144:    public:
        -: 9145:        ColourImpl( IStream* stream ): m_stream( stream ) {}
        -: 9146:
        -: 9147:        //! RAII wrapper around writing specific colour of text using specific
        -: 9148:        //! colour impl into a stream.
        -: 9149:        class ColourGuard {
        -: 9150:            ColourImpl const* m_colourImpl;
        -: 9151:            Colour::Code m_code;
        -: 9152:            bool m_engaged = false;
        -: 9153:
        -: 9154:        public:
        -: 9155:            //! Does **not** engage the guard/start the colour
        -: 9156:            ColourGuard( Colour::Code code,
        -: 9157:                         ColourImpl const* colour );
        -: 9158:
        -: 9159:            ColourGuard( ColourGuard const& rhs ) = delete;
        -: 9160:            ColourGuard& operator=( ColourGuard const& rhs ) = delete;
        -: 9161:
        -: 9162:            ColourGuard( ColourGuard&& rhs ) noexcept;
        -: 9163:            ColourGuard& operator=( ColourGuard&& rhs ) noexcept;
        -: 9164:
        -: 9165:            //! Removes colour _if_ the guard was engaged
        -: 9166:            ~ColourGuard();
        -: 9167:
        -: 9168:            /**
        -: 9169:             * Explicitly engages colour for given stream.
        -: 9170:             *
        -: 9171:             * The API based on operator<< should be preferred.
        -: 9172:             */
        -: 9173:            ColourGuard& engage( std::ostream& stream ) &;
        -: 9174:            /**
        -: 9175:             * Explicitly engages colour for given stream.
        -: 9176:             *
        -: 9177:             * The API based on operator<< should be preferred.
        -: 9178:             */
        -: 9179:            ColourGuard&& engage( std::ostream& stream ) &&;
        -: 9180:
        -: 9181:        private:
        -: 9182:            //! Engages the guard and starts using colour
        -: 9183:            friend std::ostream& operator<<( std::ostream& lhs,
        -: 9184:                                             ColourGuard& guard ) {
        -: 9185:                guard.engageImpl( lhs );
        -: 9186:                return lhs;
        -: 9187:            }
        -: 9188:            //! Engages the guard and starts using colour
        -: 9189:            friend std::ostream& operator<<( std::ostream& lhs,
        -: 9190:                                            ColourGuard&& guard) {
        -: 9191:                guard.engageImpl( lhs );
        -: 9192:                return lhs;
        -: 9193:            }
        -: 9194:
        -: 9195:            void engageImpl( std::ostream& stream );
        -: 9196:
        -: 9197:        };
        -: 9198:
        -: 9199:        virtual ~ColourImpl(); // = default
        -: 9200:        /**
        -: 9201:         * Creates a guard object for given colour and this colour impl
        -: 9202:         *
        -: 9203:         * **Important:**
        -: 9204:         * the guard starts disengaged, and has to be engaged explicitly.
        -: 9205:         */
        -: 9206:        ColourGuard guardColour( Colour::Code colourCode );
        -: 9207:
        -: 9208:    private:
        -: 9209:        virtual void use( Colour::Code colourCode ) const = 0;
        -: 9210:    };
        -: 9211:
        -: 9212:    //! Provides ColourImpl based on global config and target compilation platform
        -: 9213:    Detail::unique_ptr<ColourImpl> makeColourImpl( ColourMode colourSelection,
        -: 9214:                                                   IStream* stream );
        -: 9215:
        -: 9216:    //! Checks if specific colour impl has been compiled into the binary
        -: 9217:    bool isColourImplAvailable( ColourMode colourSelection );
        -: 9218:
        -: 9219:} // end namespace Catch
        -: 9220:
        -: 9221:#endif // CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 9222:
        -: 9223:
        -: 9224:#ifndef CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 9225:#define CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 9226:
        -: 9227:// This include must be kept so that user's configured value for CONSOLE_WIDTH
        -: 9228:// is used before we attempt to provide a default value
        -: 9229:
        -: 9230:#ifndef CATCH_CONFIG_CONSOLE_WIDTH
        -: 9231:#define CATCH_CONFIG_CONSOLE_WIDTH 80
        -: 9232:#endif
        -: 9233:
        -: 9234:#endif // CATCH_CONSOLE_WIDTH_HPP_INCLUDED
        -: 9235:
        -: 9236:
        -: 9237:#ifndef CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 9238:#define CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 9239:
        -: 9240:
        -: 9241:#include <cstddef>
        -: 9242:#include <initializer_list>
        -: 9243:
        -: 9244:// We want a simple polyfill over `std::empty`, `std::size` and so on
        -: 9245:// for C++14 or C++ libraries with incomplete support.
        -: 9246:// We also have to handle that MSVC std lib will happily provide these
        -: 9247:// under older standards.
        -: 9248:#if defined(CATCH_CPP17_OR_GREATER) || defined(_MSC_VER)
        -: 9249:
        -: 9250:// We are already using this header either way, so there shouldn't
        -: 9251:// be much additional overhead in including it to get the feature
        -: 9252:// test macros
        -: 9253:#include <string>
        -: 9254:
        -: 9255:#  if !defined(__cpp_lib_nonmember_container_access)
        -: 9256:#      define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 9257:#  endif
        -: 9258:
        -: 9259:#else
        -: 9260:#define CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 9261:#endif
        -: 9262:
        -: 9263:
        -: 9264:
        -: 9265:namespace Catch {
        -: 9266:namespace Detail {
        -: 9267:
        -: 9268:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -: 9269:    template <typename Container>
        -: 9270:    constexpr auto empty(Container const& cont) -> decltype(cont.empty()) {
        -: 9271:        return cont.empty();
        -: 9272:    }
        -: 9273:    template <typename T, std::size_t N>
        -: 9274:    constexpr bool empty(const T (&)[N]) noexcept {
        -: 9275:        // GCC < 7 does not support the const T(&)[] parameter syntax
        -: 9276:        // so we have to ignore the length explicitly
        -: 9277:        (void)N;
        -: 9278:        return false;
        -: 9279:    }
        -: 9280:    template <typename T>
        -: 9281:    constexpr bool empty(std::initializer_list<T> list) noexcept {
        -: 9282:        return list.size() > 0;
        -: 9283:    }
        -: 9284:
        -: 9285:
        -: 9286:    template <typename Container>
        -: 9287:    constexpr auto size(Container const& cont) -> decltype(cont.size()) {
        -: 9288:        return cont.size();
        -: 9289:    }
        -: 9290:    template <typename T, std::size_t N>
        -: 9291:    constexpr std::size_t size(const T(&)[N]) noexcept {
        -: 9292:        return N;
        -: 9293:    }
        -: 9294:#endif // CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS
        -: 9295:
        -: 9296:} // end namespace Detail
        -: 9297:} // end namespace Catch
        -: 9298:
        -: 9299:
        -: 9300:
        -: 9301:#endif // CATCH_CONTAINER_NONMEMBERS_HPP_INCLUDED
        -: 9302:
        -: 9303:
        -: 9304:#ifndef CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 9305:#define CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 9306:
        -: 9307:#include <string>
        -: 9308:
        -: 9309:namespace Catch {
        -: 9310:    void writeToDebugConsole( std::string const& text );
        -: 9311:}
        -: 9312:
        -: 9313:#endif // CATCH_DEBUG_CONSOLE_HPP_INCLUDED
        -: 9314:
        -: 9315:
        -: 9316:#ifndef CATCH_DEBUGGER_HPP_INCLUDED
        -: 9317:#define CATCH_DEBUGGER_HPP_INCLUDED
        -: 9318:
        -: 9319:
        -: 9320:namespace Catch {
        -: 9321:    bool isDebuggerActive();
        -: 9322:}
        -: 9323:
        -: 9324:#ifdef CATCH_PLATFORM_MAC
        -: 9325:
        -: 9326:    #if defined(__i386__) || defined(__x86_64__)
        -: 9327:        #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
        -: 9328:    #elif defined(__aarch64__)
        -: 9329:        #define CATCH_TRAP() __asm__(".inst 0xd43e0000")
        -: 9330:    #elif defined(__POWERPC__)
        -: 9331:        #define CATCH_TRAP() __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
        -: 9332:        : : : "memory","r0","r3","r4" ) /* NOLINT */
        -: 9333:    #endif
        -: 9334:
        -: 9335:#elif defined(CATCH_PLATFORM_IPHONE)
        -: 9336:
        -: 9337:    // use inline assembler
        -: 9338:    #if defined(__i386__) || defined(__x86_64__)
        -: 9339:        #define CATCH_TRAP()  __asm__("int $3")
        -: 9340:    #elif defined(__aarch64__)
        -: 9341:        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
        -: 9342:    #elif defined(__arm__) && !defined(__thumb__)
        -: 9343:        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")
        -: 9344:    #elif defined(__arm__) &&  defined(__thumb__)
        -: 9345:        #define CATCH_TRAP()  __asm__(".inst 0xde01")
        -: 9346:    #endif
        -: 9347:
        -: 9348:#elif defined(CATCH_PLATFORM_LINUX)
        -: 9349:    // If we can use inline assembler, do it because this allows us to break
        -: 9350:    // directly at the location of the failing check instead of breaking inside
        -: 9351:    // raise() called from it, i.e. one stack frame below.
        -: 9352:    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
        -: 9353:        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
        -: 9354:    #else // Fall back to the generic way.
        -: 9355:        #include <signal.h>
        -: 9356:
        -: 9357:        #define CATCH_TRAP() raise(SIGTRAP)
        -: 9358:    #endif
        -: 9359:#elif defined(_MSC_VER)
        -: 9360:    #define CATCH_TRAP() __debugbreak()
        -: 9361:#elif defined(__MINGW32__)
        -: 9362:    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
        -: 9363:    #define CATCH_TRAP() DebugBreak()
        -: 9364:#endif
        -: 9365:
        -: 9366:#ifndef CATCH_BREAK_INTO_DEBUGGER
        -: 9367:    #ifdef CATCH_TRAP
        -: 9368:        #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
        -: 9369:    #else
        -: 9370:        #define CATCH_BREAK_INTO_DEBUGGER() []{}()
        -: 9371:    #endif
        -: 9372:#endif
        -: 9373:
        -: 9374:#endif // CATCH_DEBUGGER_HPP_INCLUDED
        -: 9375:
        -: 9376:
        -: 9377:#ifndef CATCH_ENFORCE_HPP_INCLUDED
        -: 9378:#define CATCH_ENFORCE_HPP_INCLUDED
        -: 9379:
        -: 9380:
        -: 9381:#include <exception>
        -: 9382:
        -: 9383:namespace Catch {
        -: 9384:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -: 9385:    template <typename Ex>
        -: 9386:    [[noreturn]]
        -: 9387:    void throw_exception(Ex const& e) {
        -: 9388:        throw e;
        -: 9389:    }
        -: 9390:#else // ^^ Exceptions are enabled //  Exceptions are disabled vv
        -: 9391:    [[noreturn]]
        -: 9392:    void throw_exception(std::exception const& e);
        -: 9393:#endif
        -: 9394:
        -: 9395:    [[noreturn]]
        -: 9396:    void throw_logic_error(std::string const& msg);
        -: 9397:    [[noreturn]]
        -: 9398:    void throw_domain_error(std::string const& msg);
        -: 9399:    [[noreturn]]
        -: 9400:    void throw_runtime_error(std::string const& msg);
        -: 9401:
        -: 9402:} // namespace Catch;
        -: 9403:
        -: 9404:#define CATCH_MAKE_MSG(...) \
        -: 9405:    (Catch::ReusableStringStream() << __VA_ARGS__).str()
        -: 9406:
        -: 9407:#define CATCH_INTERNAL_ERROR(...) \
        -: 9408:    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))
        -: 9409:
        -: 9410:#define CATCH_ERROR(...) \
        -: 9411:    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
        -: 9412:
        -: 9413:#define CATCH_RUNTIME_ERROR(...) \
        -: 9414:    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
        -: 9415:
        -: 9416:#define CATCH_ENFORCE( condition, ... ) \
        -: 9417:    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)
        -: 9418:
        -: 9419:
        -: 9420:#endif // CATCH_ENFORCE_HPP_INCLUDED
        -: 9421:
        -: 9422:
        -: 9423:#ifndef CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 9424:#define CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 9425:
        -: 9426:
        -: 9427:#include <vector>
        -: 9428:
        -: 9429:namespace Catch {
        -: 9430:
        -: 9431:    namespace Detail {
        -: 9432:
        -: 9433:        Catch::Detail::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );
        -: 9434:
        -: 9435:        class EnumValuesRegistry : public IMutableEnumValuesRegistry {
        -: 9436:
        -: 9437:            std::vector<Catch::Detail::unique_ptr<EnumInfo>> m_enumInfos;
        -: 9438:
        -: 9439:            EnumInfo const& registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values) override;
        -: 9440:        };
        -: 9441:
        -: 9442:        std::vector<StringRef> parseEnums( StringRef enums );
        -: 9443:
        -: 9444:    } // Detail
        -: 9445:
        -: 9446:} // Catch
        -: 9447:
        -: 9448:#endif // CATCH_ENUM_VALUES_REGISTRY_HPP_INCLUDED
        -: 9449:
        -: 9450:
        -: 9451:#ifndef CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 9452:#define CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 9453:
        -: 9454:namespace Catch {
        -: 9455:
        -: 9456:    //! Simple RAII class that stores the value of `errno`
        -: 9457:    //! at construction and restores it at destruction.
        -: 9458:    class ErrnoGuard {
        -: 9459:    public:
        -: 9460:        // Keep these outlined to avoid dragging in macros from <cerrno>
        -: 9461:
        -: 9462:        ErrnoGuard();
        -: 9463:        ~ErrnoGuard();
        -: 9464:    private:
        -: 9465:        int m_oldErrno;
        -: 9466:    };
        -: 9467:
        -: 9468:}
        -: 9469:
        -: 9470:#endif // CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 9471:
        -: 9472:
        -: 9473:#ifndef CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 9474:#define CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 9475:
        -: 9476:
        -: 9477:#include <vector>
        -: 9478:#include <string>
        -: 9479:
        -: 9480:namespace Catch {
        -: 9481:
        -: 9482:    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
        -: 9483:    public:
        -: 9484:        ~ExceptionTranslatorRegistry() override;
        -: 9485:        void registerTranslator( Detail::unique_ptr<IExceptionTranslator>&& translator );
        -: 9486:        std::string translateActiveException() const override;
        -: 9487:
        -: 9488:    private:
        -: 9489:        ExceptionTranslators m_translators;
        -: 9490:    };
        -: 9491:}
        -: 9492:
        -: 9493:#endif // CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 9494:
        -: 9495:
        -: 9496:#ifndef CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 9497:#define CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 9498:
        -: 9499:#include <cassert>
        -: 9500:
        -: 9501:namespace Catch {
        -: 9502:
        -: 9503:    /**
        -: 9504:     * Wrapper for platform-specific fatal error (signals/SEH) handlers
        -: 9505:     *
        -: 9506:     * Tries to be cooperative with other handlers, and not step over
        -: 9507:     * other handlers. This means that unknown structured exceptions
        -: 9508:     * are passed on, previous signal handlers are called, and so on.
        -: 9509:     *
        -: 9510:     * Can only be instantiated once, and assumes that once a signal
        -: 9511:     * is caught, the binary will end up terminating. Thus, there
        -: 9512:     */
        -: 9513:    class FatalConditionHandler {
        -: 9514:        bool m_started = false;
        -: 9515:
        -: 9516:        // Install/disengage implementation for specific platform.
        -: 9517:        // Should be if-defed to work on current platform, can assume
        -: 9518:        // engage-disengage 1:1 pairing.
        -: 9519:        void engage_platform();
        -: 9520:        void disengage_platform() noexcept;
        -: 9521:    public:
        -: 9522:        // Should also have platform-specific implementations as needed
        -: 9523:        FatalConditionHandler();
        -: 9524:        ~FatalConditionHandler();
        -: 9525:
        -: 9526:        void engage() {
        -: 9527:            assert(!m_started && "Handler cannot be installed twice.");
        -: 9528:            m_started = true;
        -: 9529:            engage_platform();
        -: 9530:        }
        -: 9531:
        -: 9532:        void disengage() noexcept {
        -: 9533:            assert(m_started && "Handler cannot be uninstalled without being installed first");
        -: 9534:            m_started = false;
        -: 9535:            disengage_platform();
        -: 9536:        }
        -: 9537:    };
        -: 9538:
        -: 9539:    //! Simple RAII guard for (dis)engaging the FatalConditionHandler
        -: 9540:    class FatalConditionHandlerGuard {
        -: 9541:        FatalConditionHandler* m_handler;
        -: 9542:    public:
        -: 9543:        FatalConditionHandlerGuard(FatalConditionHandler* handler):
        -: 9544:            m_handler(handler) {
        -: 9545:            m_handler->engage();
        -: 9546:        }
        -: 9547:        ~FatalConditionHandlerGuard() {
        -: 9548:            m_handler->disengage();
        -: 9549:        }
        -: 9550:    };
        -: 9551:
        -: 9552:} // end namespace Catch
        -: 9553:
        -: 9554:#endif // CATCH_FATAL_CONDITION_HANDLER_HPP_INCLUDED
        -: 9555:
        -: 9556:
        -: 9557:#ifndef CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 9558:#define CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 9559:
        -: 9560:
        -: 9561:#include <cassert>
        -: 9562:#include <cmath>
        -: 9563:#include <cstdint>
        -: 9564:#include <utility>
        -: 9565:#include <limits>
        -: 9566:
        -: 9567:namespace Catch {
        -: 9568:    namespace Detail {
        -: 9569:
        -: 9570:        uint32_t convertToBits(float f);
        -: 9571:        uint64_t convertToBits(double d);
        -: 9572:
        -: 9573:        // Used when we know we want == comparison of two doubles
        -: 9574:        // to centralize warning suppression
        -: 9575:        bool directCompare( float lhs, float rhs );
        -: 9576:        bool directCompare( double lhs, double rhs );
        -: 9577:
        -: 9578:    } // end namespace Detail
        -: 9579:
        -: 9580:
        -: 9581:
        -: 9582:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 9583:#    pragma GCC diagnostic push
        -: 9584:    // We do a bunch of direct compensations of floating point numbers,
        -: 9585:    // because we know what we are doing and actually do want the direct
        -: 9586:    // comparison behaviour.
        -: 9587:#    pragma GCC diagnostic ignored "-Wfloat-equal"
        -: 9588:#endif
        -: 9589:
        -: 9590:    /**
        -: 9591:     * Calculates the ULP distance between two floating point numbers
        -: 9592:     *
        -: 9593:     * The ULP distance of two floating point numbers is the count of
        -: 9594:     * valid floating point numbers representable between them.
        -: 9595:     *
        -: 9596:     * There are some exceptions between how this function counts the
        -: 9597:     * distance, and the interpretation of the standard as implemented.
        -: 9598:     * by e.g. `nextafter`. For this function it always holds that:
        -: 9599:     * * `(x == y) => ulpDistance(x, y) == 0` (so `ulpDistance(-0, 0) == 0`)
        -: 9600:     * * `ulpDistance(maxFinite, INF) == 1`
        -: 9601:     * * `ulpDistance(x, -x) == 2 * ulpDistance(x, 0)`
        -: 9602:     *
        -: 9603:     * \pre `!isnan( lhs )`
        -: 9604:     * \pre `!isnan( rhs )`
        -: 9605:     * \pre floating point numbers are represented in IEEE-754 format
        -: 9606:     */
        -: 9607:    template <typename FP>
        -: 9608:    uint64_t ulpDistance( FP lhs, FP rhs ) {
        -: 9609:        assert( std::numeric_limits<FP>::is_iec559 &&
        -: 9610:            "ulpDistance assumes IEEE-754 format for floating point types" );
        -: 9611:        assert( !Catch::isnan( lhs ) &&
        -: 9612:                "Distance between NaN and number is not meaningful" );
        -: 9613:        assert( !Catch::isnan( rhs ) &&
        -: 9614:                "Distance between NaN and number is not meaningful" );
        -: 9615:
        -: 9616:        // We want X == Y to imply 0 ULP distance even if X and Y aren't
        -: 9617:        // bit-equal (-0 and 0), or X - Y != 0 (same sign infinities).
        -: 9618:        if ( lhs == rhs ) { return 0; }
        -: 9619:
        -: 9620:        // We need a properly typed positive zero for type inference.
        -: 9621:        static constexpr FP positive_zero{};
        -: 9622:
        -: 9623:        // We want to ensure that +/- 0 is always represented as positive zero
        -: 9624:        if ( lhs == positive_zero ) { lhs = positive_zero; }
        -: 9625:        if ( rhs == positive_zero ) { rhs = positive_zero; }
        -: 9626:
        -: 9627:        // If arguments have different signs, we can handle them by summing
        -: 9628:        // how far are they from 0 each.
        -: 9629:        if ( std::signbit( lhs ) != std::signbit( rhs ) ) {
        -: 9630:            return ulpDistance( std::abs( lhs ), positive_zero ) +
        -: 9631:                   ulpDistance( std::abs( rhs ), positive_zero );
        -: 9632:        }
        -: 9633:
        -: 9634:        // When both lhs and rhs are of the same sign, we can just
        -: 9635:        // read the numbers bitwise as integers, and then subtract them
        -: 9636:        // (assuming IEEE).
        -: 9637:        uint64_t lc = Detail::convertToBits( lhs );
        -: 9638:        uint64_t rc = Detail::convertToBits( rhs );
        -: 9639:
        -: 9640:        // The ulp distance between two numbers is symmetric, so to avoid
        -: 9641:        // dealing with overflows we want the bigger converted number on the lhs
        -: 9642:        if ( lc < rc ) {
        -: 9643:            std::swap( lc, rc );
        -: 9644:        }
        -: 9645:
        -: 9646:        return lc - rc;
        -: 9647:    }
        -: 9648:
        -: 9649:#if defined( __GNUC__ ) || defined( __clang__ )
        -: 9650:#    pragma GCC diagnostic pop
        -: 9651:#endif
        -: 9652:
        -: 9653:
        -: 9654:} // end namespace Catch
        -: 9655:
        -: 9656:#endif // CATCH_FLOATING_POINT_HELPERS_HPP_INCLUDED
        -: 9657:
        -: 9658:
        -: 9659:#ifndef CATCH_GETENV_HPP_INCLUDED
        -: 9660:#define CATCH_GETENV_HPP_INCLUDED
        -: 9661:
        -: 9662:namespace Catch {
        -: 9663:namespace Detail {
        -: 9664:
        -: 9665:    //! Wrapper over `std::getenv` that compiles on UWP (and always returns nullptr there)
        -: 9666:    char const* getEnv(char const* varName);
        -: 9667:
        -: 9668:}
        -: 9669:}
        -: 9670:
        -: 9671:#endif // CATCH_GETENV_HPP_INCLUDED
        -: 9672:
        -: 9673:
        -: 9674:#ifndef CATCH_IS_PERMUTATION_HPP_INCLUDED
        -: 9675:#define CATCH_IS_PERMUTATION_HPP_INCLUDED
        -: 9676:
        -: 9677:#include <algorithm>
        -: 9678:#include <iterator>
        -: 9679:
        -: 9680:namespace Catch {
        -: 9681:    namespace Detail {
        -: 9682:
        -: 9683:        template <typename ForwardIter,
        -: 9684:                  typename Sentinel,
        -: 9685:                  typename T,
        -: 9686:                  typename Comparator>
        -: 9687:        ForwardIter find_sentinel( ForwardIter start,
        -: 9688:                                   Sentinel sentinel,
        -: 9689:                                   T const& value,
        -: 9690:                                   Comparator cmp ) {
        -: 9691:            while ( start != sentinel ) {
        -: 9692:                if ( cmp( *start, value ) ) { break; }
        -: 9693:                ++start;
        -: 9694:            }
        -: 9695:            return start;
        -: 9696:        }
        -: 9697:
        -: 9698:        template <typename ForwardIter,
        -: 9699:                  typename Sentinel,
        -: 9700:                  typename T,
        -: 9701:                  typename Comparator>
        -: 9702:        std::ptrdiff_t count_sentinel( ForwardIter start,
        -: 9703:                                       Sentinel sentinel,
        -: 9704:                                       T const& value,
        -: 9705:                                       Comparator cmp ) {
        -: 9706:            std::ptrdiff_t count = 0;
        -: 9707:            while ( start != sentinel ) {
        -: 9708:                if ( cmp( *start, value ) ) { ++count; }
        -: 9709:                ++start;
        -: 9710:            }
        -: 9711:            return count;
        -: 9712:        }
        -: 9713:
        -: 9714:        template <typename ForwardIter, typename Sentinel>
        -: 9715:        std::enable_if_t<!std::is_same<ForwardIter, Sentinel>::value,
        -: 9716:                         std::ptrdiff_t>
        -: 9717:        sentinel_distance( ForwardIter iter, const Sentinel sentinel ) {
        -: 9718:            std::ptrdiff_t dist = 0;
        -: 9719:            while ( iter != sentinel ) {
        -: 9720:                ++iter;
        -: 9721:                ++dist;
        -: 9722:            }
        -: 9723:            return dist;
        -: 9724:        }
        -: 9725:
        -: 9726:        template <typename ForwardIter>
        -: 9727:        std::ptrdiff_t sentinel_distance( ForwardIter first,
        -: 9728:                                          ForwardIter last ) {
        -: 9729:            return std::distance( first, last );
        -: 9730:        }
        -: 9731:
        -: 9732:        template <typename ForwardIter1,
        -: 9733:                  typename Sentinel1,
        -: 9734:                  typename ForwardIter2,
        -: 9735:                  typename Sentinel2,
        -: 9736:                  typename Comparator>
        -: 9737:        bool check_element_counts( ForwardIter1 first_1,
        -: 9738:                                   const Sentinel1 end_1,
        -: 9739:                                   ForwardIter2 first_2,
        -: 9740:                                   const Sentinel2 end_2,
        -: 9741:                                   Comparator cmp ) {
        -: 9742:            auto cursor = first_1;
        -: 9743:            while ( cursor != end_1 ) {
        -: 9744:                if ( find_sentinel( first_1, cursor, *cursor, cmp ) ==
        -: 9745:                     cursor ) {
        -: 9746:                    // we haven't checked this element yet
        -: 9747:                    const auto count_in_range_2 =
        -: 9748:                        count_sentinel( first_2, end_2, *cursor, cmp );
        -: 9749:                    // Not a single instance in 2nd range, so it cannot be a
        -: 9750:                    // permutation of 1st range
        -: 9751:                    if ( count_in_range_2 == 0 ) { return false; }
        -: 9752:
        -: 9753:                    const auto count_in_range_1 =
        -: 9754:                        count_sentinel( cursor, end_1, *cursor, cmp );
        -: 9755:                    if ( count_in_range_1 != count_in_range_2 ) {
        -: 9756:                        return false;
        -: 9757:                    }
        -: 9758:                }
        -: 9759:
        -: 9760:                ++cursor;
        -: 9761:            }
        -: 9762:
        -: 9763:            return true;
        -: 9764:        }
        -: 9765:
        -: 9766:        template <typename ForwardIter1,
        -: 9767:                  typename Sentinel1,
        -: 9768:                  typename ForwardIter2,
        -: 9769:                  typename Sentinel2,
        -: 9770:                  typename Comparator>
        -: 9771:        bool is_permutation( ForwardIter1 first_1,
        -: 9772:                             const Sentinel1 end_1,
        -: 9773:                             ForwardIter2 first_2,
        -: 9774:                             const Sentinel2 end_2,
        -: 9775:                             Comparator cmp ) {
        -: 9776:            // TODO: no optimization for stronger iterators, because we would also have to constrain on sentinel vs not sentinel types
        -: 9777:            // TODO: Comparator has to be "both sides", e.g. a == b => b == a
        -: 9778:            // This skips shared prefix of the two ranges
        -: 9779:            while (first_1 != end_1 && first_2 != end_2 && cmp(*first_1, *first_2)) {
        -: 9780:                ++first_1;
        -: 9781:                ++first_2;
        -: 9782:            }
        -: 9783:
        -: 9784:            // We need to handle case where at least one of the ranges has no more elements
        -: 9785:            if (first_1 == end_1 || first_2 == end_2) {
        -: 9786:                return first_1 == end_1 && first_2 == end_2;
        -: 9787:            }
        -: 9788:
        -: 9789:            // pair counting is n**2, so we pay linear walk to compare the sizes first
        -: 9790:            auto dist_1 = sentinel_distance( first_1, end_1 );
        -: 9791:            auto dist_2 = sentinel_distance( first_2, end_2 );
        -: 9792:
        -: 9793:            if (dist_1 != dist_2) { return false; }
        -: 9794:
        -: 9795:            // Since we do not try to handle stronger iterators pair (e.g.
        -: 9796:            // bidir) optimally, the only thing left to do is to check counts in
        -: 9797:            // the remaining ranges.
        -: 9798:            return check_element_counts( first_1, end_1, first_2, end_2, cmp );
        -: 9799:        }
        -: 9800:
        -: 9801:    } // namespace Detail
        -: 9802:} // namespace Catch
        -: 9803:
        -: 9804:#endif // CATCH_IS_PERMUTATION_HPP_INCLUDED
        -: 9805:
        -: 9806:
        -: 9807:#ifndef CATCH_ISTREAM_HPP_INCLUDED
        -: 9808:#define CATCH_ISTREAM_HPP_INCLUDED
        -: 9809:
        -: 9810:
        -: 9811:#include <iosfwd>
        -: 9812:#include <cstddef>
        -: 9813:#include <ostream>
        -: 9814:#include <string>
        -: 9815:
        -: 9816:namespace Catch {
        -: 9817:
        -: 9818:    class IStream {
        -: 9819:    public:
        -: 9820:        virtual ~IStream(); // = default
        -: 9821:        virtual std::ostream& stream() = 0;
        -: 9822:        /**
        -: 9823:         * Best guess on whether the instance is writing to a console (e.g. via stdout/stderr)
        -: 9824:         *
        -: 9825:         * This is useful for e.g. Win32 colour support, because the Win32
        -: 9826:         * API manipulates console directly, unlike POSIX escape codes,
        -: 9827:         * that can be written anywhere.
        -: 9828:         *
        -: 9829:         * Due to variety of ways to change where the stdout/stderr is
        -: 9830:         * _actually_ being written, users should always assume that
        -: 9831:         * the answer might be wrong.
        -: 9832:         */
        -: 9833:        virtual bool isConsole() const { return false; }
        -: 9834:    };
        -: 9835:
        -: 9836:    /**
        -: 9837:     * Creates a stream wrapper that writes to specific file.
        -: 9838:     *
        -: 9839:     * Also recognizes 4 special filenames
        -: 9840:     * * `-` for stdout
        -: 9841:     * * `%stdout` for stdout
        -: 9842:     * * `%stderr` for stderr
        -: 9843:     * * `%debug` for platform specific debugging output
        -: 9844:     *
        -: 9845:     * \throws if passed an unrecognized %-prefixed stream
        -: 9846:     */
        -: 9847:    auto makeStream( std::string const& filename ) -> Detail::unique_ptr<IStream>;
        -: 9848:
        -: 9849:}
        -: 9850:
        -: 9851:#endif // CATCH_STREAM_HPP_INCLUDED
        -: 9852:
        -: 9853:
        -: 9854:#ifndef CATCH_JSONWRITER_HPP_INCLUDED
        -: 9855:#define CATCH_JSONWRITER_HPP_INCLUDED
        -: 9856:
        -: 9857:
        -: 9858:#include <cstdint>
        -: 9859:#include <sstream>
        -: 9860:
        -: 9861:namespace Catch {
        -: 9862:    class JsonObjectWriter;
        -: 9863:    class JsonArrayWriter;
        -: 9864:
        -: 9865:    struct JsonUtils {
        -: 9866:        static void indent( std::ostream& os, std::uint64_t level );
        -: 9867:        static void appendCommaNewline( std::ostream& os,
        -: 9868:                                        bool& should_comma,
        -: 9869:                                        std::uint64_t level );
        -: 9870:    };
        -: 9871:
        -: 9872:    class JsonValueWriter {
        -: 9873:    public:
        -: 9874:        JsonValueWriter( std::ostream& os );
        -: 9875:        JsonValueWriter( std::ostream& os, std::uint64_t indent_level );
        -: 9876:
        -: 9877:        JsonObjectWriter writeObject() &&;
        -: 9878:        JsonArrayWriter writeArray() &&;
        -: 9879:
        -: 9880:        template <typename T>
        -: 9881:        void write( T const& value ) && {
        -: 9882:            writeImpl( value, !std::is_arithmetic<T>::value );
        -: 9883:        }
        -: 9884:        void write( StringRef value ) &&;
        -: 9885:        void write( bool value ) &&;
        -: 9886:
        -: 9887:    private:
        -: 9888:        void writeImpl( StringRef value, bool quote );
        -: 9889:
        -: 9890:        // Without this SFINAE, this overload is a better match
        -: 9891:        // for `std::string`, `char const*`, `char const[N]` args.
        -: 9892:        // While it would still work, it would cause code bloat
        -: 9893:        // and multiple iteration over the strings
        -: 9894:        template <typename T,
        -: 9895:                  typename = typename std::enable_if_t<
        -: 9896:                      !std::is_convertible<T, StringRef>::value>>
        -: 9897:        void writeImpl( T const& value, bool quote_value ) {
        -: 9898:            m_sstream << value;
        -: 9899:            writeImpl( m_sstream.str(), quote_value );
        -: 9900:        }
        -: 9901:
        -: 9902:        std::ostream& m_os;
        -: 9903:        std::stringstream m_sstream;
        -: 9904:        std::uint64_t m_indent_level;
        -: 9905:    };
        -: 9906:
        -: 9907:    class JsonObjectWriter {
        -: 9908:    public:
        -: 9909:        JsonObjectWriter( std::ostream& os );
        -: 9910:        JsonObjectWriter( std::ostream& os, std::uint64_t indent_level );
        -: 9911:
        -: 9912:        JsonObjectWriter( JsonObjectWriter&& source ) noexcept;
        -: 9913:        JsonObjectWriter& operator=( JsonObjectWriter&& source ) = delete;
        -: 9914:
        -: 9915:        ~JsonObjectWriter();
        -: 9916:
        -: 9917:        JsonValueWriter write( StringRef key );
        -: 9918:
        -: 9919:    private:
        -: 9920:        std::ostream& m_os;
        -: 9921:        std::uint64_t m_indent_level;
        -: 9922:        bool m_should_comma = false;
        -: 9923:        bool m_active = true;
        -: 9924:    };
        -: 9925:
        -: 9926:    class JsonArrayWriter {
        -: 9927:    public:
        -: 9928:        JsonArrayWriter( std::ostream& os );
        -: 9929:        JsonArrayWriter( std::ostream& os, std::uint64_t indent_level );
        -: 9930:
        -: 9931:        JsonArrayWriter( JsonArrayWriter&& source ) noexcept;
        -: 9932:        JsonArrayWriter& operator=( JsonArrayWriter&& source ) = delete;
        -: 9933:
        -: 9934:        ~JsonArrayWriter();
        -: 9935:
        -: 9936:        JsonObjectWriter writeObject();
        -: 9937:        JsonArrayWriter writeArray();
        -: 9938:
        -: 9939:        template <typename T>
        -: 9940:        JsonArrayWriter& write( T const& value ) {
        -: 9941:            return writeImpl( value );
        -: 9942:        }
        -: 9943:
        -: 9944:        JsonArrayWriter& write( bool value );
        -: 9945:
        -: 9946:    private:
        -: 9947:        template <typename T>
        -: 9948:        JsonArrayWriter& writeImpl( T const& value ) {
        -: 9949:            JsonUtils::appendCommaNewline(
        -: 9950:                m_os, m_should_comma, m_indent_level + 1 );
        -: 9951:            JsonValueWriter{ m_os }.write( value );
        -: 9952:
        -: 9953:            return *this;
        -: 9954:        }
        -: 9955:
        -: 9956:        std::ostream& m_os;
        -: 9957:        std::uint64_t m_indent_level;
        -: 9958:        bool m_should_comma = false;
        -: 9959:        bool m_active = true;
        -: 9960:    };
        -: 9961:
        -: 9962:} // namespace Catch
        -: 9963:
        -: 9964:#endif // CATCH_JSONWRITER_HPP_INCLUDED
        -: 9965:
        -: 9966:
        -: 9967:#ifndef CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 9968:#define CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 9969:
        -: 9970:namespace Catch {
        -: 9971:
        -: 9972:    struct LeakDetector {
        -: 9973:        LeakDetector();
        -: 9974:        ~LeakDetector();
        -: 9975:    };
        -: 9976:
        -: 9977:}
        -: 9978:#endif // CATCH_LEAK_DETECTOR_HPP_INCLUDED
        -: 9979:
        -: 9980:
        -: 9981:#ifndef CATCH_LIST_HPP_INCLUDED
        -: 9982:#define CATCH_LIST_HPP_INCLUDED
        -: 9983:
        -: 9984:
        -: 9985:#include <set>
        -: 9986:#include <string>
        -: 9987:
        -: 9988:
        -: 9989:namespace Catch {
        -: 9990:
        -: 9991:    class IEventListener;
        -: 9992:    class Config;
        -: 9993:
        -: 9994:
        -: 9995:    struct ReporterDescription {
        -: 9996:        std::string name, description;
        -: 9997:    };
        -: 9998:    struct ListenerDescription {
        -: 9999:        StringRef name;
        -:10000:        std::string description;
        -:10001:    };
        -:10002:
        -:10003:    struct TagInfo {
        -:10004:        void add(StringRef spelling);
        -:10005:        std::string all() const;
        -:10006:
        -:10007:        std::set<StringRef> spellings;
        -:10008:        std::size_t count = 0;
        -:10009:    };
        -:10010:
        -:10011:    bool list( IEventListener& reporter, Config const& config );
        -:10012:
        -:10013:} // end namespace Catch
        -:10014:
        -:10015:#endif // CATCH_LIST_HPP_INCLUDED
        -:10016:
        -:10017:
        -:10018:#ifndef CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -:10019:#define CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -:10020:
        -:10021:
        -:10022:#include <cstdio>
        -:10023:#include <iosfwd>
        -:10024:#include <string>
        -:10025:
        -:10026:namespace Catch {
        -:10027:
        -:10028:    class RedirectedStream {
        -:10029:        std::ostream& m_originalStream;
        -:10030:        std::ostream& m_redirectionStream;
        -:10031:        std::streambuf* m_prevBuf;
        -:10032:
        -:10033:    public:
        -:10034:        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );
        -:10035:        ~RedirectedStream();
        -:10036:    };
        -:10037:
        -:10038:    class RedirectedStdOut {
        -:10039:        ReusableStringStream m_rss;
        -:10040:        RedirectedStream m_cout;
        -:10041:    public:
        -:10042:        RedirectedStdOut();
        -:10043:        auto str() const -> std::string;
        -:10044:    };
        -:10045:
        -:10046:    // StdErr has two constituent streams in C++, std::cerr and std::clog
        -:10047:    // This means that we need to redirect 2 streams into 1 to keep proper
        -:10048:    // order of writes
        -:10049:    class RedirectedStdErr {
        -:10050:        ReusableStringStream m_rss;
        -:10051:        RedirectedStream m_cerr;
        -:10052:        RedirectedStream m_clog;
        -:10053:    public:
        -:10054:        RedirectedStdErr();
        -:10055:        auto str() const -> std::string;
        -:10056:    };
        -:10057:
        -:10058:    class RedirectedStreams {
        -:10059:    public:
        -:10060:        RedirectedStreams(RedirectedStreams const&) = delete;
        -:10061:        RedirectedStreams& operator=(RedirectedStreams const&) = delete;
        -:10062:        RedirectedStreams(RedirectedStreams&&) = delete;
        -:10063:        RedirectedStreams& operator=(RedirectedStreams&&) = delete;
        -:10064:
        -:10065:        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);
        -:10066:        ~RedirectedStreams();
        -:10067:    private:
        -:10068:        std::string& m_redirectedCout;
        -:10069:        std::string& m_redirectedCerr;
        -:10070:        RedirectedStdOut m_redirectedStdOut;
        -:10071:        RedirectedStdErr m_redirectedStdErr;
        -:10072:    };
        -:10073:
        -:10074:#if defined(CATCH_CONFIG_NEW_CAPTURE)
        -:10075:
        -:10076:    // Windows's implementation of std::tmpfile is terrible (it tries
        -:10077:    // to create a file inside system folder, thus requiring elevated
        -:10078:    // privileges for the binary), so we have to use tmpnam(_s) and
        -:10079:    // create the file ourselves there.
        -:10080:    class TempFile {
        -:10081:    public:
        -:10082:        TempFile(TempFile const&) = delete;
        -:10083:        TempFile& operator=(TempFile const&) = delete;
        -:10084:        TempFile(TempFile&&) = delete;
        -:10085:        TempFile& operator=(TempFile&&) = delete;
        -:10086:
        -:10087:        TempFile();
        -:10088:        ~TempFile();
        -:10089:
        -:10090:        std::FILE* getFile();
        -:10091:        std::string getContents();
        -:10092:
        -:10093:    private:
        -:10094:        std::FILE* m_file = nullptr;
        -:10095:    #if defined(_MSC_VER)
        -:10096:        char m_buffer[L_tmpnam] = { 0 };
        -:10097:    #endif
        -:10098:    };
        -:10099:
        -:10100:
        -:10101:    class OutputRedirect {
        -:10102:    public:
        -:10103:        OutputRedirect(OutputRedirect const&) = delete;
        -:10104:        OutputRedirect& operator=(OutputRedirect const&) = delete;
        -:10105:        OutputRedirect(OutputRedirect&&) = delete;
        -:10106:        OutputRedirect& operator=(OutputRedirect&&) = delete;
        -:10107:
        -:10108:
        -:10109:        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);
        -:10110:        ~OutputRedirect();
        -:10111:
        -:10112:    private:
        -:10113:        int m_originalStdout = -1;
        -:10114:        int m_originalStderr = -1;
        -:10115:        TempFile m_stdoutFile;
        -:10116:        TempFile m_stderrFile;
        -:10117:        std::string& m_stdoutDest;
        -:10118:        std::string& m_stderrDest;
        -:10119:    };
        -:10120:
        -:10121:#endif
        -:10122:
        -:10123:} // end namespace Catch
        -:10124:
        -:10125:#endif // CATCH_OUTPUT_REDIRECT_HPP_INCLUDED
        -:10126:
        -:10127:
        -:10128:#ifndef CATCH_PARSE_NUMBERS_HPP_INCLUDED
        -:10129:#define CATCH_PARSE_NUMBERS_HPP_INCLUDED
        -:10130:
        -:10131:
        -:10132:#include <string>
        -:10133:
        -:10134:namespace Catch {
        -:10135:
        -:10136:    /**
        -:10137:     * Parses unsigned int from the input, using provided base
        -:10138:     *
        -:10139:     * Effectively a wrapper around std::stoul but with better error checking
        -:10140:     * e.g. "-1" is rejected, instead of being parsed as UINT_MAX.
        -:10141:     */
        -:10142:    Optional<unsigned int> parseUInt(std::string const& input, int base = 10);
        -:10143:}
        -:10144:
        -:10145:#endif // CATCH_PARSE_NUMBERS_HPP_INCLUDED
        -:10146:
        -:10147:
        -:10148:#ifndef CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -:10149:#define CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -:10150:
        -:10151:
        -:10152:#include <map>
        -:10153:#include <string>
        -:10154:#include <vector>
        -:10155:
        -:10156:namespace Catch {
        -:10157:
        -:10158:    class IEventListener;
        -:10159:    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;
        -:10160:    class IReporterFactory;
        -:10161:    using IReporterFactoryPtr = Detail::unique_ptr<IReporterFactory>;
        -:10162:    struct ReporterConfig;
        -:10163:    class EventListenerFactory;
        -:10164:
        -:10165:    class ReporterRegistry {
        -:10166:        struct ReporterRegistryImpl;
        -:10167:        Detail::unique_ptr<ReporterRegistryImpl> m_impl;
        -:10168:
        -:10169:    public:
        -:10170:        ReporterRegistry();
        -:10171:        ~ReporterRegistry(); // = default;
        -:10172:
        -:10173:        IEventListenerPtr create( std::string const& name,
        -:10174:                                  ReporterConfig&& config ) const;
        -:10175:
        -:10176:        void registerReporter( std::string const& name,
        -:10177:                               IReporterFactoryPtr factory );
        -:10178:
        -:10179:        void
        -:10180:        registerListener( Detail::unique_ptr<EventListenerFactory> factory );
        -:10181:
        -:10182:        std::map<std::string,
        -:10183:                 IReporterFactoryPtr,
        -:10184:                 Detail::CaseInsensitiveLess> const&
        -:10185:        getFactories() const;
        -:10186:
        -:10187:        std::vector<Detail::unique_ptr<EventListenerFactory>> const&
        -:10188:        getListeners() const;
        -:10189:    };
        -:10190:
        -:10191:} // end namespace Catch
        -:10192:
        -:10193:#endif // CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -:10194:
        -:10195:
        -:10196:#ifndef CATCH_RUN_CONTEXT_HPP_INCLUDED
        -:10197:#define CATCH_RUN_CONTEXT_HPP_INCLUDED
        -:10198:
        -:10199:
        -:10200:
        -:10201:#ifndef CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -:10202:#define CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -:10203:
        -:10204:
        -:10205:#include <string>
        -:10206:#include <vector>
        -:10207:
        -:10208:namespace Catch {
        -:10209:namespace TestCaseTracking {
        -:10210:
        -:10211:    struct NameAndLocation {
        -:10212:        std::string name;
        -:10213:        SourceLineInfo location;
        -:10214:
        -:10215:        NameAndLocation( std::string&& _name, SourceLineInfo const& _location );
        -:10216:        friend bool operator==(NameAndLocation const& lhs, NameAndLocation const& rhs) {
        -:10217:            // This is a very cheap check that should have a very high hit rate.
        -:10218:            // If we get to SourceLineInfo::operator==, we will redo it, but the
        -:10219:            // cost of repeating is trivial at that point (we will be paying
        -:10220:            // multiple strcmp/memcmps at that point).
        -:10221:            if ( lhs.location.line != rhs.location.line ) { return false; }
        -:10222:            return lhs.name == rhs.name && lhs.location == rhs.location;
        -:10223:        }
        -:10224:        friend bool operator!=(NameAndLocation const& lhs,
        -:10225:                               NameAndLocation const& rhs) {
        -:10226:            return !( lhs == rhs );
        -:10227:        }
        -:10228:    };
        -:10229:
        -:10230:    /**
        -:10231:     * This is a variant of `NameAndLocation` that does not own the name string
        -:10232:     *
        -:10233:     * This avoids extra allocations when trying to locate a tracker by its
        -:10234:     * name and location, as long as we make sure that trackers only keep
        -:10235:     * around the owning variant.
        -:10236:     */
        -:10237:    struct NameAndLocationRef {
        -:10238:        StringRef name;
        -:10239:        SourceLineInfo location;
        -:10240:
        -:10241:        constexpr NameAndLocationRef( StringRef name_,
        -:10242:                                      SourceLineInfo location_ ):
        -:10243:            name( name_ ), location( location_ ) {}
        -:10244:
        -:10245:        friend bool operator==( NameAndLocation const& lhs,
        -:10246:                                NameAndLocationRef const& rhs ) {
        -:10247:            // This is a very cheap check that should have a very high hit rate.
        -:10248:            // If we get to SourceLineInfo::operator==, we will redo it, but the
        -:10249:            // cost of repeating is trivial at that point (we will be paying
        -:10250:            // multiple strcmp/memcmps at that point).
        -:10251:            if ( lhs.location.line != rhs.location.line ) { return false; }
        -:10252:            return StringRef( lhs.name ) == rhs.name &&
        -:10253:                   lhs.location == rhs.location;
        -:10254:        }
        -:10255:        friend bool operator==( NameAndLocationRef const& lhs,
        -:10256:                                NameAndLocation const& rhs ) {
        -:10257:            return rhs == lhs;
        -:10258:        }
        -:10259:    };
        -:10260:
        -:10261:    class ITracker;
        -:10262:
        -:10263:    using ITrackerPtr = Catch::Detail::unique_ptr<ITracker>;
        -:10264:
        -:10265:    class ITracker {
        -:10266:        NameAndLocation m_nameAndLocation;
        -:10267:
        -:10268:        using Children = std::vector<ITrackerPtr>;
        -:10269:
        -:10270:    protected:
        -:10271:        enum CycleState {
        -:10272:            NotStarted,
        -:10273:            Executing,
        -:10274:            ExecutingChildren,
        -:10275:            NeedsAnotherRun,
        -:10276:            CompletedSuccessfully,
        -:10277:            Failed
        -:10278:        };
        -:10279:
        -:10280:        ITracker* m_parent = nullptr;
        -:10281:        Children m_children;
        -:10282:        CycleState m_runState = NotStarted;
        -:10283:
        -:10284:    public:
        -:10285:        ITracker( NameAndLocation&& nameAndLoc, ITracker* parent ):
        -:10286:            m_nameAndLocation( CATCH_MOVE(nameAndLoc) ),
        -:10287:            m_parent( parent )
        -:10288:        {}
        -:10289:
        -:10290:
        -:10291:        // static queries
        -:10292:        NameAndLocation const& nameAndLocation() const {
        -:10293:            return m_nameAndLocation;
        -:10294:        }
        -:10295:        ITracker* parent() const {
        -:10296:            return m_parent;
        -:10297:        }
        -:10298:
        -:10299:        virtual ~ITracker(); // = default
        -:10300:
        -:10301:
        -:10302:        // dynamic queries
        -:10303:
        -:10304:        //! Returns true if tracker run to completion (successfully or not)
        -:10305:        virtual bool isComplete() const = 0;
        -:10306:        //! Returns true if tracker run to completion successfully
        -:10307:        bool isSuccessfullyCompleted() const {
        -:10308:            return m_runState == CompletedSuccessfully;
        -:10309:        }
        -:10310:        //! Returns true if tracker has started but hasn't been completed
        -:10311:        bool isOpen() const;
        -:10312:        //! Returns true iff tracker has started
        -:10313:        bool hasStarted() const;
        -:10314:
        -:10315:        // actions
        -:10316:        virtual void close() = 0; // Successfully complete
        -:10317:        virtual void fail() = 0;
        -:10318:        void markAsNeedingAnotherRun();
        -:10319:
        -:10320:        //! Register a nested ITracker
        -:10321:        void addChild( ITrackerPtr&& child );
        -:10322:        /**
        -:10323:         * Returns ptr to specific child if register with this tracker.
        -:10324:         *
        -:10325:         * Returns nullptr if not found.
        -:10326:         */
        -:10327:        ITracker* findChild( NameAndLocationRef const& nameAndLocation );
        -:10328:        //! Have any children been added?
        -:10329:        bool hasChildren() const {
        -:10330:            return !m_children.empty();
        -:10331:        }
        -:10332:
        -:10333:
        -:10334:        //! Marks tracker as executing a child, doing se recursively up the tree
        -:10335:        void openChild();
        -:10336:
        -:10337:        /**
        -:10338:         * Returns true if the instance is a section tracker
        -:10339:         *
        -:10340:         * Subclasses should override to true if they are, replaces RTTI
        -:10341:         * for internal debug checks.
        -:10342:         */
        -:10343:        virtual bool isSectionTracker() const;
        -:10344:        /**
        -:10345:         * Returns true if the instance is a generator tracker
        -:10346:         *
        -:10347:         * Subclasses should override to true if they are, replaces RTTI
        -:10348:         * for internal debug checks.
        -:10349:         */
        -:10350:        virtual bool isGeneratorTracker() const;
        -:10351:    };
        -:10352:
        -:10353:    class TrackerContext {
        -:10354:
        -:10355:        enum RunState {
        -:10356:            NotStarted,
        -:10357:            Executing,
        -:10358:            CompletedCycle
        -:10359:        };
        -:10360:
        -:10361:        ITrackerPtr m_rootTracker;
        -:10362:        ITracker* m_currentTracker = nullptr;
        -:10363:        RunState m_runState = NotStarted;
        -:10364:
        -:10365:    public:
        -:10366:
        -:10367:        ITracker& startRun();
        -:10368:
        -:10369:        void startCycle() {
        -:10370:            m_currentTracker = m_rootTracker.get();
        -:10371:            m_runState = Executing;
        -:10372:        }
        -:10373:        void completeCycle();
        -:10374:
        -:10375:        bool completedCycle() const;
        -:10376:        ITracker& currentTracker() { return *m_currentTracker; }
        -:10377:        void setCurrentTracker( ITracker* tracker );
        -:10378:    };
        -:10379:
        -:10380:    class TrackerBase : public ITracker {
        -:10381:    protected:
        -:10382:
        -:10383:        TrackerContext& m_ctx;
        -:10384:
        -:10385:    public:
        -:10386:        TrackerBase( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -:10387:
        -:10388:        bool isComplete() const override;
        -:10389:
        -:10390:        void open();
        -:10391:
        -:10392:        void close() override;
        -:10393:        void fail() override;
        -:10394:
        -:10395:    private:
        -:10396:        void moveToParent();
        -:10397:        void moveToThis();
        -:10398:    };
        -:10399:
        -:10400:    class SectionTracker : public TrackerBase {
        -:10401:        std::vector<StringRef> m_filters;
        -:10402:        // Note that lifetime-wise we piggy back off the name stored in the `ITracker` parent`.
        -:10403:        // Currently it allocates owns the name, so this is safe. If it is later refactored
        -:10404:        // to not own the name, the name still has to outlive the `ITracker` parent, so
        -:10405:        // this should still be safe.
        -:10406:        StringRef m_trimmed_name;
        -:10407:    public:
        -:10408:        SectionTracker( NameAndLocation&& nameAndLocation, TrackerContext& ctx, ITracker* parent );
        -:10409:
        -:10410:        bool isSectionTracker() const override;
        -:10411:
        -:10412:        bool isComplete() const override;
        -:10413:
        -:10414:        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocationRef const& nameAndLocation );
        -:10415:
        -:10416:        void tryOpen();
        -:10417:
        -:10418:        void addInitialFilters( std::vector<std::string> const& filters );
        -:10419:        void addNextFilters( std::vector<StringRef> const& filters );
        -:10420:        //! Returns filters active in this tracker
        -:10421:        std::vector<StringRef> const& getFilters() const { return m_filters; }
        -:10422:        //! Returns whitespace-trimmed name of the tracked section
        -:10423:        StringRef trimmedName() const;
        -:10424:    };
        -:10425:
        -:10426:} // namespace TestCaseTracking
        -:10427:
        -:10428:using TestCaseTracking::ITracker;
        -:10429:using TestCaseTracking::TrackerContext;
        -:10430:using TestCaseTracking::SectionTracker;
        -:10431:
        -:10432:} // namespace Catch
        -:10433:
        -:10434:#endif // CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -:10435:
        -:10436:#include <string>
        -:10437:
        -:10438:namespace Catch {
        -:10439:
        -:10440:    class IGeneratorTracker;
        -:10441:    class IConfig;
        -:10442:    class IEventListener;
        -:10443:    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;
        -:10444:
        -:10445:    ///////////////////////////////////////////////////////////////////////////
        -:10446:
        -:10447:    class RunContext final : public IResultCapture {
        -:10448:
        -:10449:    public:
        -:10450:        RunContext( RunContext const& ) = delete;
        -:10451:        RunContext& operator =( RunContext const& ) = delete;
        -:10452:
        -:10453:        explicit RunContext( IConfig const* _config, IEventListenerPtr&& reporter );
        -:10454:
        -:10455:        ~RunContext() override;
        -:10456:
        -:10457:        Totals runTest(TestCaseHandle const& testCase);
        -:10458:
        -:10459:    public: // IResultCapture
        -:10460:
        -:10461:        // Assertion handlers
        -:10462:        void handleExpr
        -:10463:                (   AssertionInfo const& info,
        -:10464:                    ITransientExpression const& expr,
        -:10465:                    AssertionReaction& reaction ) override;
        -:10466:        void handleMessage
        -:10467:                (   AssertionInfo const& info,
        -:10468:                    ResultWas::OfType resultType,
        -:10469:                    StringRef message,
        -:10470:                    AssertionReaction& reaction ) override;
        -:10471:        void handleUnexpectedExceptionNotThrown
        -:10472:                (   AssertionInfo const& info,
        -:10473:                    AssertionReaction& reaction ) override;
        -:10474:        void handleUnexpectedInflightException
        -:10475:                (   AssertionInfo const& info,
        -:10476:                    std::string&& message,
        -:10477:                    AssertionReaction& reaction ) override;
        -:10478:        void handleIncomplete
        -:10479:                (   AssertionInfo const& info ) override;
        -:10480:        void handleNonExpr
        -:10481:                (   AssertionInfo const &info,
        -:10482:                    ResultWas::OfType resultType,
        -:10483:                    AssertionReaction &reaction ) override;
        -:10484:
        -:10485:        void notifyAssertionStarted( AssertionInfo const& info ) override;
        -:10486:        bool sectionStarted( StringRef sectionName,
        -:10487:                             SourceLineInfo const& sectionLineInfo,
        -:10488:                             Counts& assertions ) override;
        -:10489:
        -:10490:        void sectionEnded( SectionEndInfo&& endInfo ) override;
        -:10491:        void sectionEndedEarly( SectionEndInfo&& endInfo ) override;
        -:10492:
        -:10493:        IGeneratorTracker*
        -:10494:        acquireGeneratorTracker( StringRef generatorName,
        -:10495:                                 SourceLineInfo const& lineInfo ) override;
        -:10496:        IGeneratorTracker* createGeneratorTracker(
        -:10497:            StringRef generatorName,
        -:10498:            SourceLineInfo lineInfo,
        -:10499:            Generators::GeneratorBasePtr&& generator ) override;
        -:10500:
        -:10501:
        -:10502:        void benchmarkPreparing( StringRef name ) override;
        -:10503:        void benchmarkStarting( BenchmarkInfo const& info ) override;
        -:10504:        void benchmarkEnded( BenchmarkStats<> const& stats ) override;
        -:10505:        void benchmarkFailed( StringRef error ) override;
        -:10506:
        -:10507:        void pushScopedMessage( MessageInfo const& message ) override;
        -:10508:        void popScopedMessage( MessageInfo const& message ) override;
        -:10509:
        -:10510:        void emplaceUnscopedMessage( MessageBuilder&& builder ) override;
        -:10511:
        -:10512:        std::string getCurrentTestName() const override;
        -:10513:
        -:10514:        const AssertionResult* getLastResult() const override;
        -:10515:
        -:10516:        void exceptionEarlyReported() override;
        -:10517:
        -:10518:        void handleFatalErrorCondition( StringRef message ) override;
        -:10519:
        -:10520:        bool lastAssertionPassed() override;
        -:10521:
        -:10522:        void assertionPassed() override;
        -:10523:
        -:10524:    public:
        -:10525:        // !TBD We need to do this another way!
        -:10526:        bool aborting() const;
        -:10527:
        -:10528:    private:
        -:10529:
        -:10530:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
        -:10531:        void invokeActiveTestCase();
        -:10532:
        -:10533:        void resetAssertionInfo();
        -:10534:        bool testForMissingAssertions( Counts& assertions );
        -:10535:
        -:10536:        void assertionEnded( AssertionResult&& result );
        -:10537:        void reportExpr
        -:10538:                (   AssertionInfo const &info,
        -:10539:                    ResultWas::OfType resultType,
        -:10540:                    ITransientExpression const *expr,
        -:10541:                    bool negated );
        -:10542:
        -:10543:        void populateReaction( AssertionReaction& reaction );
        -:10544:
        -:10545:    private:
        -:10546:
        -:10547:        void handleUnfinishedSections();
        -:10548:
        -:10549:        TestRunInfo m_runInfo;
        -:10550:        TestCaseHandle const* m_activeTestCase = nullptr;
        -:10551:        ITracker* m_testCaseTracker = nullptr;
        -:10552:        Optional<AssertionResult> m_lastResult;
        -:10553:
        -:10554:        IConfig const* m_config;
        -:10555:        Totals m_totals;
        -:10556:        IEventListenerPtr m_reporter;
        -:10557:        std::vector<MessageInfo> m_messages;
        -:10558:        std::vector<ScopedMessage> m_messageScopes; /* Keeps owners of so-called unscoped messages. */
        -:10559:        AssertionInfo m_lastAssertionInfo;
        -:10560:        std::vector<SectionEndInfo> m_unfinishedSections;
        -:10561:        std::vector<ITracker*> m_activeSections;
        -:10562:        TrackerContext m_trackerContext;
        -:10563:        FatalConditionHandler m_fatalConditionhandler;
        -:10564:        bool m_lastAssertionPassed = false;
        -:10565:        bool m_shouldReportUnexpected = true;
        -:10566:        bool m_includeSuccessfulResults;
        -:10567:    };
        -:10568:
        -:10569:    void seedRng(IConfig const& config);
        -:10570:    unsigned int rngSeed();
        -:10571:} // end namespace Catch
        -:10572:
        -:10573:#endif // CATCH_RUN_CONTEXT_HPP_INCLUDED
        -:10574:
        -:10575:
        -:10576:#ifndef CATCH_SHARDING_HPP_INCLUDED
        -:10577:#define CATCH_SHARDING_HPP_INCLUDED
        -:10578:
        -:10579:#include <cassert>
        -:10580:#include <cmath>
        -:10581:#include <algorithm>
        -:10582:
        -:10583:namespace Catch {
        -:10584:
        -:10585:    template<typename Container>
        -:10586:    Container createShard(Container const& container, std::size_t const shardCount, std::size_t const shardIndex) {
        -:10587:        assert(shardCount > shardIndex);
        -:10588:
        -:10589:        if (shardCount == 1) {
        -:10590:            return container;
        -:10591:        }
        -:10592:
        -:10593:        const std::size_t totalTestCount = container.size();
        -:10594:
        -:10595:        const std::size_t shardSize = totalTestCount / shardCount;
        -:10596:        const std::size_t leftoverTests = totalTestCount % shardCount;
        -:10597:
        -:10598:        const std::size_t startIndex = shardIndex * shardSize + (std::min)(shardIndex, leftoverTests);
        -:10599:        const std::size_t endIndex = (shardIndex + 1) * shardSize + (std::min)(shardIndex + 1, leftoverTests);
        -:10600:
        -:10601:        auto startIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(startIndex));
        -:10602:        auto endIterator = std::next(container.begin(), static_cast<std::ptrdiff_t>(endIndex));
        -:10603:
        -:10604:        return Container(startIterator, endIterator);
        -:10605:    }
        -:10606:
        -:10607:}
        -:10608:
        -:10609:#endif // CATCH_SHARDING_HPP_INCLUDED
        -:10610:
        -:10611:
        -:10612:#ifndef CATCH_SINGLETONS_HPP_INCLUDED
        -:10613:#define CATCH_SINGLETONS_HPP_INCLUDED
        -:10614:
        -:10615:namespace Catch {
        -:10616:
        -:10617:    struct ISingleton {
        -:10618:        virtual ~ISingleton(); // = default
        -:10619:    };
        -:10620:
        -:10621:
        -:10622:    void addSingleton( ISingleton* singleton );
        -:10623:    void cleanupSingletons();
        -:10624:
        -:10625:
        -:10626:    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>
        -:10627:    class Singleton : SingletonImplT, public ISingleton {
        -:10628:
        -:10629:        static auto getInternal() -> Singleton* {
        -:10630:            static Singleton* s_instance = nullptr;
        -:10631:            if( !s_instance ) {
        -:10632:                s_instance = new Singleton;
        -:10633:                addSingleton( s_instance );
        -:10634:            }
        -:10635:            return s_instance;
        -:10636:        }
        -:10637:
        -:10638:    public:
        -:10639:        static auto get() -> InterfaceT const& {
        -:10640:            return *getInternal();
        -:10641:        }
        -:10642:        static auto getMutable() -> MutableInterfaceT& {
        -:10643:            return *getInternal();
        -:10644:        }
        -:10645:    };
        -:10646:
        -:10647:} // namespace Catch
        -:10648:
        -:10649:#endif // CATCH_SINGLETONS_HPP_INCLUDED
        -:10650:
        -:10651:
        -:10652:#ifndef CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -:10653:#define CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -:10654:
        -:10655:
        -:10656:#include <vector>
        -:10657:#include <exception>
        -:10658:
        -:10659:namespace Catch {
        -:10660:
        -:10661:    class StartupExceptionRegistry {
        -:10662:#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
        -:10663:    public:
        -:10664:        void add(std::exception_ptr const& exception) noexcept;
        -:10665:        std::vector<std::exception_ptr> const& getExceptions() const noexcept;
        -:10666:    private:
        -:10667:        std::vector<std::exception_ptr> m_exceptions;
        -:10668:#endif
        -:10669:    };
        -:10670:
        -:10671:} // end namespace Catch
        -:10672:
        -:10673:#endif // CATCH_STARTUP_EXCEPTION_REGISTRY_HPP_INCLUDED
        -:10674:
        -:10675:
        -:10676:
        -:10677:#ifndef CATCH_STDSTREAMS_HPP_INCLUDED
        -:10678:#define CATCH_STDSTREAMS_HPP_INCLUDED
        -:10679:
        -:10680:#include <iosfwd>
        -:10681:
        -:10682:namespace Catch {
        -:10683:
        -:10684:    std::ostream& cout();
        -:10685:    std::ostream& cerr();
        -:10686:    std::ostream& clog();
        -:10687:
        -:10688:} // namespace Catch
        -:10689:
        -:10690:#endif
        -:10691:
        -:10692:
        -:10693:#ifndef CATCH_STRING_MANIP_HPP_INCLUDED
        -:10694:#define CATCH_STRING_MANIP_HPP_INCLUDED
        -:10695:
        -:10696:
        -:10697:#include <cstdint>
        -:10698:#include <string>
        -:10699:#include <iosfwd>
        -:10700:#include <vector>
        -:10701:
        -:10702:namespace Catch {
        -:10703:
        -:10704:    bool startsWith( std::string const& s, std::string const& prefix );
        -:10705:    bool startsWith( StringRef s, char prefix );
        -:10706:    bool endsWith( std::string const& s, std::string const& suffix );
        -:10707:    bool endsWith( std::string const& s, char suffix );
        -:10708:    bool contains( std::string const& s, std::string const& infix );
        -:10709:    void toLowerInPlace( std::string& s );
        -:10710:    std::string toLower( std::string const& s );
        -:10711:    char toLower( char c );
        -:10712:    //! Returns a new string without whitespace at the start/end
        -:10713:    std::string trim( std::string const& str );
        -:10714:    //! Returns a substring of the original ref without whitespace. Beware lifetimes!
        -:10715:    StringRef trim(StringRef ref);
        -:10716:
        -:10717:    // !!! Be aware, returns refs into original string - make sure original string outlives them
        -:10718:    std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
        -:10719:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
        -:10720:
        -:10721:    /**
        -:10722:     * Helper for streaming a "count [maybe-plural-of-label]" human-friendly string
        -:10723:     *
        -:10724:     * Usage example:
        -:10725:     * ```cpp
        -:10726:     * std::cout << "Found " << pluralise(count, "error") << '\n';
        -:10727:     * ```
        -:10728:     *
        -:10729:     * **Important:** The provided string must outlive the instance
        -:10730:     */
        -:10731:    class pluralise {
        -:10732:        std::uint64_t m_count;
        -:10733:        StringRef m_label;
        -:10734:
        -:10735:    public:
        -:10736:        constexpr pluralise(std::uint64_t count, StringRef label):
        -:10737:            m_count(count),
        -:10738:            m_label(label)
        -:10739:        {}
        -:10740:
        -:10741:        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
        -:10742:    };
        -:10743:}
        -:10744:
        -:10745:#endif // CATCH_STRING_MANIP_HPP_INCLUDED
        -:10746:
        -:10747:
        -:10748:#ifndef CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -:10749:#define CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -:10750:
        -:10751:
        -:10752:#include <map>
        -:10753:#include <string>
        -:10754:
        -:10755:namespace Catch {
        -:10756:    struct SourceLineInfo;
        -:10757:
        -:10758:    class TagAliasRegistry : public ITagAliasRegistry {
        -:10759:    public:
        -:10760:        ~TagAliasRegistry() override;
        -:10761:        TagAlias const* find( std::string const& alias ) const override;
        -:10762:        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
        -:10763:        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
        -:10764:
        -:10765:    private:
        -:10766:        std::map<std::string, TagAlias> m_registry;
        -:10767:    };
        -:10768:
        -:10769:} // end namespace Catch
        -:10770:
        -:10771:#endif // CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -:10772:
        -:10773:
        -:10774:#ifndef CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED
        -:10775:#define CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED
        -:10776:
        -:10777:#include <cstdint>
        -:10778:
        -:10779:namespace Catch {
        -:10780:
        -:10781:    struct TestCaseInfo;
        -:10782:
        -:10783:    class TestCaseInfoHasher {
        -:10784:    public:
        -:10785:        using hash_t = std::uint64_t;
        -:10786:        TestCaseInfoHasher( hash_t seed );
        -:10787:        uint32_t operator()( TestCaseInfo const& t ) const;
        -:10788:
        -:10789:    private:
        -:10790:        hash_t m_seed;
        -:10791:    };
        -:10792:
        -:10793:} // namespace Catch
        -:10794:
        -:10795:#endif /* CATCH_TEST_CASE_INFO_HASHER_HPP_INCLUDED */
        -:10796:
        -:10797:
        -:10798:#ifndef CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -:10799:#define CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -:10800:
        -:10801:
        -:10802:#include <vector>
        -:10803:
        -:10804:namespace Catch {
        -:10805:
        -:10806:    class IConfig;
        -:10807:    class ITestInvoker;
        -:10808:    class TestCaseHandle;
        -:10809:    class TestSpec;
        -:10810:
        -:10811:    std::vector<TestCaseHandle> sortTests( IConfig const& config, std::vector<TestCaseHandle> const& unsortedTestCases );
        -:10812:
        -:10813:    bool isThrowSafe( TestCaseHandle const& testCase, IConfig const& config );
        -:10814:
        -:10815:    std::vector<TestCaseHandle> filterTests( std::vector<TestCaseHandle> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -:10816:    std::vector<TestCaseHandle> const& getAllTestCasesSorted( IConfig const& config );
        -:10817:
        -:10818:    class TestRegistry : public ITestCaseRegistry {
        -:10819:    public:
        -:10820:        void registerTest( Detail::unique_ptr<TestCaseInfo> testInfo, Detail::unique_ptr<ITestInvoker> testInvoker );
        -:10821:
        -:10822:        std::vector<TestCaseInfo*> const& getAllInfos() const override;
        -:10823:        std::vector<TestCaseHandle> const& getAllTests() const override;
        -:10824:        std::vector<TestCaseHandle> const& getAllTestsSorted( IConfig const& config ) const override;
        -:10825:
        -:10826:    private:
        -:10827:        std::vector<Detail::unique_ptr<TestCaseInfo>> m_owned_test_infos;
        -:10828:        // Keeps a materialized vector for `getAllInfos`.
        -:10829:        // We should get rid of that eventually (see interface note)
        -:10830:        std::vector<TestCaseInfo*> m_viewed_test_infos;
        -:10831:
        -:10832:        std::vector<Detail::unique_ptr<ITestInvoker>> m_invokers;
        -:10833:        std::vector<TestCaseHandle> m_handles;
        -:10834:        mutable TestRunOrder m_currentSortOrder = TestRunOrder::Declared;
        -:10835:        mutable std::vector<TestCaseHandle> m_sortedFunctions;
        -:10836:    };
        -:10837:
        -:10838:    ///////////////////////////////////////////////////////////////////////////
        -:10839:
        -:10840:
        -:10841:} // end namespace Catch
        -:10842:
        -:10843:
        -:10844:#endif // CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -:10845:
        -:10846:
        -:10847:#ifndef CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -:10848:#define CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -:10849:
        -:10850:#ifdef __clang__
        -:10851:#pragma clang diagnostic push
        -:10852:#pragma clang diagnostic ignored "-Wpadded"
        -:10853:#endif
        -:10854:
        -:10855:
        -:10856:#include <vector>
        -:10857:#include <string>
        -:10858:
        -:10859:namespace Catch {
        -:10860:
        -:10861:    class ITagAliasRegistry;
        -:10862:
        -:10863:    class TestSpecParser {
        -:10864:        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        -:10865:        Mode m_mode = None;
        -:10866:        Mode lastMode = None;
        -:10867:        bool m_exclusion = false;
        -:10868:        std::size_t m_pos = 0;
        -:10869:        std::size_t m_realPatternPos = 0;
        -:10870:        std::string m_arg;
        -:10871:        std::string m_substring;
        -:10872:        std::string m_patternName;
        -:10873:        std::vector<std::size_t> m_escapeChars;
        -:10874:        TestSpec::Filter m_currentFilter;
        -:10875:        TestSpec m_testSpec;
        -:10876:        ITagAliasRegistry const* m_tagAliases = nullptr;
        -:10877:
        -:10878:    public:
        -:10879:        TestSpecParser( ITagAliasRegistry const& tagAliases );
        -:10880:
        -:10881:        TestSpecParser& parse( std::string const& arg );
        -:10882:        TestSpec testSpec();
        -:10883:
        -:10884:    private:
        -:10885:        bool visitChar( char c );
        -:10886:        void startNewMode( Mode mode );
        -:10887:        bool processNoneChar( char c );
        -:10888:        void processNameChar( char c );
        -:10889:        bool processOtherChar( char c );
        -:10890:        void endMode();
        -:10891:        void escape();
        -:10892:        bool isControlChar( char c ) const;
        -:10893:        void saveLastMode();
        -:10894:        void revertBackToLastMode();
        -:10895:        void addFilter();
        -:10896:        bool separate();
        -:10897:
        -:10898:        // Handles common preprocessing of the pattern for name/tag patterns
        -:10899:        std::string preprocessPattern();
        -:10900:        // Adds the current pattern as a test name
        -:10901:        void addNamePattern();
        -:10902:        // Adds the current pattern as a tag
        -:10903:        void addTagPattern();
        -:10904:
        -:10905:        inline void addCharToPattern(char c) {
        -:10906:            m_substring += c;
        -:10907:            m_patternName += c;
        -:10908:            m_realPatternPos++;
        -:10909:        }
        -:10910:
        -:10911:    };
        -:10912:
        -:10913:} // namespace Catch
        -:10914:
        -:10915:#ifdef __clang__
        -:10916:#pragma clang diagnostic pop
        -:10917:#endif
        -:10918:
        -:10919:#endif // CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -:10920:
        -:10921:
        -:10922:#ifndef CATCH_TEXTFLOW_HPP_INCLUDED
        -:10923:#define CATCH_TEXTFLOW_HPP_INCLUDED
        -:10924:
        -:10925:
        -:10926:#include <cassert>
        -:10927:#include <string>
        -:10928:#include <vector>
        -:10929:
        -:10930:namespace Catch {
        -:10931:    namespace TextFlow {
        -:10932:
        -:10933:        class Columns;
        -:10934:
        -:10935:        /**
        -:10936:         * Represents a column of text with specific width and indentation
        -:10937:         *
        -:10938:         * When written out to a stream, it will perform linebreaking
        -:10939:         * of the provided text so that the written lines fit within
        -:10940:         * target width.
        -:10941:         */
        -:10942:        class Column {
        -:10943:            // String to be written out
        -:10944:            std::string m_string;
        -:10945:            // Width of the column for linebreaking
        -:10946:            size_t m_width = CATCH_CONFIG_CONSOLE_WIDTH - 1;
        -:10947:            // Indentation of other lines (including first if initial indent is unset)
        -:10948:            size_t m_indent = 0;
        -:10949:            // Indentation of the first line
        -:10950:            size_t m_initialIndent = std::string::npos;
        -:10951:
        -:10952:        public:
        -:10953:            /**
        -:10954:             * Iterates "lines" in `Column` and returns them
        -:10955:             */
        -:10956:            class const_iterator {
        -:10957:                friend Column;
        -:10958:                struct EndTag {};
        -:10959:
        -:10960:                Column const& m_column;
        -:10961:                // Where does the current line start?
        -:10962:                size_t m_lineStart = 0;
        -:10963:                // How long should the current line be?
        -:10964:                size_t m_lineLength = 0;
        -:10965:                // How far have we checked the string to iterate?
        -:10966:                size_t m_parsedTo = 0;
        -:10967:                // Should a '-' be appended to the line?
        -:10968:                bool m_addHyphen = false;
        -:10969:
        -:10970:                const_iterator( Column const& column, EndTag ):
        -:10971:                    m_column( column ), m_lineStart( m_column.m_string.size() ) {}
        -:10972:
        -:10973:                // Calculates the length of the current line
        -:10974:                void calcLength();
        -:10975:
        -:10976:                // Returns current indentation width
        -:10977:                size_t indentSize() const;
        -:10978:
        -:10979:                // Creates an indented and (optionally) suffixed string from
        -:10980:                // current iterator position, indentation and length.
        -:10981:                std::string addIndentAndSuffix( size_t position,
        -:10982:                                                size_t length ) const;
        -:10983:
        -:10984:            public:
        -:10985:                using difference_type = std::ptrdiff_t;
        -:10986:                using value_type = std::string;
        -:10987:                using pointer = value_type*;
        -:10988:                using reference = value_type&;
        -:10989:                using iterator_category = std::forward_iterator_tag;
        -:10990:
        -:10991:                explicit const_iterator( Column const& column );
        -:10992:
        -:10993:                std::string operator*() const;
        -:10994:
        -:10995:                const_iterator& operator++();
        -:10996:                const_iterator operator++( int );
        -:10997:
        -:10998:                bool operator==( const_iterator const& other ) const {
        -:10999:                    return m_lineStart == other.m_lineStart && &m_column == &other.m_column;
        -:11000:                }
        -:11001:                bool operator!=( const_iterator const& other ) const {
        -:11002:                    return !operator==( other );
        -:11003:                }
        -:11004:            };
        -:11005:            using iterator = const_iterator;
        -:11006:
        -:11007:            explicit Column( std::string const& text ): m_string( text ) {}
        -:11008:            explicit Column( std::string&& text ):
        -:11009:                m_string( CATCH_MOVE(text)) {}
        -:11010:
        -:11011:            Column& width( size_t newWidth ) & {
        -:11012:                assert( newWidth > 0 );
        -:11013:                m_width = newWidth;
        -:11014:                return *this;
        -:11015:            }
        -:11016:            Column&& width( size_t newWidth ) && {
        -:11017:                assert( newWidth > 0 );
        -:11018:                m_width = newWidth;
        -:11019:                return CATCH_MOVE( *this );
        -:11020:            }
        -:11021:            Column& indent( size_t newIndent ) & {
        -:11022:                m_indent = newIndent;
        -:11023:                return *this;
        -:11024:            }
        -:11025:            Column&& indent( size_t newIndent ) && {
        -:11026:                m_indent = newIndent;
        -:11027:                return CATCH_MOVE( *this );
        -:11028:            }
        -:11029:            Column& initialIndent( size_t newIndent ) & {
        -:11030:                m_initialIndent = newIndent;
        -:11031:                return *this;
        -:11032:            }
        -:11033:            Column&& initialIndent( size_t newIndent ) && {
        -:11034:                m_initialIndent = newIndent;
        -:11035:                return CATCH_MOVE( *this );
        -:11036:            }
        -:11037:
        -:11038:            size_t width() const { return m_width; }
        -:11039:            const_iterator begin() const { return const_iterator( *this ); }
        -:11040:            const_iterator end() const { return { *this, const_iterator::EndTag{} }; }
        -:11041:
        -:11042:            friend std::ostream& operator<<( std::ostream& os,
        -:11043:                                             Column const& col );
        -:11044:
        -:11045:            friend Columns operator+( Column const& lhs, Column const& rhs );
        -:11046:            friend Columns operator+( Column&& lhs, Column&& rhs );
        -:11047:        };
        -:11048:
        -:11049:        //! Creates a column that serves as an empty space of specific width
        -:11050:        Column Spacer( size_t spaceWidth );
        -:11051:
        -:11052:        class Columns {
        -:11053:            std::vector<Column> m_columns;
        -:11054:
        -:11055:        public:
        -:11056:            class iterator {
        -:11057:                friend Columns;
        -:11058:                struct EndTag {};
        -:11059:
        -:11060:                std::vector<Column> const& m_columns;
        -:11061:                std::vector<Column::const_iterator> m_iterators;
        -:11062:                size_t m_activeIterators;
        -:11063:
        -:11064:                iterator( Columns const& columns, EndTag );
        -:11065:
        -:11066:            public:
        -:11067:                using difference_type = std::ptrdiff_t;
        -:11068:                using value_type = std::string;
        -:11069:                using pointer = value_type*;
        -:11070:                using reference = value_type&;
        -:11071:                using iterator_category = std::forward_iterator_tag;
        -:11072:
        -:11073:                explicit iterator( Columns const& columns );
        -:11074:
        -:11075:                auto operator==( iterator const& other ) const -> bool {
        -:11076:                    return m_iterators == other.m_iterators;
        -:11077:                }
        -:11078:                auto operator!=( iterator const& other ) const -> bool {
        -:11079:                    return m_iterators != other.m_iterators;
        -:11080:                }
        -:11081:                std::string operator*() const;
        -:11082:                iterator& operator++();
        -:11083:                iterator operator++( int );
        -:11084:            };
        -:11085:            using const_iterator = iterator;
        -:11086:
        -:11087:            iterator begin() const { return iterator( *this ); }
        -:11088:            iterator end() const { return { *this, iterator::EndTag() }; }
        -:11089:
        -:11090:            friend Columns& operator+=( Columns& lhs, Column const& rhs );
        -:11091:            friend Columns& operator+=( Columns& lhs, Column&& rhs );
        -:11092:            friend Columns operator+( Columns const& lhs, Column const& rhs );
        -:11093:            friend Columns operator+( Columns&& lhs, Column&& rhs );
        -:11094:
        -:11095:            friend std::ostream& operator<<( std::ostream& os,
        -:11096:                                             Columns const& cols );
        -:11097:        };
        -:11098:
        -:11099:    } // namespace TextFlow
        -:11100:} // namespace Catch
        -:11101:#endif // CATCH_TEXTFLOW_HPP_INCLUDED
        -:11102:
        -:11103:
        -:11104:#ifndef CATCH_TO_STRING_HPP_INCLUDED
        -:11105:#define CATCH_TO_STRING_HPP_INCLUDED
        -:11106:
        -:11107:#include <string>
        -:11108:
        -:11109:
        -:11110:namespace Catch {
        -:11111:    template <typename T>
        -:11112:    std::string to_string(T const& t) {
        -:11113:#if defined(CATCH_CONFIG_CPP11_TO_STRING)
        -:11114:        return std::to_string(t);
        -:11115:#else
        -:11116:        ReusableStringStream rss;
        -:11117:        rss << t;
        -:11118:        return rss.str();
        -:11119:#endif
        -:11120:    }
        -:11121:} // end namespace Catch
        -:11122:
        -:11123:#endif // CATCH_TO_STRING_HPP_INCLUDED
        -:11124:
        -:11125:
        -:11126:#ifndef CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -:11127:#define CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -:11128:
        -:11129:namespace Catch {
        -:11130:    bool uncaught_exceptions();
        -:11131:} // end namespace Catch
        -:11132:
        -:11133:#endif // CATCH_UNCAUGHT_EXCEPTIONS_HPP_INCLUDED
        -:11134:
        -:11135:
        -:11136:#ifndef CATCH_XMLWRITER_HPP_INCLUDED
        -:11137:#define CATCH_XMLWRITER_HPP_INCLUDED
        -:11138:
        -:11139:
        -:11140:#include <iosfwd>
        -:11141:#include <vector>
        -:11142:
        -:11143:namespace Catch {
        -:11144:    enum class XmlFormatting {
        -:11145:        None = 0x00,
        -:11146:        Indent = 0x01,
        -:11147:        Newline = 0x02,
        -:11148:    };
        -:11149:
        -:11150:    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
        -:11151:    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);
        -:11152:
        -:11153:    /**
        -:11154:     * Helper for XML-encoding text (escaping angle brackets, quotes, etc)
        -:11155:     *
        -:11156:     * Note: doesn't take ownership of passed strings, and thus the
        -:11157:     *       encoded string must outlive the encoding instance.
        -:11158:     */
        -:11159:    class XmlEncode {
        -:11160:    public:
        -:11161:        enum ForWhat { ForTextNodes, ForAttributes };
        -:11162:
        -:11163:        XmlEncode( StringRef str, ForWhat forWhat = ForTextNodes );
        -:11164:
        -:11165:        void encodeTo( std::ostream& os ) const;
        -:11166:
        -:11167:        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );
        -:11168:
        -:11169:    private:
        -:11170:        StringRef m_str;
        -:11171:        ForWhat m_forWhat;
        -:11172:    };
        -:11173:
        -:11174:    class XmlWriter {
        -:11175:    public:
        -:11176:
        -:11177:        class ScopedElement {
        -:11178:        public:
        -:11179:            ScopedElement( XmlWriter* writer, XmlFormatting fmt );
        -:11180:
        -:11181:            ScopedElement( ScopedElement&& other ) noexcept;
        -:11182:            ScopedElement& operator=( ScopedElement&& other ) noexcept;
        -:11183:
        -:11184:            ~ScopedElement();
        -:11185:
        -:11186:            ScopedElement&
        -:11187:            writeText( StringRef text,
        -:11188:                       XmlFormatting fmt = XmlFormatting::Newline |
        -:11189:                                           XmlFormatting::Indent );
        -:11190:
        -:11191:            ScopedElement& writeAttribute( StringRef name,
        -:11192:                                           StringRef attribute );
        -:11193:            template <typename T,
        -:11194:                      // Without this SFINAE, this overload is a better match
        -:11195:                      // for `std::string`, `char const*`, `char const[N]` args.
        -:11196:                      // While it would still work, it would cause code bloat
        -:11197:                      // and multiple iteration over the strings
        -:11198:                      typename = typename std::enable_if_t<
        -:11199:                          !std::is_convertible<T, StringRef>::value>>
        -:11200:            ScopedElement& writeAttribute( StringRef name,
        -:11201:                                           T const& attribute ) {
        -:11202:                m_writer->writeAttribute( name, attribute );
        -:11203:                return *this;
        -:11204:            }
        -:11205:
        -:11206:        private:
        -:11207:            XmlWriter* m_writer = nullptr;
        -:11208:            XmlFormatting m_fmt;
        -:11209:        };
        -:11210:
        -:11211:        XmlWriter( std::ostream& os );
        -:11212:        ~XmlWriter();
        -:11213:
        -:11214:        XmlWriter( XmlWriter const& ) = delete;
        -:11215:        XmlWriter& operator=( XmlWriter const& ) = delete;
        -:11216:
        -:11217:        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -:11218:
        -:11219:        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -:11220:
        -:11221:        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
        -:11222:
        -:11223:        //! The attribute content is XML-encoded
        -:11224:        XmlWriter& writeAttribute( StringRef name, StringRef attribute );
        -:11225:
        -:11226:        //! Writes the attribute as "true/false"
        -:11227:        XmlWriter& writeAttribute( StringRef name, bool attribute );
        -:11228:
        -:11229:        //! The attribute content is XML-encoded
        -:11230:        XmlWriter& writeAttribute( StringRef name, char const* attribute );
        -:11231:
        -:11232:        //! The attribute value must provide op<<(ostream&, T). The resulting
        -:11233:        //! serialization is XML-encoded
        -:11234:        template <typename T,
        -:11235:                  // Without this SFINAE, this overload is a better match
        -:11236:                  // for `std::string`, `char const*`, `char const[N]` args.
        -:11237:                  // While it would still work, it would cause code bloat
        -:11238:                  // and multiple iteration over the strings
        -:11239:                  typename = typename std::enable_if_t<
        -:11240:                      !std::is_convertible<T, StringRef>::value>>
        -:11241:        XmlWriter& writeAttribute( StringRef name, T const& attribute ) {
        -:11242:            ReusableStringStream rss;
        -:11243:            rss << attribute;
        -:11244:            return writeAttribute( name, rss.str() );
        -:11245:        }
        -:11246:
        -:11247:        //! Writes escaped `text` in a element
        -:11248:        XmlWriter& writeText( StringRef text,
        -:11249:                              XmlFormatting fmt = XmlFormatting::Newline |
        -:11250:                                                  XmlFormatting::Indent );
        -:11251:
        -:11252:        //! Writes XML comment as "<!-- text -->"
        -:11253:        XmlWriter& writeComment( StringRef text,
        -:11254:                                 XmlFormatting fmt = XmlFormatting::Newline |
        -:11255:                                                     XmlFormatting::Indent );
        -:11256:
        -:11257:        void writeStylesheetRef( StringRef url );
        -:11258:
        -:11259:        void ensureTagClosed();
        -:11260:
        -:11261:    private:
        -:11262:
        -:11263:        void applyFormatting(XmlFormatting fmt);
        -:11264:
        -:11265:        void writeDeclaration();
        -:11266:
        -:11267:        void newlineIfNecessary();
        -:11268:
        -:11269:        bool m_tagIsOpen = false;
        -:11270:        bool m_needsNewline = false;
        -:11271:        std::vector<std::string> m_tags;
        -:11272:        std::string m_indent;
        -:11273:        std::ostream& m_os;
        -:11274:    };
        -:11275:
        -:11276:}
        -:11277:
        -:11278:#endif // CATCH_XMLWRITER_HPP_INCLUDED
        -:11279:
        -:11280:
        -:11281:/** \file
        -:11282: * This is a convenience header for Catch2's Matcher support. It includes
        -:11283: * **all** of Catch2 headers related to matchers.
        -:11284: *
        -:11285: * Generally the Catch2 users should use specific includes they need,
        -:11286: * but this header can be used instead for ease-of-experimentation, or
        -:11287: * just plain convenience, at the cost of increased compilation times.
        -:11288: *
        -:11289: * When a new header is added to either the `matchers` folder, or to
        -:11290: * the corresponding internal subfolder, it should be added here.
        -:11291: */
        -:11292:
        -:11293:#ifndef CATCH_MATCHERS_ALL_HPP_INCLUDED
        -:11294:#define CATCH_MATCHERS_ALL_HPP_INCLUDED
        -:11295:
        -:11296:
        -:11297:
        -:11298:#ifndef CATCH_MATCHERS_HPP_INCLUDED
        -:11299:#define CATCH_MATCHERS_HPP_INCLUDED
        -:11300:
        -:11301:
        -:11302:
        -:11303:#ifndef CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -:11304:#define CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -:11305:
        -:11306:
        -:11307:#include <string>
        -:11308:
        -:11309:namespace Catch {
        -:11310:
        -:11311:    template<typename ArgT, typename MatcherT>
        -:11312:    class MatchExpr : public ITransientExpression {
        -:11313:        ArgT && m_arg;
        -:11314:        MatcherT const& m_matcher;
        -:11315:    public:
        -:11316:        MatchExpr( ArgT && arg, MatcherT const& matcher )
        -:11317:        :   ITransientExpression{ true, matcher.match( arg ) }, // not forwarding arg here on purpose
        -:11318:            m_arg( CATCH_FORWARD(arg) ),
        -:11319:            m_matcher( matcher )
        -:11320:        {}
        -:11321:
        -:11322:        void streamReconstructedExpression( std::ostream& os ) const override {
        -:11323:            os << Catch::Detail::stringify( m_arg )
        -:11324:               << ' '
        -:11325:               << m_matcher.toString();
        -:11326:        }
        -:11327:    };
        -:11328:
        -:11329:    namespace Matchers {
        -:11330:        template <typename ArgT>
        -:11331:        class MatcherBase;
        -:11332:    }
        -:11333:
        -:11334:    using StringMatcher = Matchers::MatcherBase<std::string>;
        -:11335:
        -:11336:    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher );
        -:11337:
        -:11338:    template<typename ArgT, typename MatcherT>
        -:11339:    auto makeMatchExpr( ArgT && arg, MatcherT const& matcher ) -> MatchExpr<ArgT, MatcherT> {
        -:11340:        return MatchExpr<ArgT, MatcherT>( CATCH_FORWARD(arg), matcher );
        -:11341:    }
        -:11342:
        -:11343:} // namespace Catch
        -:11344:
        -:11345:
        -:11346:///////////////////////////////////////////////////////////////////////////////
        -:11347:#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
        -:11348:    do { \
        -:11349:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -:11350:        INTERNAL_CATCH_TRY { \
        -:11351:            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher ) ); \
        -:11352:        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
        -:11353:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -:11354:    } while( false )
        -:11355:
        -:11356:
        -:11357:///////////////////////////////////////////////////////////////////////////////
        -:11358:#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
        -:11359:    do { \
        -:11360:        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -:11361:        if( catchAssertionHandler.allowThrows() ) \
        -:11362:            try { \
        -:11363:                static_cast<void>(__VA_ARGS__ ); \
        -:11364:                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
        -:11365:            } \
        -:11366:            catch( exceptionType const& ex ) { \
        -:11367:                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher ) ); \
        -:11368:            } \
        -:11369:            catch( ... ) { \
        -:11370:                catchAssertionHandler.handleUnexpectedInflightException(); \
        -:11371:            } \
        -:11372:        else \
        -:11373:            catchAssertionHandler.handleThrowingCallSkipped(); \
        -:11374:        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
        -:11375:    } while( false )
        -:11376:
        -:11377:
        -:11378:#endif // CATCH_MATCHERS_IMPL_HPP_INCLUDED
        -:11379:
        -:11380:#include <string>
        -:11381:#include <vector>
        -:11382:
        -:11383:namespace Catch {
        -:11384:namespace Matchers {
        -:11385:
        -:11386:    class MatcherUntypedBase {
        -:11387:    public:
        -:11388:        MatcherUntypedBase() = default;
        -:11389:
        -:11390:        MatcherUntypedBase(MatcherUntypedBase const&) = default;
        -:11391:        MatcherUntypedBase(MatcherUntypedBase&&) = default;
        -:11392:
        -:11393:        MatcherUntypedBase& operator = (MatcherUntypedBase const&) = delete;
        -:11394:        MatcherUntypedBase& operator = (MatcherUntypedBase&&) = delete;
        -:11395:
        -:11396:        std::string toString() const;
        -:11397:
        -:11398:    protected:
        -:11399:        virtual ~MatcherUntypedBase(); // = default;
        -:11400:        virtual std::string describe() const = 0;
        -:11401:        mutable std::string m_cachedToString;
        -:11402:    };
        -:11403:
        -:11404:
        -:11405:    template<typename T>
        -:11406:    class MatcherBase : public MatcherUntypedBase {
        -:11407:    public:
        -:11408:        virtual bool match( T const& arg ) const = 0;
        -:11409:    };
        -:11410:
        -:11411:    namespace Detail {
        -:11412:
        -:11413:        template<typename ArgT>
        -:11414:        class MatchAllOf final : public MatcherBase<ArgT> {
        -:11415:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -:11416:
        -:11417:        public:
        -:11418:            MatchAllOf() = default;
        -:11419:            MatchAllOf(MatchAllOf const&) = delete;
        -:11420:            MatchAllOf& operator=(MatchAllOf const&) = delete;
        -:11421:            MatchAllOf(MatchAllOf&&) = default;
        -:11422:            MatchAllOf& operator=(MatchAllOf&&) = default;
        -:11423:
        -:11424:
        -:11425:            bool match( ArgT const& arg ) const override {
        -:11426:                for( auto matcher : m_matchers ) {
        -:11427:                    if (!matcher->match(arg))
        -:11428:                        return false;
        -:11429:                }
        -:11430:                return true;
        -:11431:            }
        -:11432:            std::string describe() const override {
        -:11433:                std::string description;
        -:11434:                description.reserve( 4 + m_matchers.size()*32 );
        -:11435:                description += "( ";
        -:11436:                bool first = true;
        -:11437:                for( auto matcher : m_matchers ) {
        -:11438:                    if( first )
        -:11439:                        first = false;
        -:11440:                    else
        -:11441:                        description += " and ";
        -:11442:                    description += matcher->toString();
        -:11443:                }
        -:11444:                description += " )";
        -:11445:                return description;
        -:11446:            }
        -:11447:
        -:11448:            friend MatchAllOf operator&& (MatchAllOf&& lhs, MatcherBase<ArgT> const& rhs) {
        -:11449:                lhs.m_matchers.push_back(&rhs);
        -:11450:                return CATCH_MOVE(lhs);
        -:11451:            }
        -:11452:            friend MatchAllOf operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf&& rhs) {
        -:11453:                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);
        -:11454:                return CATCH_MOVE(rhs);
        -:11455:            }
        -:11456:        };
        -:11457:
        -:11458:        //! lvalue overload is intentionally deleted, users should
        -:11459:        //! not be trying to compose stored composition matchers
        -:11460:        template<typename ArgT>
        -:11461:        MatchAllOf<ArgT> operator&& (MatchAllOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;
        -:11462:        //! lvalue overload is intentionally deleted, users should
        -:11463:        //! not be trying to compose stored composition matchers
        -:11464:        template<typename ArgT>
        -:11465:        MatchAllOf<ArgT> operator&& (MatcherBase<ArgT> const& lhs, MatchAllOf<ArgT> const& rhs) = delete;
        -:11466:
        -:11467:        template<typename ArgT>
        -:11468:        class MatchAnyOf final : public MatcherBase<ArgT> {
        -:11469:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -:11470:        public:
        -:11471:            MatchAnyOf() = default;
        -:11472:            MatchAnyOf(MatchAnyOf const&) = delete;
        -:11473:            MatchAnyOf& operator=(MatchAnyOf const&) = delete;
        -:11474:            MatchAnyOf(MatchAnyOf&&) = default;
        -:11475:            MatchAnyOf& operator=(MatchAnyOf&&) = default;
        -:11476:
        -:11477:            bool match( ArgT const& arg ) const override {
        -:11478:                for( auto matcher : m_matchers ) {
        -:11479:                    if (matcher->match(arg))
        -:11480:                        return true;
        -:11481:                }
        -:11482:                return false;
        -:11483:            }
        -:11484:            std::string describe() const override {
        -:11485:                std::string description;
        -:11486:                description.reserve( 4 + m_matchers.size()*32 );
        -:11487:                description += "( ";
        -:11488:                bool first = true;
        -:11489:                for( auto matcher : m_matchers ) {
        -:11490:                    if( first )
        -:11491:                        first = false;
        -:11492:                    else
        -:11493:                        description += " or ";
        -:11494:                    description += matcher->toString();
        -:11495:                }
        -:11496:                description += " )";
        -:11497:                return description;
        -:11498:            }
        -:11499:
        -:11500:            friend MatchAnyOf operator|| (MatchAnyOf&& lhs, MatcherBase<ArgT> const& rhs) {
        -:11501:                lhs.m_matchers.push_back(&rhs);
        -:11502:                return CATCH_MOVE(lhs);
        -:11503:            }
        -:11504:            friend MatchAnyOf operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf&& rhs) {
        -:11505:                rhs.m_matchers.insert(rhs.m_matchers.begin(), &lhs);
        -:11506:                return CATCH_MOVE(rhs);
        -:11507:            }
        -:11508:        };
        -:11509:
        -:11510:        //! lvalue overload is intentionally deleted, users should
        -:11511:        //! not be trying to compose stored composition matchers
        -:11512:        template<typename ArgT>
        -:11513:        MatchAnyOf<ArgT> operator|| (MatchAnyOf<ArgT> const& lhs, MatcherBase<ArgT> const& rhs) = delete;
        -:11514:        //! lvalue overload is intentionally deleted, users should
        -:11515:        //! not be trying to compose stored composition matchers
        -:11516:        template<typename ArgT>
        -:11517:        MatchAnyOf<ArgT> operator|| (MatcherBase<ArgT> const& lhs, MatchAnyOf<ArgT> const& rhs) = delete;
        -:11518:
        -:11519:        template<typename ArgT>
        -:11520:        class MatchNotOf final : public MatcherBase<ArgT> {
        -:11521:            MatcherBase<ArgT> const& m_underlyingMatcher;
        -:11522:
        -:11523:        public:
        -:11524:            explicit MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ):
        -:11525:                m_underlyingMatcher( underlyingMatcher )
        -:11526:            {}
        -:11527:
        -:11528:            bool match( ArgT const& arg ) const override {
        -:11529:                return !m_underlyingMatcher.match( arg );
        -:11530:            }
        -:11531:
        -:11532:            std::string describe() const override {
        -:11533:                return "not " + m_underlyingMatcher.toString();
        -:11534:            }
        -:11535:        };
        -:11536:
        -:11537:    } // namespace Detail
        -:11538:
        -:11539:    template <typename T>
        -:11540:    Detail::MatchAllOf<T> operator&& (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) {
        -:11541:        return Detail::MatchAllOf<T>{} && lhs && rhs;
        -:11542:    }
        -:11543:    template <typename T>
        -:11544:    Detail::MatchAnyOf<T> operator|| (MatcherBase<T> const& lhs, MatcherBase<T> const& rhs) {
        -:11545:        return Detail::MatchAnyOf<T>{} || lhs || rhs;
        -:11546:    }
        -:11547:
        -:11548:    template <typename T>
        -:11549:    Detail::MatchNotOf<T> operator! (MatcherBase<T> const& matcher) {
        -:11550:        return Detail::MatchNotOf<T>{ matcher };
        -:11551:    }
        -:11552:
        -:11553:
        -:11554:} // namespace Matchers
        -:11555:} // namespace Catch
        -:11556:
        -:11557:
        -:11558:#if defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -:11559:  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:11560:  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -:11561:
        -:11562:  #define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11563:  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11564:
        -:11565:  #define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:11566:  #define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11567:
        -:11568:#elif defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -:11569:
        -:11570:  #define CATCH_REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)
        -:11571:  #define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:11572:
        -:11573:  #define CATCH_CHECK_THROWS_WITH( expr, matcher )                     (void)(0)
        -:11574:  #define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)
        -:11575:
        -:11576:  #define CATCH_CHECK_THAT( arg, matcher )                             (void)(0)
        -:11577:  #define CATCH_REQUIRE_THAT( arg, matcher )                           (void)(0)
        -:11578:
        -:11579:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && !defined(CATCH_CONFIG_DISABLE)
        -:11580:
        -:11581:  #define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:11582:  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
        -:11583:
        -:11584:  #define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11585:  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11586:
        -:11587:  #define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:11588:  #define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11589:
        -:11590:#elif !defined(CATCH_CONFIG_PREFIX_ALL) && defined(CATCH_CONFIG_DISABLE)
        -:11591:
        -:11592:  #define REQUIRE_THROWS_WITH( expr, matcher )                   (void)(0)
        -:11593:  #define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
        -:11594:
        -:11595:  #define CHECK_THROWS_WITH( expr, matcher )                     (void)(0)
        -:11596:  #define CHECK_THROWS_MATCHES( expr, exceptionType, matcher )   (void)(0)
        -:11597:
        -:11598:  #define CHECK_THAT( arg, matcher )                             (void)(0)
        -:11599:  #define REQUIRE_THAT( arg, matcher )                           (void)(0)
        -:11600:
        -:11601:#endif // end of user facing macro declarations
        -:11602:
        -:11603:#endif // CATCH_MATCHERS_HPP_INCLUDED
        -:11604:
        -:11605:
        -:11606:#ifndef CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -:11607:#define CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -:11608:
        -:11609:
        -:11610:
        -:11611:#ifndef CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -:11612:#define CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -:11613:
        -:11614:
        -:11615:#include <array>
        -:11616:#include <algorithm>
        -:11617:#include <string>
        -:11618:#include <type_traits>
        -:11619:
        -:11620:namespace Catch {
        -:11621:namespace Matchers {
        -:11622:    class MatcherGenericBase : public MatcherUntypedBase {
        -:11623:    public:
        -:11624:        MatcherGenericBase() = default;
        -:11625:        ~MatcherGenericBase() override; // = default;
        -:11626:
        -:11627:        MatcherGenericBase(MatcherGenericBase const&) = default;
        -:11628:        MatcherGenericBase(MatcherGenericBase&&) = default;
        -:11629:
        -:11630:        MatcherGenericBase& operator=(MatcherGenericBase const&) = delete;
        -:11631:        MatcherGenericBase& operator=(MatcherGenericBase&&) = delete;
        -:11632:    };
        -:11633:
        -:11634:
        -:11635:    namespace Detail {
        -:11636:        template<std::size_t N, std::size_t M>
        -:11637:        std::array<void const*, N + M> array_cat(std::array<void const*, N> && lhs, std::array<void const*, M> && rhs) {
        -:11638:            std::array<void const*, N + M> arr{};
        -:11639:            std::copy_n(lhs.begin(), N, arr.begin());
        -:11640:            std::copy_n(rhs.begin(), M, arr.begin() + N);
        -:11641:            return arr;
        -:11642:        }
        -:11643:
        -:11644:        template<std::size_t N>
        -:11645:        std::array<void const*, N+1> array_cat(std::array<void const*, N> && lhs, void const* rhs) {
        -:11646:            std::array<void const*, N+1> arr{};
        -:11647:            std::copy_n(lhs.begin(), N, arr.begin());
        -:11648:            arr[N] = rhs;
        -:11649:            return arr;
        -:11650:        }
        -:11651:
        -:11652:        template<std::size_t N>
        -:11653:        std::array<void const*, N+1> array_cat(void const* lhs, std::array<void const*, N> && rhs) {
        -:11654:            std::array<void const*, N + 1> arr{ {lhs} };
        -:11655:            std::copy_n(rhs.begin(), N, arr.begin() + 1);
        -:11656:            return arr;
        -:11657:        }
        -:11658:
        -:11659:        template<typename T>
        -:11660:        using is_generic_matcher = std::is_base_of<
        -:11661:            Catch::Matchers::MatcherGenericBase,
        -:11662:            std::remove_cv_t<std::remove_reference_t<T>>
        -:11663:        >;
        -:11664:
        -:11665:        template<typename... Ts>
        -:11666:        using are_generic_matchers = Catch::Detail::conjunction<is_generic_matcher<Ts>...>;
        -:11667:
        -:11668:        template<typename T>
        -:11669:        using is_matcher = std::is_base_of<
        -:11670:            Catch::Matchers::MatcherUntypedBase,
        -:11671:            std::remove_cv_t<std::remove_reference_t<T>>
        -:11672:        >;
        -:11673:
        -:11674:
        -:11675:        template<std::size_t N, typename Arg>
        -:11676:        bool match_all_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) {
        -:11677:            return true;
        -:11678:        }
        -:11679:
        -:11680:        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>
        -:11681:        bool match_all_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) {
        -:11682:            return static_cast<T const*>(matchers[Idx])->match(arg) && match_all_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>{});
        -:11683:        }
        -:11684:
        -:11685:
        -:11686:        template<std::size_t N, typename Arg>
        -:11687:        bool match_any_of(Arg&&, std::array<void const*, N> const&, std::index_sequence<>) {
        -:11688:            return false;
        -:11689:        }
        -:11690:
        -:11691:        template<typename T, typename... MatcherTs, std::size_t N, typename Arg, std::size_t Idx, std::size_t... Indices>
        -:11692:        bool match_any_of(Arg&& arg, std::array<void const*, N> const& matchers, std::index_sequence<Idx, Indices...>) {
        -:11693:            return static_cast<T const*>(matchers[Idx])->match(arg) || match_any_of<MatcherTs...>(arg, matchers, std::index_sequence<Indices...>{});
        -:11694:        }
        -:11695:
        -:11696:        std::string describe_multi_matcher(StringRef combine, std::string const* descriptions_begin, std::string const* descriptions_end);
        -:11697:
        -:11698:        template<typename... MatcherTs, std::size_t... Idx>
        -:11699:        std::string describe_multi_matcher(StringRef combine, std::array<void const*, sizeof...(MatcherTs)> const& matchers, std::index_sequence<Idx...>) {
        -:11700:            std::array<std::string, sizeof...(MatcherTs)> descriptions {{
        -:11701:                static_cast<MatcherTs const*>(matchers[Idx])->toString()...
        -:11702:            }};
        -:11703:
        -:11704:            return describe_multi_matcher(combine, descriptions.data(), descriptions.data() + descriptions.size());
        -:11705:        }
        -:11706:
        -:11707:
        -:11708:        template<typename... MatcherTs>
        -:11709:        class MatchAllOfGeneric final : public MatcherGenericBase {
        -:11710:        public:
        -:11711:            MatchAllOfGeneric(MatchAllOfGeneric const&) = delete;
        -:11712:            MatchAllOfGeneric& operator=(MatchAllOfGeneric const&) = delete;
        -:11713:            MatchAllOfGeneric(MatchAllOfGeneric&&) = default;
        -:11714:            MatchAllOfGeneric& operator=(MatchAllOfGeneric&&) = default;
        -:11715:
        -:11716:            MatchAllOfGeneric(MatcherTs const&... matchers) : m_matchers{ {std::addressof(matchers)...} } {}
        -:11717:            explicit MatchAllOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers{matchers} {}
        -:11718:
        -:11719:            template<typename Arg>
        -:11720:            bool match(Arg&& arg) const {
        -:11721:                return match_all_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -:11722:            }
        -:11723:
        -:11724:            std::string describe() const override {
        -:11725:                return describe_multi_matcher<MatcherTs...>(" and "_sr, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -:11726:            }
        -:11727:
        -:11728:            // Has to be public to enable the concatenating operators
        -:11729:            // below, because they are not friend of the RHS, only LHS,
        -:11730:            // and thus cannot access private fields of RHS
        -:11731:            std::array<void const*, sizeof...( MatcherTs )> m_matchers;
        -:11732:
        -:11733:
        -:11734:            //! Avoids type nesting for `GenericAllOf && GenericAllOf` case
        -:11735:            template<typename... MatchersRHS>
        -:11736:            friend
        -:11737:            MatchAllOfGeneric<MatcherTs..., MatchersRHS...> operator && (
        -:11738:                    MatchAllOfGeneric<MatcherTs...>&& lhs,
        -:11739:                    MatchAllOfGeneric<MatchersRHS...>&& rhs) {
        -:11740:                return MatchAllOfGeneric<MatcherTs..., MatchersRHS...>{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))};
        -:11741:            }
        -:11742:
        -:11743:            //! Avoids type nesting for `GenericAllOf && some matcher` case
        -:11744:            template<typename MatcherRHS>
        -:11745:            friend std::enable_if_t<is_matcher<MatcherRHS>::value,
        -:11746:            MatchAllOfGeneric<MatcherTs..., MatcherRHS>> operator && (
        -:11747:                    MatchAllOfGeneric<MatcherTs...>&& lhs,
        -:11748:                    MatcherRHS const& rhs) {
        -:11749:                return MatchAllOfGeneric<MatcherTs..., MatcherRHS>{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(&rhs))};
        -:11750:            }
        -:11751:
        -:11752:            //! Avoids type nesting for `some matcher && GenericAllOf` case
        -:11753:            template<typename MatcherLHS>
        -:11754:            friend std::enable_if_t<is_matcher<MatcherLHS>::value,
        -:11755:            MatchAllOfGeneric<MatcherLHS, MatcherTs...>> operator && (
        -:11756:                    MatcherLHS const& lhs,
        -:11757:                    MatchAllOfGeneric<MatcherTs...>&& rhs) {
        -:11758:                return MatchAllOfGeneric<MatcherLHS, MatcherTs...>{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))};
        -:11759:            }
        -:11760:        };
        -:11761:
        -:11762:
        -:11763:        template<typename... MatcherTs>
        -:11764:        class MatchAnyOfGeneric final : public MatcherGenericBase {
        -:11765:        public:
        -:11766:            MatchAnyOfGeneric(MatchAnyOfGeneric const&) = delete;
        -:11767:            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric const&) = delete;
        -:11768:            MatchAnyOfGeneric(MatchAnyOfGeneric&&) = default;
        -:11769:            MatchAnyOfGeneric& operator=(MatchAnyOfGeneric&&) = default;
        -:11770:
        -:11771:            MatchAnyOfGeneric(MatcherTs const&... matchers) : m_matchers{ {std::addressof(matchers)...} } {}
        -:11772:            explicit MatchAnyOfGeneric(std::array<void const*, sizeof...(MatcherTs)> matchers) : m_matchers{matchers} {}
        -:11773:
        -:11774:            template<typename Arg>
        -:11775:            bool match(Arg&& arg) const {
        -:11776:                return match_any_of<MatcherTs...>(arg, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -:11777:            }
        -:11778:
        -:11779:            std::string describe() const override {
        -:11780:                return describe_multi_matcher<MatcherTs...>(" or "_sr, m_matchers, std::index_sequence_for<MatcherTs...>{});
        -:11781:            }
        -:11782:
        -:11783:
        -:11784:            // Has to be public to enable the concatenating operators
        -:11785:            // below, because they are not friend of the RHS, only LHS,
        -:11786:            // and thus cannot access private fields of RHS
        -:11787:            std::array<void const*, sizeof...( MatcherTs )> m_matchers;
        -:11788:
        -:11789:            //! Avoids type nesting for `GenericAnyOf || GenericAnyOf` case
        -:11790:            template<typename... MatchersRHS>
        -:11791:            friend MatchAnyOfGeneric<MatcherTs..., MatchersRHS...> operator || (
        -:11792:                    MatchAnyOfGeneric<MatcherTs...>&& lhs,
        -:11793:                    MatchAnyOfGeneric<MatchersRHS...>&& rhs) {
        -:11794:                return MatchAnyOfGeneric<MatcherTs..., MatchersRHS...>{array_cat(CATCH_MOVE(lhs.m_matchers), CATCH_MOVE(rhs.m_matchers))};
        -:11795:            }
        -:11796:
        -:11797:            //! Avoids type nesting for `GenericAnyOf || some matcher` case
        -:11798:            template<typename MatcherRHS>
        -:11799:            friend std::enable_if_t<is_matcher<MatcherRHS>::value,
        -:11800:            MatchAnyOfGeneric<MatcherTs..., MatcherRHS>> operator || (
        -:11801:                    MatchAnyOfGeneric<MatcherTs...>&& lhs,
        -:11802:                    MatcherRHS const& rhs) {
        -:11803:                return MatchAnyOfGeneric<MatcherTs..., MatcherRHS>{array_cat(CATCH_MOVE(lhs.m_matchers), static_cast<void const*>(std::addressof(rhs)))};
        -:11804:            }
        -:11805:
        -:11806:            //! Avoids type nesting for `some matcher || GenericAnyOf` case
        -:11807:            template<typename MatcherLHS>
        -:11808:            friend std::enable_if_t<is_matcher<MatcherLHS>::value,
        -:11809:            MatchAnyOfGeneric<MatcherLHS, MatcherTs...>> operator || (
        -:11810:                MatcherLHS const& lhs,
        -:11811:                MatchAnyOfGeneric<MatcherTs...>&& rhs) {
        -:11812:                return MatchAnyOfGeneric<MatcherLHS, MatcherTs...>{array_cat(static_cast<void const*>(std::addressof(lhs)), CATCH_MOVE(rhs.m_matchers))};
        -:11813:            }
        -:11814:        };
        -:11815:
        -:11816:
        -:11817:        template<typename MatcherT>
        -:11818:        class MatchNotOfGeneric final : public MatcherGenericBase {
        -:11819:            MatcherT const& m_matcher;
        -:11820:
        -:11821:        public:
        -:11822:            MatchNotOfGeneric(MatchNotOfGeneric const&) = delete;
        -:11823:            MatchNotOfGeneric& operator=(MatchNotOfGeneric const&) = delete;
        -:11824:            MatchNotOfGeneric(MatchNotOfGeneric&&) = default;
        -:11825:            MatchNotOfGeneric& operator=(MatchNotOfGeneric&&) = default;
        -:11826:
        -:11827:            explicit MatchNotOfGeneric(MatcherT const& matcher) : m_matcher{matcher} {}
        -:11828:
        -:11829:            template<typename Arg>
        -:11830:            bool match(Arg&& arg) const {
        -:11831:                return !m_matcher.match(arg);
        -:11832:            }
        -:11833:
        -:11834:            std::string describe() const override {
        -:11835:                return "not " + m_matcher.toString();
        -:11836:            }
        -:11837:
        -:11838:            //! Negating negation can just unwrap and return underlying matcher
        -:11839:            friend MatcherT const& operator ! (MatchNotOfGeneric<MatcherT> const& matcher) {
        -:11840:                return matcher.m_matcher;
        -:11841:            }
        -:11842:        };
        -:11843:    } // namespace Detail
        -:11844:
        -:11845:
        -:11846:    // compose only generic matchers
        -:11847:    template<typename MatcherLHS, typename MatcherRHS>
        -:11848:    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherRHS>>
        -:11849:        operator && (MatcherLHS const& lhs, MatcherRHS const& rhs) {
        -:11850:        return { lhs, rhs };
        -:11851:    }
        -:11852:
        -:11853:    template<typename MatcherLHS, typename MatcherRHS>
        -:11854:    std::enable_if_t<Detail::are_generic_matchers<MatcherLHS, MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherRHS>>
        -:11855:        operator || (MatcherLHS const& lhs, MatcherRHS const& rhs) {
        -:11856:        return { lhs, rhs };
        -:11857:    }
        -:11858:
        -:11859:    //! Wrap provided generic matcher in generic negator
        -:11860:    template<typename MatcherT>
        -:11861:    std::enable_if_t<Detail::is_generic_matcher<MatcherT>::value, Detail::MatchNotOfGeneric<MatcherT>>
        -:11862:        operator ! (MatcherT const& matcher) {
        -:11863:        return Detail::MatchNotOfGeneric<MatcherT>{matcher};
        -:11864:    }
        -:11865:
        -:11866:
        -:11867:    // compose mixed generic and non-generic matchers
        -:11868:    template<typename MatcherLHS, typename ArgRHS>
        -:11869:    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAllOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>
        -:11870:        operator && (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) {
        -:11871:        return { lhs, rhs };
        -:11872:    }
        -:11873:
        -:11874:    template<typename ArgLHS, typename MatcherRHS>
        -:11875:    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAllOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>
        -:11876:        operator && (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) {
        -:11877:        return { lhs, rhs };
        -:11878:    }
        -:11879:
        -:11880:    template<typename MatcherLHS, typename ArgRHS>
        -:11881:    std::enable_if_t<Detail::is_generic_matcher<MatcherLHS>::value, Detail::MatchAnyOfGeneric<MatcherLHS, MatcherBase<ArgRHS>>>
        -:11882:        operator || (MatcherLHS const& lhs, MatcherBase<ArgRHS> const& rhs) {
        -:11883:        return { lhs, rhs };
        -:11884:    }
        -:11885:
        -:11886:    template<typename ArgLHS, typename MatcherRHS>
        -:11887:    std::enable_if_t<Detail::is_generic_matcher<MatcherRHS>::value, Detail::MatchAnyOfGeneric<MatcherBase<ArgLHS>, MatcherRHS>>
        -:11888:        operator || (MatcherBase<ArgLHS> const& lhs, MatcherRHS const& rhs) {
        -:11889:        return { lhs, rhs };
        -:11890:    }
        -:11891:
        -:11892:} // namespace Matchers
        -:11893:} // namespace Catch
        -:11894:
        -:11895:#endif // CATCH_MATCHERS_TEMPLATED_HPP_INCLUDED
        -:11896:
        -:11897:namespace Catch {
        -:11898:    namespace Matchers {
        -:11899:
        -:11900:        class IsEmptyMatcher final : public MatcherGenericBase {
        -:11901:        public:
        -:11902:            template <typename RangeLike>
        -:11903:            bool match(RangeLike&& rng) const {
        -:11904:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -:11905:                using Catch::Detail::empty;
        -:11906:#else
        -:11907:                using std::empty;
        -:11908:#endif
        -:11909:                return empty(rng);
        -:11910:            }
        -:11911:
        -:11912:            std::string describe() const override;
        -:11913:        };
        -:11914:
        -:11915:        class HasSizeMatcher final : public MatcherGenericBase {
        -:11916:            std::size_t m_target_size;
        -:11917:        public:
        -:11918:            explicit HasSizeMatcher(std::size_t target_size):
        -:11919:                m_target_size(target_size)
        -:11920:            {}
        -:11921:
        -:11922:            template <typename RangeLike>
        -:11923:            bool match(RangeLike&& rng) const {
        -:11924:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -:11925:                using Catch::Detail::size;
        -:11926:#else
        -:11927:                using std::size;
        -:11928:#endif
        -:11929:                return size(rng) == m_target_size;
        -:11930:            }
        -:11931:
        -:11932:            std::string describe() const override;
        -:11933:        };
        -:11934:
        -:11935:        template <typename Matcher>
        -:11936:        class SizeMatchesMatcher final : public MatcherGenericBase {
        -:11937:            Matcher m_matcher;
        -:11938:        public:
        -:11939:            explicit SizeMatchesMatcher(Matcher m):
        -:11940:                m_matcher(CATCH_MOVE(m))
        -:11941:            {}
        -:11942:
        -:11943:            template <typename RangeLike>
        -:11944:            bool match(RangeLike&& rng) const {
        -:11945:#if defined(CATCH_CONFIG_POLYFILL_NONMEMBER_CONTAINER_ACCESS)
        -:11946:                using Catch::Detail::size;
        -:11947:#else
        -:11948:                using std::size;
        -:11949:#endif
        -:11950:                return m_matcher.match(size(rng));
        -:11951:            }
        -:11952:
        -:11953:            std::string describe() const override {
        -:11954:                return "size matches " + m_matcher.describe();
        -:11955:            }
        -:11956:        };
        -:11957:
        -:11958:
        -:11959:        //! Creates a matcher that accepts empty ranges/containers
        -:11960:        IsEmptyMatcher IsEmpty();
        -:11961:        //! Creates a matcher that accepts ranges/containers with specific size
        -:11962:        HasSizeMatcher SizeIs(std::size_t sz);
        -:11963:        template <typename Matcher>
        -:11964:        std::enable_if_t<Detail::is_matcher<Matcher>::value,
        -:11965:        SizeMatchesMatcher<Matcher>> SizeIs(Matcher&& m) {
        -:11966:            return SizeMatchesMatcher<Matcher>{CATCH_FORWARD(m)};
        -:11967:        }
        -:11968:
        -:11969:    } // end namespace Matchers
        -:11970:} // end namespace Catch
        -:11971:
        -:11972:#endif // CATCH_MATCHERS_CONTAINER_PROPERTIES_HPP_INCLUDED
        -:11973:
        -:11974:
        -:11975:#ifndef CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -:11976:#define CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -:11977:
        -:11978:
        -:11979:#include <algorithm>
        -:11980:#include <functional>
        -:11981:
        -:11982:namespace Catch {
        -:11983:    namespace Matchers {
        -:11984:        //! Matcher for checking that an element in range is equal to specific element
        -:11985:        template <typename T, typename Equality>
        -:11986:        class ContainsElementMatcher final : public MatcherGenericBase {
        -:11987:            T m_desired;
        -:11988:            Equality m_eq;
        -:11989:        public:
        -:11990:            template <typename T2, typename Equality2>
        -:11991:            ContainsElementMatcher(T2&& target, Equality2&& predicate):
        -:11992:                m_desired(CATCH_FORWARD(target)),
        -:11993:                m_eq(CATCH_FORWARD(predicate))
        -:11994:            {}
        -:11995:
        -:11996:            std::string describe() const override {
        -:11997:                return "contains element " + Catch::Detail::stringify(m_desired);
        -:11998:            }
        -:11999:
        -:12000:            template <typename RangeLike>
        -:12001:            bool match( RangeLike&& rng ) const {
        -:12002:                for ( auto&& elem : rng ) {
        -:12003:                    if ( m_eq( elem, m_desired ) ) { return true; }
        -:12004:                }
        -:12005:                return false;
        -:12006:            }
        -:12007:        };
        -:12008:
        -:12009:        //! Meta-matcher for checking that an element in a range matches a specific matcher
        -:12010:        template <typename Matcher>
        -:12011:        class ContainsMatcherMatcher final : public MatcherGenericBase {
        -:12012:            Matcher m_matcher;
        -:12013:        public:
        -:12014:            // Note that we do a copy+move to avoid having to SFINAE this
        -:12015:            // constructor (and also avoid some perfect forwarding failure
        -:12016:            // cases)
        -:12017:            ContainsMatcherMatcher(Matcher matcher):
        -:12018:                m_matcher(CATCH_MOVE(matcher))
        -:12019:            {}
        -:12020:
        -:12021:            template <typename RangeLike>
        -:12022:            bool match(RangeLike&& rng) const {
        -:12023:                for (auto&& elem : rng) {
        -:12024:                    if (m_matcher.match(elem)) {
        -:12025:                        return true;
        -:12026:                    }
        -:12027:                }
        -:12028:                return false;
        -:12029:            }
        -:12030:
        -:12031:            std::string describe() const override {
        -:12032:                return "contains element matching " + m_matcher.describe();
        -:12033:            }
        -:12034:        };
        -:12035:
        -:12036:        /**
        -:12037:         * Creates a matcher that checks whether a range contains a specific element.
        -:12038:         *
        -:12039:         * Uses `std::equal_to` to do the comparison
        -:12040:         */
        -:12041:        template <typename T>
        -:12042:        std::enable_if_t<!Detail::is_matcher<T>::value,
        -:12043:        ContainsElementMatcher<T, std::equal_to<>>> Contains(T&& elem) {
        -:12044:            return { CATCH_FORWARD(elem), std::equal_to<>{} };
        -:12045:        }
        -:12046:
        -:12047:        //! Creates a matcher that checks whether a range contains element matching a matcher
        -:12048:        template <typename Matcher>
        -:12049:        std::enable_if_t<Detail::is_matcher<Matcher>::value,
        -:12050:        ContainsMatcherMatcher<Matcher>> Contains(Matcher&& matcher) {
        -:12051:            return { CATCH_FORWARD(matcher) };
        -:12052:        }
        -:12053:
        -:12054:        /**
        -:12055:         * Creates a matcher that checks whether a range contains a specific element.
        -:12056:         *
        -:12057:         * Uses `eq` to do the comparisons, the element is provided on the rhs
        -:12058:         */
        -:12059:        template <typename T, typename Equality>
        -:12060:        ContainsElementMatcher<T, Equality> Contains(T&& elem, Equality&& eq) {
        -:12061:            return { CATCH_FORWARD(elem), CATCH_FORWARD(eq) };
        -:12062:        }
        -:12063:
        -:12064:    }
        -:12065:}
        -:12066:
        -:12067:#endif // CATCH_MATCHERS_CONTAINS_HPP_INCLUDED
        -:12068:
        -:12069:
        -:12070:#ifndef CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -:12071:#define CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -:12072:
        -:12073:
        -:12074:namespace Catch {
        -:12075:namespace Matchers {
        -:12076:
        -:12077:class ExceptionMessageMatcher final : public MatcherBase<std::exception> {
        -:12078:    std::string m_message;
        -:12079:public:
        -:12080:
        -:12081:    ExceptionMessageMatcher(std::string const& message):
        -:12082:        m_message(message)
        -:12083:    {}
        -:12084:
        -:12085:    bool match(std::exception const& ex) const override;
        -:12086:
        -:12087:    std::string describe() const override;
        -:12088:};
        -:12089:
        -:12090://! Creates a matcher that checks whether a std derived exception has the provided message
        -:12091:ExceptionMessageMatcher Message(std::string const& message);
        -:12092:
        -:12093:template <typename StringMatcherType>
        -:12094:class ExceptionMessageMatchesMatcher final
        -:12095:    : public MatcherBase<std::exception> {
        -:12096:    StringMatcherType m_matcher;
        -:12097:
        -:12098:public:
        -:12099:    ExceptionMessageMatchesMatcher( StringMatcherType matcher ):
        -:12100:        m_matcher( CATCH_MOVE( matcher ) ) {}
        -:12101:
        -:12102:    bool match( std::exception const& ex ) const override {
        -:12103:        return m_matcher.match( ex.what() );
        -:12104:    }
        -:12105:
        -:12106:    std::string describe() const override {
        -:12107:        return " matches \"" + m_matcher.describe() + '"';
        -:12108:    }
        -:12109:};
        -:12110:
        -:12111://! Creates a matcher that checks whether a message from an std derived
        -:12112://! exception matches a provided matcher
        -:12113:template <typename StringMatcherType>
        -:12114:ExceptionMessageMatchesMatcher<StringMatcherType>
        -:12115:MessageMatches( StringMatcherType&& matcher ) {
        -:12116:    return { CATCH_FORWARD( matcher ) };
        -:12117:}
        -:12118:
        -:12119:} // namespace Matchers
        -:12120:} // namespace Catch
        -:12121:
        -:12122:#endif // CATCH_MATCHERS_EXCEPTION_HPP_INCLUDED
        -:12123:
        -:12124:
        -:12125:#ifndef CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED
        -:12126:#define CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED
        -:12127:
        -:12128:
        -:12129:namespace Catch {
        -:12130:namespace Matchers {
        -:12131:
        -:12132:    namespace Detail {
        -:12133:        enum class FloatingPointKind : uint8_t;
        -:12134:    }
        -:12135:
        -:12136:    class  WithinAbsMatcher final : public MatcherBase<double> {
        -:12137:    public:
        -:12138:        WithinAbsMatcher(double target, double margin);
        -:12139:        bool match(double const& matchee) const override;
        -:12140:        std::string describe() const override;
        -:12141:    private:
        -:12142:        double m_target;
        -:12143:        double m_margin;
        -:12144:    };
        -:12145:
        -:12146:    //! Creates a matcher that accepts numbers within certain range of target
        -:12147:    WithinAbsMatcher WithinAbs( double target, double margin );
        -:12148:
        -:12149:
        -:12150:
        -:12151:    class WithinUlpsMatcher final : public MatcherBase<double> {
        -:12152:    public:
        -:12153:        WithinUlpsMatcher( double target,
        -:12154:                           uint64_t ulps,
        -:12155:                           Detail::FloatingPointKind baseType );
        -:12156:        bool match(double const& matchee) const override;
        -:12157:        std::string describe() const override;
        -:12158:    private:
        -:12159:        double m_target;
        -:12160:        uint64_t m_ulps;
        -:12161:        Detail::FloatingPointKind m_type;
        -:12162:    };
        -:12163:
        -:12164:    //! Creates a matcher that accepts doubles within certain ULP range of target
        -:12165:    WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
        -:12166:    //! Creates a matcher that accepts floats within certain ULP range of target
        -:12167:    WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
        -:12168:
        -:12169:
        -:12170:
        -:12171:    // Given IEEE-754 format for floats and doubles, we can assume
        -:12172:    // that float -> double promotion is lossless. Given this, we can
        -:12173:    // assume that if we do the standard relative comparison of
        -:12174:    // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
        -:12175:    // the same result if we do this for floats, as if we do this for
        -:12176:    // doubles that were promoted from floats.
        -:12177:    class WithinRelMatcher final : public MatcherBase<double> {
        -:12178:    public:
        -:12179:        WithinRelMatcher( double target, double epsilon );
        -:12180:        bool match(double const& matchee) const override;
        -:12181:        std::string describe() const override;
        -:12182:    private:
        -:12183:        double m_target;
        -:12184:        double m_epsilon;
        -:12185:    };
        -:12186:
        -:12187:    //! Creates a matcher that accepts doubles within certain relative range of target
        -:12188:    WithinRelMatcher WithinRel(double target, double eps);
        -:12189:    //! Creates a matcher that accepts doubles within 100*DBL_EPS relative range of target
        -:12190:    WithinRelMatcher WithinRel(double target);
        -:12191:    //! Creates a matcher that accepts doubles within certain relative range of target
        -:12192:    WithinRelMatcher WithinRel(float target, float eps);
        -:12193:    //! Creates a matcher that accepts floats within 100*FLT_EPS relative range of target
        -:12194:    WithinRelMatcher WithinRel(float target);
        -:12195:
        -:12196:
        -:12197:
        -:12198:    class IsNaNMatcher final : public MatcherBase<double> {
        -:12199:    public:
        -:12200:        IsNaNMatcher() = default;
        -:12201:        bool match( double const& matchee ) const override;
        -:12202:        std::string describe() const override;
        -:12203:    };
        -:12204:
        -:12205:    IsNaNMatcher IsNaN();
        -:12206:
        -:12207:} // namespace Matchers
        -:12208:} // namespace Catch
        -:12209:
        -:12210:#endif // CATCH_MATCHERS_FLOATING_POINT_HPP_INCLUDED
        -:12211:
        -:12212:
        -:12213:#ifndef CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -:12214:#define CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -:12215:
        -:12216:
        -:12217:#include <string>
        -:12218:
        -:12219:namespace Catch {
        -:12220:namespace Matchers {
        -:12221:
        -:12222:namespace Detail {
        -:12223:    std::string finalizeDescription(const std::string& desc);
        -:12224:} // namespace Detail
        -:12225:
        -:12226:template <typename T, typename Predicate>
        -:12227:class PredicateMatcher final : public MatcherBase<T> {
        -:12228:    Predicate m_predicate;
        -:12229:    std::string m_description;
        -:12230:public:
        -:12231:
        -:12232:    PredicateMatcher(Predicate&& elem, std::string const& descr)
        -:12233:        :m_predicate(CATCH_FORWARD(elem)),
        -:12234:        m_description(Detail::finalizeDescription(descr))
        -:12235:    {}
        -:12236:
        -:12237:    bool match( T const& item ) const override {
        -:12238:        return m_predicate(item);
        -:12239:    }
        -:12240:
        -:12241:    std::string describe() const override {
        -:12242:        return m_description;
        -:12243:    }
        -:12244:};
        -:12245:
        -:12246:    /**
        -:12247:     * Creates a matcher that calls delegates `match` to the provided predicate.
        -:12248:     *
        -:12249:     * The user has to explicitly specify the argument type to the matcher
        -:12250:     */
        -:12251:    template<typename T, typename Pred>
        -:12252:    PredicateMatcher<T, Pred> Predicate(Pred&& predicate, std::string const& description = "") {
        -:12253:        static_assert(is_callable<Pred(T)>::value, "Predicate not callable with argument T");
        -:12254:        static_assert(std::is_same<bool, FunctionReturnType<Pred, T>>::value, "Predicate does not return bool");
        -:12255:        return PredicateMatcher<T, Pred>(CATCH_FORWARD(predicate), description);
        -:12256:    }
        -:12257:
        -:12258:} // namespace Matchers
        -:12259:} // namespace Catch
        -:12260:
        -:12261:#endif // CATCH_MATCHERS_PREDICATE_HPP_INCLUDED
        -:12262:
        -:12263:
        -:12264:#ifndef CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED
        -:12265:#define CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED
        -:12266:
        -:12267:
        -:12268:namespace Catch {
        -:12269:    namespace Matchers {
        -:12270:        // Matcher for checking that all elements in range matches a given matcher.
        -:12271:        template <typename Matcher>
        -:12272:        class AllMatchMatcher final : public MatcherGenericBase {
        -:12273:            Matcher m_matcher;
        -:12274:        public:
        -:12275:            AllMatchMatcher(Matcher matcher):
        -:12276:                m_matcher(CATCH_MOVE(matcher))
        -:12277:            {}
        -:12278:
        -:12279:            std::string describe() const override {
        -:12280:                return "all match " + m_matcher.describe();
        -:12281:            }
        -:12282:
        -:12283:            template <typename RangeLike>
        -:12284:            bool match(RangeLike&& rng) const {
        -:12285:                for (auto&& elem : rng) {
        -:12286:                    if (!m_matcher.match(elem)) {
        -:12287:                        return false;
        -:12288:                    }
        -:12289:                }
        -:12290:                return true;
        -:12291:            }
        -:12292:        };
        -:12293:
        -:12294:        // Matcher for checking that no element in range matches a given matcher.
        -:12295:        template <typename Matcher>
        -:12296:        class NoneMatchMatcher final : public MatcherGenericBase {
        -:12297:            Matcher m_matcher;
        -:12298:        public:
        -:12299:            NoneMatchMatcher(Matcher matcher):
        -:12300:                m_matcher(CATCH_MOVE(matcher))
        -:12301:            {}
        -:12302:
        -:12303:            std::string describe() const override {
        -:12304:                return "none match " + m_matcher.describe();
        -:12305:            }
        -:12306:
        -:12307:            template <typename RangeLike>
        -:12308:            bool match(RangeLike&& rng) const {
        -:12309:                for (auto&& elem : rng) {
        -:12310:                    if (m_matcher.match(elem)) {
        -:12311:                        return false;
        -:12312:                    }
        -:12313:                }
        -:12314:                return true;
        -:12315:            }
        -:12316:        };
        -:12317:
        -:12318:        // Matcher for checking that at least one element in range matches a given matcher.
        -:12319:        template <typename Matcher>
        -:12320:        class AnyMatchMatcher final : public MatcherGenericBase {
        -:12321:            Matcher m_matcher;
        -:12322:        public:
        -:12323:            AnyMatchMatcher(Matcher matcher):
        -:12324:                m_matcher(CATCH_MOVE(matcher))
        -:12325:            {}
        -:12326:
        -:12327:            std::string describe() const override {
        -:12328:                return "any match " + m_matcher.describe();
        -:12329:            }
        -:12330:
        -:12331:            template <typename RangeLike>
        -:12332:            bool match(RangeLike&& rng) const {
        -:12333:                for (auto&& elem : rng) {
        -:12334:                    if (m_matcher.match(elem)) {
        -:12335:                        return true;
        -:12336:                    }
        -:12337:                }
        -:12338:                return false;
        -:12339:            }
        -:12340:        };
        -:12341:
        -:12342:        // Matcher for checking that all elements in range are true.
        -:12343:        class AllTrueMatcher final : public MatcherGenericBase {
        -:12344:        public:
        -:12345:            std::string describe() const override;
        -:12346:
        -:12347:            template <typename RangeLike>
        -:12348:            bool match(RangeLike&& rng) const {
        -:12349:                for (auto&& elem : rng) {
        -:12350:                    if (!elem) {
        -:12351:                        return false;
        -:12352:                    }
        -:12353:                }
        -:12354:                return true;
        -:12355:            }
        -:12356:        };
        -:12357:
        -:12358:        // Matcher for checking that no element in range is true.
        -:12359:        class NoneTrueMatcher final : public MatcherGenericBase {
        -:12360:        public:
        -:12361:            std::string describe() const override;
        -:12362:
        -:12363:            template <typename RangeLike>
        -:12364:            bool match(RangeLike&& rng) const {
        -:12365:                for (auto&& elem : rng) {
        -:12366:                    if (elem) {
        -:12367:                        return false;
        -:12368:                    }
        -:12369:                }
        -:12370:                return true;
        -:12371:            }
        -:12372:        };
        -:12373:
        -:12374:        // Matcher for checking that any element in range is true.
        -:12375:        class AnyTrueMatcher final : public MatcherGenericBase {
        -:12376:        public:
        -:12377:            std::string describe() const override;
        -:12378:
        -:12379:            template <typename RangeLike>
        -:12380:            bool match(RangeLike&& rng) const {
        -:12381:                for (auto&& elem : rng) {
        -:12382:                    if (elem) {
        -:12383:                        return true;
        -:12384:                    }
        -:12385:                }
        -:12386:                return false;
        -:12387:            }
        -:12388:        };
        -:12389:
        -:12390:        // Creates a matcher that checks whether all elements in a range match a matcher
        -:12391:        template <typename Matcher>
        -:12392:        AllMatchMatcher<Matcher> AllMatch(Matcher&& matcher) {
        -:12393:            return { CATCH_FORWARD(matcher) };
        -:12394:        }
        -:12395:
        -:12396:        // Creates a matcher that checks whether no element in a range matches a matcher.
        -:12397:        template <typename Matcher>
        -:12398:        NoneMatchMatcher<Matcher> NoneMatch(Matcher&& matcher) {
        -:12399:            return { CATCH_FORWARD(matcher) };
        -:12400:        }
        -:12401:
        -:12402:        // Creates a matcher that checks whether any element in a range matches a matcher.
        -:12403:        template <typename Matcher>
        -:12404:        AnyMatchMatcher<Matcher> AnyMatch(Matcher&& matcher) {
        -:12405:            return { CATCH_FORWARD(matcher) };
        -:12406:        }
        -:12407:
        -:12408:        // Creates a matcher that checks whether all elements in a range are true
        -:12409:        AllTrueMatcher AllTrue();
        -:12410:
        -:12411:        // Creates a matcher that checks whether no element in a range is true
        -:12412:        NoneTrueMatcher NoneTrue();
        -:12413:
        -:12414:        // Creates a matcher that checks whether any element in a range is true
        -:12415:        AnyTrueMatcher AnyTrue();
        -:12416:    }
        -:12417:}
        -:12418:
        -:12419:#endif // CATCH_MATCHERS_QUANTIFIERS_HPP_INCLUDED
        -:12420:
        -:12421:
        -:12422:#ifndef CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED
        -:12423:#define CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED
        -:12424:
        -:12425:
        -:12426:#include <algorithm>
        -:12427:#include <utility>
        -:12428:
        -:12429:namespace Catch {
        -:12430:    namespace Matchers {
        -:12431:
        -:12432:        /**
        -:12433:         * Matcher for checking that an element contains the same
        -:12434:         * elements in the same order
        -:12435:         */
        -:12436:        template <typename TargetRangeLike, typename Equality>
        -:12437:        class RangeEqualsMatcher final : public MatcherGenericBase {
        -:12438:            TargetRangeLike m_desired;
        -:12439:            Equality m_predicate;
        -:12440:
        -:12441:        public:
        -:12442:            template <typename TargetRangeLike2, typename Equality2>
        -:12443:            RangeEqualsMatcher( TargetRangeLike2&& range,
        -:12444:                                Equality2&& predicate ):
        -:12445:                m_desired( CATCH_FORWARD( range ) ),
        -:12446:                m_predicate( CATCH_FORWARD( predicate ) ) {}
        -:12447:
        -:12448:            template <typename RangeLike>
        -:12449:            bool match( RangeLike&& rng ) const {
        -:12450:                auto rng_start = begin( rng );
        -:12451:                const auto rng_end = end( rng );
        -:12452:                auto target_start = begin( m_desired );
        -:12453:                const auto target_end = end( m_desired );
        -:12454:
        -:12455:                while (rng_start != rng_end && target_start != target_end) {
        -:12456:                    if (!m_predicate(*rng_start, *target_start)) {
        -:12457:                        return false;
        -:12458:                    }
        -:12459:                    ++rng_start;
        -:12460:                    ++target_start;
        -:12461:                }
        -:12462:                return rng_start == rng_end && target_start == target_end;
        -:12463:            }
        -:12464:
        -:12465:            std::string describe() const override {
        -:12466:                return "elements are " + Catch::Detail::stringify( m_desired );
        -:12467:            }
        -:12468:        };
        -:12469:
        -:12470:        /**
        -:12471:         * Matcher for checking that an element contains the same
        -:12472:         * elements (but not necessarily in the same order)
        -:12473:         */
        -:12474:        template <typename TargetRangeLike, typename Equality>
        -:12475:        class UnorderedRangeEqualsMatcher final : public MatcherGenericBase {
        -:12476:            TargetRangeLike m_desired;
        -:12477:            Equality m_predicate;
        -:12478:
        -:12479:        public:
        -:12480:            template <typename TargetRangeLike2, typename Equality2>
        -:12481:            UnorderedRangeEqualsMatcher( TargetRangeLike2&& range,
        -:12482:                                         Equality2&& predicate ):
        -:12483:                m_desired( CATCH_FORWARD( range ) ),
        -:12484:                m_predicate( CATCH_FORWARD( predicate ) ) {}
        -:12485:
        -:12486:            template <typename RangeLike>
        -:12487:            bool match( RangeLike&& rng ) const {
        -:12488:                using std::begin;
        -:12489:                using std::end;
        -:12490:                return Catch::Detail::is_permutation( begin( m_desired ),
        -:12491:                                                      end( m_desired ),
        -:12492:                                                      begin( rng ),
        -:12493:                                                      end( rng ),
        -:12494:                                                      m_predicate );
        -:12495:            }
        -:12496:
        -:12497:            std::string describe() const override {
        -:12498:                return "unordered elements are " +
        -:12499:                       ::Catch::Detail::stringify( m_desired );
        -:12500:            }
        -:12501:        };
        -:12502:
        -:12503:        /**
        -:12504:         * Creates a matcher that checks if all elements in a range are equal
        -:12505:         * to all elements in another range.
        -:12506:         *
        -:12507:         * Uses `std::equal_to` to do the comparison
        -:12508:         */
        -:12509:        template <typename RangeLike>
        -:12510:        std::enable_if_t<!Detail::is_matcher<RangeLike>::value,
        -:12511:                         RangeEqualsMatcher<RangeLike, std::equal_to<>>>
        -:12512:        RangeEquals( RangeLike&& range ) {
        -:12513:            return { CATCH_FORWARD( range ), std::equal_to<>{} };
        -:12514:        }
        -:12515:
        -:12516:        /**
        -:12517:         * Creates a matcher that checks if all elements in a range are equal
        -:12518:         * to all elements in another range.
        -:12519:         *
        -:12520:         * Uses to provided predicate `predicate` to do the comparisons
        -:12521:         */
        -:12522:        template <typename RangeLike, typename Equality>
        -:12523:        RangeEqualsMatcher<RangeLike, Equality>
        -:12524:        RangeEquals( RangeLike&& range, Equality&& predicate ) {
        -:12525:            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };
        -:12526:        }
        -:12527:
        -:12528:        /**
        -:12529:         * Creates a matcher that checks if all elements in a range are equal
        -:12530:         * to all elements in another range, in some permutation
        -:12531:         *
        -:12532:         * Uses `std::equal_to` to do the comparison
        -:12533:         */
        -:12534:        template <typename RangeLike>
        -:12535:        std::enable_if_t<
        -:12536:            !Detail::is_matcher<RangeLike>::value,
        -:12537:            UnorderedRangeEqualsMatcher<RangeLike, std::equal_to<>>>
        -:12538:        UnorderedRangeEquals( RangeLike&& range ) {
        -:12539:            return { CATCH_FORWARD( range ), std::equal_to<>{} };
        -:12540:        }
        -:12541:
        -:12542:        /**
        -:12543:         * Creates a matcher that checks if all elements in a range are equal
        -:12544:         * to all elements in another range, in some permutation.
        -:12545:         *
        -:12546:         * Uses to provided predicate `predicate` to do the comparisons
        -:12547:         */
        -:12548:        template <typename RangeLike, typename Equality>
        -:12549:        UnorderedRangeEqualsMatcher<RangeLike, Equality>
        -:12550:        UnorderedRangeEquals( RangeLike&& range, Equality&& predicate ) {
        -:12551:            return { CATCH_FORWARD( range ), CATCH_FORWARD( predicate ) };
        -:12552:        }
        -:12553:    } // namespace Matchers
        -:12554:} // namespace Catch
        -:12555:
        -:12556:#endif // CATCH_MATCHERS_RANGE_EQUALS_HPP_INCLUDED
        -:12557:
        -:12558:
        -:12559:#ifndef CATCH_MATCHERS_STRING_HPP_INCLUDED
        -:12560:#define CATCH_MATCHERS_STRING_HPP_INCLUDED
        -:12561:
        -:12562:
        -:12563:#include <string>
        -:12564:
        -:12565:namespace Catch {
        -:12566:namespace Matchers {
        -:12567:
        -:12568:    struct CasedString {
        -:12569:        CasedString( std::string const& str, CaseSensitive caseSensitivity );
        -:12570:        std::string adjustString( std::string const& str ) const;
        -:12571:        StringRef caseSensitivitySuffix() const;
        -:12572:
        -:12573:        CaseSensitive m_caseSensitivity;
        -:12574:        std::string m_str;
        -:12575:    };
        -:12576:
        -:12577:    class StringMatcherBase : public MatcherBase<std::string> {
        -:12578:    protected:
        -:12579:        CasedString m_comparator;
        -:12580:        StringRef m_operation;
        -:12581:
        -:12582:    public:
        -:12583:        StringMatcherBase( StringRef operation,
        -:12584:                           CasedString const& comparator );
        -:12585:        std::string describe() const override;
        -:12586:    };
        -:12587:
        -:12588:    class StringEqualsMatcher final : public StringMatcherBase {
        -:12589:    public:
        -:12590:        StringEqualsMatcher( CasedString const& comparator );
        -:12591:        bool match( std::string const& source ) const override;
        -:12592:    };
        -:12593:    class StringContainsMatcher final : public StringMatcherBase {
        -:12594:    public:
        -:12595:        StringContainsMatcher( CasedString const& comparator );
        -:12596:        bool match( std::string const& source ) const override;
        -:12597:    };
        -:12598:    class StartsWithMatcher final : public StringMatcherBase {
        -:12599:    public:
        -:12600:        StartsWithMatcher( CasedString const& comparator );
        -:12601:        bool match( std::string const& source ) const override;
        -:12602:    };
        -:12603:    class EndsWithMatcher final : public StringMatcherBase {
        -:12604:    public:
        -:12605:        EndsWithMatcher( CasedString const& comparator );
        -:12606:        bool match( std::string const& source ) const override;
        -:12607:    };
        -:12608:
        -:12609:    class RegexMatcher final : public MatcherBase<std::string> {
        -:12610:        std::string m_regex;
        -:12611:        CaseSensitive m_caseSensitivity;
        -:12612:
        -:12613:    public:
        -:12614:        RegexMatcher( std::string regex, CaseSensitive caseSensitivity );
        -:12615:        bool match( std::string const& matchee ) const override;
        -:12616:        std::string describe() const override;
        -:12617:    };
        -:12618:
        -:12619:    //! Creates matcher that accepts strings that are exactly equal to `str`
        -:12620:    StringEqualsMatcher Equals( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:12621:    //! Creates matcher that accepts strings that contain `str`
        -:12622:    StringContainsMatcher ContainsSubstring( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:12623:    //! Creates matcher that accepts strings that _end_ with `str`
        -:12624:    EndsWithMatcher EndsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:12625:    //! Creates matcher that accepts strings that _start_ with `str`
        -:12626:    StartsWithMatcher StartsWith( std::string const& str, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:12627:    //! Creates matcher that accepts strings matching `regex`
        -:12628:    RegexMatcher Matches( std::string const& regex, CaseSensitive caseSensitivity = CaseSensitive::Yes );
        -:12629:
        -:12630:} // namespace Matchers
        -:12631:} // namespace Catch
        -:12632:
        -:12633:#endif // CATCH_MATCHERS_STRING_HPP_INCLUDED
        -:12634:
        -:12635:
        -:12636:#ifndef CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:12637:#define CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:12638:
        -:12639:
        -:12640:#include <algorithm>
        -:12641:
        -:12642:namespace Catch {
        -:12643:namespace Matchers {
        -:12644:
        -:12645:    template<typename T, typename Alloc>
        -:12646:    class VectorContainsElementMatcher final : public MatcherBase<std::vector<T, Alloc>> {
        -:12647:        T const& m_comparator;
        -:12648:
        -:12649:    public:
        -:12650:        VectorContainsElementMatcher(T const& comparator):
        -:12651:            m_comparator(comparator)
        -:12652:        {}
        -:12653:
        -:12654:        bool match(std::vector<T, Alloc> const& v) const override {
        -:12655:            for (auto const& el : v) {
        -:12656:                if (el == m_comparator) {
        -:12657:                    return true;
        -:12658:                }
        -:12659:            }
        -:12660:            return false;
        -:12661:        }
        -:12662:
        -:12663:        std::string describe() const override {
        -:12664:            return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -:12665:        }
        -:12666:    };
        -:12667:
        -:12668:    template<typename T, typename AllocComp, typename AllocMatch>
        -:12669:    class ContainsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> {
        -:12670:        std::vector<T, AllocComp> const& m_comparator;
        -:12671:
        -:12672:    public:
        -:12673:        ContainsMatcher(std::vector<T, AllocComp> const& comparator):
        -:12674:            m_comparator( comparator )
        -:12675:        {}
        -:12676:
        -:12677:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:12678:            // !TBD: see note in EqualsMatcher
        -:12679:            if (m_comparator.size() > v.size())
        -:12680:                return false;
        -:12681:            for (auto const& comparator : m_comparator) {
        -:12682:                auto present = false;
        -:12683:                for (const auto& el : v) {
        -:12684:                    if (el == comparator) {
        -:12685:                        present = true;
        -:12686:                        break;
        -:12687:                    }
        -:12688:                }
        -:12689:                if (!present) {
        -:12690:                    return false;
        -:12691:                }
        -:12692:            }
        -:12693:            return true;
        -:12694:        }
        -:12695:        std::string describe() const override {
        -:12696:            return "Contains: " + ::Catch::Detail::stringify( m_comparator );
        -:12697:        }
        -:12698:    };
        -:12699:
        -:12700:    template<typename T, typename AllocComp, typename AllocMatch>
        -:12701:    class EqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> {
        -:12702:        std::vector<T, AllocComp> const& m_comparator;
        -:12703:
        -:12704:    public:
        -:12705:        EqualsMatcher(std::vector<T, AllocComp> const& comparator):
        -:12706:            m_comparator( comparator )
        -:12707:        {}
        -:12708:
        -:12709:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:12710:            // !TBD: This currently works if all elements can be compared using !=
        -:12711:            // - a more general approach would be via a compare template that defaults
        -:12712:            // to using !=. but could be specialised for, e.g. std::vector<T> etc
        -:12713:            // - then just call that directly
        -:12714:            if ( m_comparator.size() != v.size() ) { return false; }
        -:12715:            for ( std::size_t i = 0; i < v.size(); ++i ) {
        -:12716:                if ( !( m_comparator[i] == v[i] ) ) { return false; }
        -:12717:            }
        -:12718:            return true;
        -:12719:        }
        -:12720:        std::string describe() const override {
        -:12721:            return "Equals: " + ::Catch::Detail::stringify( m_comparator );
        -:12722:        }
        -:12723:    };
        -:12724:
        -:12725:    template<typename T, typename AllocComp, typename AllocMatch>
        -:12726:    class ApproxMatcher final : public MatcherBase<std::vector<T, AllocMatch>> {
        -:12727:        std::vector<T, AllocComp> const& m_comparator;
        -:12728:        mutable Catch::Approx approx = Catch::Approx::custom();
        -:12729:
        -:12730:    public:
        -:12731:        ApproxMatcher(std::vector<T, AllocComp> const& comparator):
        -:12732:            m_comparator( comparator )
        -:12733:        {}
        -:12734:
        -:12735:        bool match(std::vector<T, AllocMatch> const& v) const override {
        -:12736:            if (m_comparator.size() != v.size())
        -:12737:                return false;
        -:12738:            for (std::size_t i = 0; i < v.size(); ++i)
        -:12739:                if (m_comparator[i] != approx(v[i]))
        -:12740:                    return false;
        -:12741:            return true;
        -:12742:        }
        -:12743:        std::string describe() const override {
        -:12744:            return "is approx: " + ::Catch::Detail::stringify( m_comparator );
        -:12745:        }
        -:12746:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:12747:        ApproxMatcher& epsilon( T const& newEpsilon ) {
        -:12748:            approx.epsilon(static_cast<double>(newEpsilon));
        -:12749:            return *this;
        -:12750:        }
        -:12751:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:12752:        ApproxMatcher& margin( T const& newMargin ) {
        -:12753:            approx.margin(static_cast<double>(newMargin));
        -:12754:            return *this;
        -:12755:        }
        -:12756:        template <typename = std::enable_if_t<std::is_constructible<double, T>::value>>
        -:12757:        ApproxMatcher& scale( T const& newScale ) {
        -:12758:            approx.scale(static_cast<double>(newScale));
        -:12759:            return *this;
        -:12760:        }
        -:12761:    };
        -:12762:
        -:12763:    template<typename T, typename AllocComp, typename AllocMatch>
        -:12764:    class UnorderedEqualsMatcher final : public MatcherBase<std::vector<T, AllocMatch>> {
        -:12765:        std::vector<T, AllocComp> const& m_target;
        -:12766:
        -:12767:    public:
        -:12768:        UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target):
        -:12769:            m_target(target)
        -:12770:        {}
        -:12771:        bool match(std::vector<T, AllocMatch> const& vec) const override {
        -:12772:            if (m_target.size() != vec.size()) {
        -:12773:                return false;
        -:12774:            }
        -:12775:            return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
        -:12776:        }
        -:12777:
        -:12778:        std::string describe() const override {
        -:12779:            return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
        -:12780:        }
        -:12781:    };
        -:12782:
        -:12783:
        -:12784:    // The following functions create the actual matcher objects.
        -:12785:    // This allows the types to be inferred
        -:12786:
        -:12787:    //! Creates a matcher that matches vectors that contain all elements in `comparator`
        -:12788:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:12789:    ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
        -:12790:        return ContainsMatcher<T, AllocComp, AllocMatch>(comparator);
        -:12791:    }
        -:12792:
        -:12793:    //! Creates a matcher that matches vectors that contain `comparator` as an element
        -:12794:    template<typename T, typename Alloc = std::allocator<T>>
        -:12795:    VectorContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
        -:12796:        return VectorContainsElementMatcher<T, Alloc>(comparator);
        -:12797:    }
        -:12798:
        -:12799:    //! Creates a matcher that matches vectors that are exactly equal to `comparator`
        -:12800:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:12801:    EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
        -:12802:        return EqualsMatcher<T, AllocComp, AllocMatch>(comparator);
        -:12803:    }
        -:12804:
        -:12805:    //! Creates a matcher that matches vectors that `comparator` as an element
        -:12806:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:12807:    ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
        -:12808:        return ApproxMatcher<T, AllocComp, AllocMatch>(comparator);
        -:12809:    }
        -:12810:
        -:12811:    //! Creates a matcher that matches vectors that is equal to `target` modulo permutation
        -:12812:    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
        -:12813:    UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
        -:12814:        return UnorderedEqualsMatcher<T, AllocComp, AllocMatch>(target);
        -:12815:    }
        -:12816:
        -:12817:} // namespace Matchers
        -:12818:} // namespace Catch
        -:12819:
        -:12820:#endif // CATCH_MATCHERS_VECTOR_HPP_INCLUDED
        -:12821:
        -:12822:#endif // CATCH_MATCHERS_ALL_HPP_INCLUDED
        -:12823:
        -:12824:
        -:12825:/** \file
        -:12826: * This is a convenience header for Catch2's Reporter support. It includes
        -:12827: * **all** of Catch2 headers related to reporters, including all reporters.
        -:12828: *
        -:12829: * Generally the Catch2 users should use specific includes they need,
        -:12830: * but this header can be used instead for ease-of-experimentation, or
        -:12831: * just plain convenience, at the cost of (significantly) increased
        -:12832: * compilation times.
        -:12833: *
        -:12834: * When a new header (reporter) is added to either the `reporter` folder,
        -:12835: * or to the corresponding internal subfolder, it should be added here.
        -:12836: */
        -:12837:
        -:12838:#ifndef CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:12839:#define CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:12840:
        -:12841:
        -:12842:
        -:12843:#ifndef CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:12844:#define CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:12845:
        -:12846:
        -:12847:
        -:12848:#ifndef CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:12849:#define CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:12850:
        -:12851:
        -:12852:
        -:12853:#ifndef CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED
        -:12854:#define CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED
        -:12855:
        -:12856:
        -:12857:#include <map>
        -:12858:#include <string>
        -:12859:
        -:12860:namespace Catch {
        -:12861:    class ColourImpl;
        -:12862:
        -:12863:    /**
        -:12864:     * This is the base class for all reporters.
        -:12865:     *
        -:12866:     * If are writing a reporter, you must derive from this type, or one
        -:12867:     * of the helper reporter bases that are derived from this type.
        -:12868:     *
        -:12869:     * ReporterBase centralizes handling of various common tasks in reporters,
        -:12870:     * like storing the right stream for the reporters to write to, and
        -:12871:     * providing the default implementation of the different listing events.
        -:12872:     */
        -:12873:    class ReporterBase : public IEventListener {
        -:12874:    protected:
        -:12875:        //! The stream wrapper as passed to us by outside code
        -:12876:        Detail::unique_ptr<IStream> m_wrapped_stream;
        -:12877:        //! Cached output stream from `m_wrapped_stream` to reduce
        -:12878:        //! number of indirect calls needed to write output.
        -:12879:        std::ostream& m_stream;
        -:12880:        //! Colour implementation this reporter was configured for
        -:12881:        Detail::unique_ptr<ColourImpl> m_colour;
        -:12882:        //! The custom reporter options user passed down to the reporter
        -:12883:        std::map<std::string, std::string> m_customOptions;
        -:12884:
        -:12885:    public:
        -:12886:        ReporterBase( ReporterConfig&& config );
        -:12887:        ~ReporterBase() override; // = default;
        -:12888:
        -:12889:        /**
        -:12890:         * Provides a simple default listing of reporters.
        -:12891:         *
        -:12892:         * Should look roughly like the reporter listing in v2 and earlier
        -:12893:         * versions of Catch2.
        -:12894:         */
        -:12895:        void listReporters(
        -:12896:            std::vector<ReporterDescription> const& descriptions ) override;
        -:12897:        /**
        -:12898:         * Provides a simple default listing of listeners
        -:12899:         *
        -:12900:         * Looks similarly to listing of reporters, but with listener type
        -:12901:         * instead of reporter name.
        -:12902:         */
        -:12903:        void listListeners(
        -:12904:            std::vector<ListenerDescription> const& descriptions ) override;
        -:12905:        /**
        -:12906:         * Provides a simple default listing of tests.
        -:12907:         *
        -:12908:         * Should look roughly like the test listing in v2 and earlier versions
        -:12909:         * of Catch2. Especially supports low-verbosity listing that mimics the
        -:12910:         * old `--list-test-names-only` output.
        -:12911:         */
        -:12912:        void listTests( std::vector<TestCaseHandle> const& tests ) override;
        -:12913:        /**
        -:12914:         * Provides a simple default listing of tags.
        -:12915:         *
        -:12916:         * Should look roughly like the tag listing in v2 and earlier versions
        -:12917:         * of Catch2.
        -:12918:         */
        -:12919:        void listTags( std::vector<TagInfo> const& tags ) override;
        -:12920:    };
        -:12921:} // namespace Catch
        -:12922:
        -:12923:#endif // CATCH_REPORTER_COMMON_BASE_HPP_INCLUDED
        -:12924:
        -:12925:#include <vector>
        -:12926:
        -:12927:namespace Catch {
        -:12928:
        -:12929:    class StreamingReporterBase : public ReporterBase {
        -:12930:    public:
        -:12931:        // GCC5 compat: we cannot use inherited constructor, because it
        -:12932:        //              doesn't implement backport of P0136
        -:12933:        StreamingReporterBase(ReporterConfig&& _config):
        -:12934:            ReporterBase(CATCH_MOVE(_config))
        -:12935:        {}
        -:12936:        ~StreamingReporterBase() override;
        -:12937:
        -:12938:        void benchmarkPreparing( StringRef ) override {}
        -:12939:        void benchmarkStarting( BenchmarkInfo const& ) override {}
        -:12940:        void benchmarkEnded( BenchmarkStats<> const& ) override {}
        -:12941:        void benchmarkFailed( StringRef ) override {}
        -:12942:
        -:12943:        void fatalErrorEncountered( StringRef /*error*/ ) override {}
        -:12944:        void noMatchingTestCases( StringRef /*unmatchedSpec*/ ) override {}
        -:12945:        void reportInvalidTestSpec( StringRef /*invalidArgument*/ ) override {}
        -:12946:
        -:12947:        void testRunStarting( TestRunInfo const& _testRunInfo ) override;
        -:12948:
        -:12949:        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
        -:12950:            currentTestCaseInfo = &_testInfo;
        -:12951:        }
        -:12952:        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override {}
        -:12953:        void sectionStarting(SectionInfo const& _sectionInfo) override {
        -:12954:            m_sectionStack.push_back(_sectionInfo);
        -:12955:        }
        -:12956:
        -:12957:        void assertionStarting( AssertionInfo const& ) override {}
        -:12958:        void assertionEnded( AssertionStats const& ) override {}
        -:12959:
        -:12960:        void sectionEnded(SectionStats const& /* _sectionStats */) override {
        -:12961:            m_sectionStack.pop_back();
        -:12962:        }
        -:12963:        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override {}
        -:12964:        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
        -:12965:            currentTestCaseInfo = nullptr;
        -:12966:        }
        -:12967:        void testRunEnded( TestRunStats const& /* _testRunStats */ ) override;
        -:12968:
        -:12969:        void skipTest(TestCaseInfo const&) override {
        -:12970:            // Don't do anything with this by default.
        -:12971:            // It can optionally be overridden in the derived class.
        -:12972:        }
        -:12973:
        -:12974:    protected:
        -:12975:        TestRunInfo currentTestRunInfo{ "test run has not started yet"_sr };
        -:12976:        TestCaseInfo const* currentTestCaseInfo = nullptr;
        -:12977:
        -:12978:        //! Stack of all _active_ sections in the _current_ test case
        -:12979:        std::vector<SectionInfo> m_sectionStack;
        -:12980:    };
        -:12981:
        -:12982:} // end namespace Catch
        -:12983:
        -:12984:#endif // CATCH_REPORTER_STREAMING_BASE_HPP_INCLUDED
        -:12985:
        -:12986:#include <string>
        -:12987:
        -:12988:namespace Catch {
        -:12989:
        -:12990:    class AutomakeReporter final : public StreamingReporterBase {
        -:12991:    public:
        -:12992:        // GCC5 compat: we cannot use inherited constructor, because it
        -:12993:        //              doesn't implement backport of P0136
        -:12994:        AutomakeReporter(ReporterConfig&& _config):
        -:12995:            StreamingReporterBase(CATCH_MOVE(_config))
        -:12996:        {}
        -:12997:        ~AutomakeReporter() override;
        -:12998:
        -:12999:        static std::string getDescription() {
        -:13000:            using namespace std::string_literals;
        -:13001:            return "Reports test results in the format of Automake .trs files"s;
        -:13002:        }
        -:13003:
        -:13004:        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        -:13005:        void skipTest(TestCaseInfo const& testInfo) override;
        -:13006:    };
        -:13007:
        -:13008:} // end namespace Catch
        -:13009:
        -:13010:#endif // CATCH_REPORTER_AUTOMAKE_HPP_INCLUDED
        -:13011:
        -:13012:
        -:13013:#ifndef CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:13014:#define CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:13015:
        -:13016:
        -:13017:
        -:13018:
        -:13019:namespace Catch {
        -:13020:
        -:13021:    class CompactReporter final : public StreamingReporterBase {
        -:13022:    public:
        -:13023:        using StreamingReporterBase::StreamingReporterBase;
        -:13024:
        -:13025:        ~CompactReporter() override;
        -:13026:
        -:13027:        static std::string getDescription();
        -:13028:
        -:13029:        void noMatchingTestCases( StringRef unmatchedSpec ) override;
        -:13030:
        -:13031:        void testRunStarting( TestRunInfo const& _testInfo ) override;
        -:13032:
        -:13033:        void assertionEnded(AssertionStats const& _assertionStats) override;
        -:13034:
        -:13035:        void sectionEnded(SectionStats const& _sectionStats) override;
        -:13036:
        -:13037:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:13038:
        -:13039:    };
        -:13040:
        -:13041:} // end namespace Catch
        -:13042:
        -:13043:#endif // CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:13044:
        -:13045:
        -:13046:#ifndef CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:13047:#define CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:13048:
        -:13049:
        -:13050:namespace Catch {
        -:13051:    // Fwd decls
        -:13052:    class TablePrinter;
        -:13053:
        -:13054:    class ConsoleReporter final : public StreamingReporterBase {
        -:13055:        Detail::unique_ptr<TablePrinter> m_tablePrinter;
        -:13056:
        -:13057:    public:
        -:13058:        ConsoleReporter(ReporterConfig&& config);
        -:13059:        ~ConsoleReporter() override;
        -:13060:        static std::string getDescription();
        -:13061:
        -:13062:        void noMatchingTestCases( StringRef unmatchedSpec ) override;
        -:13063:        void reportInvalidTestSpec( StringRef arg ) override;
        -:13064:
        -:13065:        void assertionStarting(AssertionInfo const&) override;
        -:13066:
        -:13067:        void assertionEnded(AssertionStats const& _assertionStats) override;
        -:13068:
        -:13069:        void sectionStarting(SectionInfo const& _sectionInfo) override;
        -:13070:        void sectionEnded(SectionStats const& _sectionStats) override;
        -:13071:
        -:13072:        void benchmarkPreparing( StringRef name ) override;
        -:13073:        void benchmarkStarting(BenchmarkInfo const& info) override;
        -:13074:        void benchmarkEnded(BenchmarkStats<> const& stats) override;
        -:13075:        void benchmarkFailed( StringRef error ) override;
        -:13076:
        -:13077:        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
        -:13078:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:13079:        void testRunStarting(TestRunInfo const& _testRunInfo) override;
        -:13080:
        -:13081:    private:
        -:13082:        void lazyPrint();
        -:13083:
        -:13084:        void lazyPrintWithoutClosingBenchmarkTable();
        -:13085:        void lazyPrintRunInfo();
        -:13086:        void printTestCaseAndSectionHeader();
        -:13087:
        -:13088:        void printClosedHeader(std::string const& _name);
        -:13089:        void printOpenHeader(std::string const& _name);
        -:13090:
        -:13091:        // if string has a : in first line will set indent to follow it on
        -:13092:        // subsequent lines
        -:13093:        void printHeaderString(std::string const& _string, std::size_t indent = 0);
        -:13094:
        -:13095:        void printTotalsDivider(Totals const& totals);
        -:13096:
        -:13097:        bool m_headerPrinted = false;
        -:13098:        bool m_testRunInfoPrinted = false;
        -:13099:    };
        -:13100:
        -:13101:} // end namespace Catch
        -:13102:
        -:13103:#endif // CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:13104:
        -:13105:
        -:13106:#ifndef CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:13107:#define CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:13108:
        -:13109:
        -:13110:#include <string>
        -:13111:#include <vector>
        -:13112:
        -:13113:namespace Catch {
        -:13114:
        -:13115:    namespace Detail {
        -:13116:
        -:13117:        //! Represents either an assertion or a benchmark result to be handled by cumulative reporter later
        -:13118:        class AssertionOrBenchmarkResult {
        -:13119:            // This should really be a variant, but this is much faster
        -:13120:            // to write and the data layout here is already terrible
        -:13121:            // enough that we do not have to care about the object size.
        -:13122:            Optional<AssertionStats> m_assertion;
        -:13123:            Optional<BenchmarkStats<>> m_benchmark;
        -:13124:        public:
        -:13125:            AssertionOrBenchmarkResult(AssertionStats const& assertion);
        -:13126:            AssertionOrBenchmarkResult(BenchmarkStats<> const& benchmark);
        -:13127:
        -:13128:            bool isAssertion() const;
        -:13129:            bool isBenchmark() const;
        -:13130:
        -:13131:            AssertionStats const& asAssertion() const;
        -:13132:            BenchmarkStats<> const& asBenchmark() const;
        -:13133:        };
        -:13134:    }
        -:13135:
        -:13136:    /**
        -:13137:     * Utility base for reporters that need to handle all results at once
        -:13138:     *
        -:13139:     * It stores tree of all test cases, sections and assertions, and after the
        -:13140:     * test run is finished, calls into `testRunEndedCumulative` to pass the
        -:13141:     * control to the deriving class.
        -:13142:     *
        -:13143:     * If you are deriving from this class and override any testing related
        -:13144:     * member functions, you should first call into the base's implementation to
        -:13145:     * avoid breaking the tree construction.
        -:13146:     *
        -:13147:     * Due to the way this base functions, it has to expand assertions up-front,
        -:13148:     * even if they are later unused (e.g. because the deriving reporter does
        -:13149:     * not report successful assertions, or because the deriving reporter does
        -:13150:     * not use assertion expansion at all). Derived classes can use two
        -:13151:     * customization points, `m_shouldStoreSuccesfulAssertions` and
        -:13152:     * `m_shouldStoreFailedAssertions`, to disable the expansion and gain extra
        -:13153:     * performance. **Accessing the assertion expansions if it wasn't stored is
        -:13154:     * UB.**
        -:13155:     */
        -:13156:    class CumulativeReporterBase : public ReporterBase {
        -:13157:    public:
        -:13158:        template<typename T, typename ChildNodeT>
        -:13159:        struct Node {
        -:13160:            explicit Node( T const& _value ) : value( _value ) {}
        -:13161:
        -:13162:            using ChildNodes = std::vector<Detail::unique_ptr<ChildNodeT>>;
        -:13163:            T value;
        -:13164:            ChildNodes children;
        -:13165:        };
        -:13166:        struct SectionNode {
        -:13167:            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
        -:13168:
        -:13169:            bool operator == (SectionNode const& other) const {
        -:13170:                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
        -:13171:            }
        -:13172:
        -:13173:            bool hasAnyAssertions() const;
        -:13174:
        -:13175:            SectionStats stats;
        -:13176:            std::vector<Detail::unique_ptr<SectionNode>> childSections;
        -:13177:            std::vector<Detail::AssertionOrBenchmarkResult> assertionsAndBenchmarks;
        -:13178:            std::string stdOut;
        -:13179:            std::string stdErr;
        -:13180:        };
        -:13181:
        -:13182:
        -:13183:        using TestCaseNode = Node<TestCaseStats, SectionNode>;
        -:13184:        using TestRunNode = Node<TestRunStats, TestCaseNode>;
        -:13185:
        -:13186:        // GCC5 compat: we cannot use inherited constructor, because it
        -:13187:        //              doesn't implement backport of P0136
        -:13188:        CumulativeReporterBase(ReporterConfig&& _config):
        -:13189:            ReporterBase(CATCH_MOVE(_config))
        -:13190:        {}
        -:13191:        ~CumulativeReporterBase() override;
        -:13192:
        -:13193:        void benchmarkPreparing( StringRef ) override {}
        -:13194:        void benchmarkStarting( BenchmarkInfo const& ) override {}
        -:13195:        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
        -:13196:        void benchmarkFailed( StringRef ) override {}
        -:13197:
        -:13198:        void noMatchingTestCases( StringRef ) override {}
        -:13199:        void reportInvalidTestSpec( StringRef ) override {}
        -:13200:        void fatalErrorEncountered( StringRef /*error*/ ) override {}
        -:13201:
        -:13202:        void testRunStarting( TestRunInfo const& ) override {}
        -:13203:
        -:13204:        void testCaseStarting( TestCaseInfo const& ) override {}
        -:13205:        void testCasePartialStarting( TestCaseInfo const&, uint64_t ) override {}
        -:13206:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:13207:
        -:13208:        void assertionStarting( AssertionInfo const& ) override {}
        -:13209:
        -:13210:        void assertionEnded( AssertionStats const& assertionStats ) override;
        -:13211:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:13212:        void testCasePartialEnded( TestCaseStats const&, uint64_t ) override {}
        -:13213:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:13214:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:13215:        //! Customization point: called after last test finishes (testRunEnded has been handled)
        -:13216:        virtual void testRunEndedCumulative() = 0;
        -:13217:
        -:13218:        void skipTest(TestCaseInfo const&) override {}
        -:13219:
        -:13220:    protected:
        -:13221:        //! Should the cumulative base store the assertion expansion for successful assertions?
        -:13222:        bool m_shouldStoreSuccesfulAssertions = true;
        -:13223:        //! Should the cumulative base store the assertion expansion for failed assertions?
        -:13224:        bool m_shouldStoreFailedAssertions = true;
        -:13225:
        -:13226:        // We need lazy construction here. We should probably refactor it
        -:13227:        // later, after the events are redone.
        -:13228:        //! The root node of the test run tree.
        -:13229:        Detail::unique_ptr<TestRunNode> m_testRun;
        -:13230:
        -:13231:    private:
        -:13232:        // Note: We rely on pointer identity being stable, which is why
        -:13233:        //       we store pointers to the nodes rather than the values.
        -:13234:        std::vector<Detail::unique_ptr<TestCaseNode>> m_testCases;
        -:13235:        // Root section of the _current_ test case
        -:13236:        Detail::unique_ptr<SectionNode> m_rootSection;
        -:13237:        // Deepest section of the _current_ test case
        -:13238:        SectionNode* m_deepestSection = nullptr;
        -:13239:        // Stack of _active_ sections in the _current_ test case
        -:13240:        std::vector<SectionNode*> m_sectionStack;
        -:13241:    };
        -:13242:
        -:13243:} // end namespace Catch
        -:13244:
        -:13245:#endif // CATCH_REPORTER_CUMULATIVE_BASE_HPP_INCLUDED
        -:13246:
        -:13247:
        -:13248:#ifndef CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:13249:#define CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:13250:
        -:13251:
        -:13252:namespace Catch {
        -:13253:
        -:13254:    /**
        -:13255:     * Base class to simplify implementing listeners.
        -:13256:     *
        -:13257:     * Provides empty default implementation for all IEventListener member
        -:13258:     * functions, so that a listener implementation can pick which
        -:13259:     * member functions it actually cares about.
        -:13260:     */
        -:13261:    class EventListenerBase : public IEventListener {
        -:13262:    public:
        -:13263:        using IEventListener::IEventListener;
        -:13264:
        -:13265:        void reportInvalidTestSpec( StringRef unmatchedSpec ) override;
        -:13266:        void fatalErrorEncountered( StringRef error ) override;
        -:13267:
        -:13268:        void benchmarkPreparing( StringRef name ) override;
        -:13269:        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
        -:13270:        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
        -:13271:        void benchmarkFailed( StringRef error ) override;
        -:13272:
        -:13273:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -:13274:        void assertionEnded( AssertionStats const& assertionStats ) override;
        -:13275:
        -:13276:        void listReporters(
        -:13277:            std::vector<ReporterDescription> const& descriptions ) override;
        -:13278:        void listListeners(
        -:13279:            std::vector<ListenerDescription> const& descriptions ) override;
        -:13280:        void listTests( std::vector<TestCaseHandle> const& tests ) override;
        -:13281:        void listTags( std::vector<TagInfo> const& tagInfos ) override;
        -:13282:
        -:13283:        void noMatchingTestCases( StringRef unmatchedSpec ) override;
        -:13284:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -:13285:        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        -:13286:        void testCasePartialStarting( TestCaseInfo const& testInfo,
        -:13287:                                      uint64_t partNumber ) override;
        -:13288:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:13289:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:13290:        void testCasePartialEnded( TestCaseStats const& testCaseStats,
        -:13291:                                   uint64_t partNumber ) override;
        -:13292:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:13293:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:13294:        void skipTest( TestCaseInfo const& testInfo ) override;
        -:13295:    };
        -:13296:
        -:13297:} // end namespace Catch
        -:13298:
        -:13299:#endif // CATCH_REPORTER_EVENT_LISTENER_HPP_INCLUDED
        -:13300:
        -:13301:
        -:13302:#ifndef CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:13303:#define CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:13304:
        -:13305:#include <iosfwd>
        -:13306:#include <string>
        -:13307:#include <vector>
        -:13308:
        -:13309:
        -:13310:namespace Catch {
        -:13311:
        -:13312:    class IConfig;
        -:13313:    class TestCaseHandle;
        -:13314:    class ColourImpl;
        -:13315:
        -:13316:    // Returns double formatted as %.3f (format expected on output)
        -:13317:    std::string getFormattedDuration( double duration );
        -:13318:
        -:13319:    //! Should the reporter show duration of test given current configuration?
        -:13320:    bool shouldShowDuration( IConfig const& config, double duration );
        -:13321:
        -:13322:    std::string serializeFilters( std::vector<std::string> const& filters );
        -:13323:
        -:13324:    struct lineOfChars {
        -:13325:        char c;
        -:13326:        constexpr lineOfChars( char c_ ): c( c_ ) {}
        -:13327:
        -:13328:        friend std::ostream& operator<<( std::ostream& out, lineOfChars value );
        -:13329:    };
        -:13330:
        -:13331:    /**
        -:13332:     * Lists reporter descriptions to the provided stream in user-friendly
        -:13333:     * format
        -:13334:     *
        -:13335:     * Used as the default listing implementation by the first party reporter
        -:13336:     * bases. The output should be backwards compatible with the output of
        -:13337:     * Catch2 v2 binaries.
        -:13338:     */
        -:13339:    void
        -:13340:    defaultListReporters( std::ostream& out,
        -:13341:                          std::vector<ReporterDescription> const& descriptions,
        -:13342:                          Verbosity verbosity );
        -:13343:
        -:13344:    /**
        -:13345:     * Lists listeners descriptions to the provided stream in user-friendly
        -:13346:     * format
        -:13347:     */
        -:13348:    void defaultListListeners( std::ostream& out,
        -:13349:                               std::vector<ListenerDescription> const& descriptions );
        -:13350:
        -:13351:    /**
        -:13352:     * Lists tag information to the provided stream in user-friendly format
        -:13353:     *
        -:13354:     * Used as the default listing implementation by the first party reporter
        -:13355:     * bases. The output should be backwards compatible with the output of
        -:13356:     * Catch2 v2 binaries.
        -:13357:     */
        -:13358:    void defaultListTags( std::ostream& out, std::vector<TagInfo> const& tags, bool isFiltered );
        -:13359:
        -:13360:    /**
        -:13361:     * Lists test case information to the provided stream in user-friendly
        -:13362:     * format
        -:13363:     *
        -:13364:     * Used as the default listing implementation by the first party reporter
        -:13365:     * bases. The output is backwards compatible with the output of Catch2
        -:13366:     * v2 binaries, and also supports the format specific to the old
        -:13367:     * `--list-test-names-only` option, for people who used it in integrations.
        -:13368:     */
        -:13369:    void defaultListTests( std::ostream& out,
        -:13370:                           ColourImpl* streamColour,
        -:13371:                           std::vector<TestCaseHandle> const& tests,
        -:13372:                           bool isFiltered,
        -:13373:                           Verbosity verbosity );
        -:13374:
        -:13375:    /**
        -:13376:     * Prints test run totals to the provided stream in user-friendly format
        -:13377:     *
        -:13378:     * Used by the console and compact reporters.
        -:13379:     */
        -:13380:    void printTestRunTotals( std::ostream& stream,
        -:13381:                      ColourImpl& streamColour,
        -:13382:                      Totals const& totals );
        -:13383:
        -:13384:} // end namespace Catch
        -:13385:
        -:13386:#endif // CATCH_REPORTER_HELPERS_HPP_INCLUDED
        -:13387:
        -:13388:
        -:13389:
        -:13390:#ifndef CATCH_REPORTER_JSON_HPP_INCLUDED
        -:13391:#define CATCH_REPORTER_JSON_HPP_INCLUDED
        -:13392:
        -:13393:
        -:13394:#include <stack>
        -:13395:
        -:13396:namespace Catch {
        -:13397:    class JsonReporter : public StreamingReporterBase {
        -:13398:    public:
        -:13399:        JsonReporter( ReporterConfig&& config );
        -:13400:
        -:13401:        ~JsonReporter() override;
        -:13402:
        -:13403:        static std::string getDescription();
        -:13404:
        -:13405:    public: // StreamingReporterBase
        -:13406:        void testRunStarting( TestRunInfo const& runInfo ) override;
        -:13407:        void testRunEnded( TestRunStats const& runStats ) override;
        -:13408:
        -:13409:        void testCaseStarting( TestCaseInfo const& tcInfo ) override;
        -:13410:        void testCaseEnded( TestCaseStats const& tcStats ) override;
        -:13411:
        -:13412:        void testCasePartialStarting( TestCaseInfo const& tcInfo,
        -:13413:                                      uint64_t index ) override;
        -:13414:        void testCasePartialEnded( TestCaseStats const& tcStats,
        -:13415:                                   uint64_t index ) override;
        -:13416:
        -:13417:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:13418:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:13419:
        -:13420:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -:13421:        void assertionEnded( AssertionStats const& assertionStats ) override;
        -:13422:
        -:13423:        //void testRunEndedCumulative() override;
        -:13424:
        -:13425:        void benchmarkPreparing( StringRef name ) override;
        -:13426:        void benchmarkStarting( BenchmarkInfo const& ) override;
        -:13427:        void benchmarkEnded( BenchmarkStats<> const& ) override;
        -:13428:        void benchmarkFailed( StringRef error ) override;
        -:13429:
        -:13430:        void listReporters(
        -:13431:            std::vector<ReporterDescription> const& descriptions ) override;
        -:13432:        void listListeners(
        -:13433:            std::vector<ListenerDescription> const& descriptions ) override;
        -:13434:        void listTests( std::vector<TestCaseHandle> const& tests ) override;
        -:13435:        void listTags( std::vector<TagInfo> const& tags ) override;
        -:13436:
        -:13437:    private:
        -:13438:        Timer m_testCaseTimer;
        -:13439:        enum class Writer {
        -:13440:            Object,
        -:13441:            Array
        -:13442:        };
        -:13443:
        -:13444:        JsonArrayWriter& startArray();
        -:13445:        JsonArrayWriter& startArray( StringRef key );
        -:13446:
        -:13447:        JsonObjectWriter& startObject();
        -:13448:        JsonObjectWriter& startObject( StringRef key );
        -:13449:
        -:13450:        void endObject();
        -:13451:        void endArray();
        -:13452:
        -:13453:        bool isInside( Writer writer );
        -:13454:
        -:13455:        void startListing();
        -:13456:        void endListing();
        -:13457:
        -:13458:        // Invariant:
        -:13459:        // When m_writers is not empty and its top element is
        -:13460:        // - Writer::Object, then m_objectWriters is not be empty
        -:13461:        // - Writer::Array,  then m_arrayWriters shall not be empty
        -:13462:        std::stack<JsonObjectWriter> m_objectWriters{};
        -:13463:        std::stack<JsonArrayWriter> m_arrayWriters{};
        -:13464:        std::stack<Writer> m_writers{};
        -:13465:
        -:13466:        bool m_startedListing = false;
        -:13467:
        -:13468:        // std::size_t m_sectionDepth = 0;
        -:13469:        // std::size_t m_sectionStarted = 0;
        -:13470:    };
        -:13471:} // namespace Catch
        -:13472:
        -:13473:#endif // CATCH_REPORTER_JSON_HPP_INCLUDED
        -:13474:
        -:13475:
        -:13476:#ifndef CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:13477:#define CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:13478:
        -:13479:
        -:13480:
        -:13481:namespace Catch {
        -:13482:
        -:13483:    class JunitReporter final : public CumulativeReporterBase {
        -:13484:    public:
        -:13485:        JunitReporter(ReporterConfig&& _config);
        -:13486:
        -:13487:        static std::string getDescription();
        -:13488:
        -:13489:        void testRunStarting(TestRunInfo const& runInfo) override;
        -:13490:
        -:13491:        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
        -:13492:        void assertionEnded(AssertionStats const& assertionStats) override;
        -:13493:
        -:13494:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:13495:
        -:13496:        void testRunEndedCumulative() override;
        -:13497:
        -:13498:    private:
        -:13499:        void writeRun(TestRunNode const& testRunNode, double suiteTime);
        -:13500:
        -:13501:        void writeTestCase(TestCaseNode const& testCaseNode);
        -:13502:
        -:13503:        void writeSection( std::string const& className,
        -:13504:                           std::string const& rootName,
        -:13505:                           SectionNode const& sectionNode,
        -:13506:                           bool testOkToFail );
        -:13507:
        -:13508:        void writeAssertions(SectionNode const& sectionNode);
        -:13509:        void writeAssertion(AssertionStats const& stats);
        -:13510:
        -:13511:        XmlWriter xml;
        -:13512:        Timer suiteTimer;
        -:13513:        std::string stdOutForSuite;
        -:13514:        std::string stdErrForSuite;
        -:13515:        unsigned int unexpectedExceptions = 0;
        -:13516:        bool m_okToFail = false;
        -:13517:    };
        -:13518:
        -:13519:} // end namespace Catch
        -:13520:
        -:13521:#endif // CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:13522:
        -:13523:
        -:13524:#ifndef CATCH_REPORTER_MULTI_HPP_INCLUDED
        -:13525:#define CATCH_REPORTER_MULTI_HPP_INCLUDED
        -:13526:
        -:13527:
        -:13528:namespace Catch {
        -:13529:
        -:13530:    class MultiReporter final : public IEventListener {
        -:13531:        /*
        -:13532:         * Stores all added reporters and listeners
        -:13533:         *
        -:13534:         * All Listeners are stored before all reporters, and individual
        -:13535:         * listeners/reporters are stored in order of insertion.
        -:13536:         */
        -:13537:        std::vector<IEventListenerPtr> m_reporterLikes;
        -:13538:        bool m_haveNoncapturingReporters = false;
        -:13539:
        -:13540:        // Keep track of how many listeners we have already inserted,
        -:13541:        // so that we can insert them into the main vector at the right place
        -:13542:        size_t m_insertedListeners = 0;
        -:13543:
        -:13544:        void updatePreferences(IEventListener const& reporterish);
        -:13545:
        -:13546:    public:
        -:13547:        using IEventListener::IEventListener;
        -:13548:
        -:13549:        void addListener( IEventListenerPtr&& listener );
        -:13550:        void addReporter( IEventListenerPtr&& reporter );
        -:13551:
        -:13552:    public: // IEventListener
        -:13553:
        -:13554:        void noMatchingTestCases( StringRef unmatchedSpec ) override;
        -:13555:        void fatalErrorEncountered( StringRef error ) override;
        -:13556:        void reportInvalidTestSpec( StringRef arg ) override;
        -:13557:
        -:13558:        void benchmarkPreparing( StringRef name ) override;
        -:13559:        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
        -:13560:        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
        -:13561:        void benchmarkFailed( StringRef error ) override;
        -:13562:
        -:13563:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -:13564:        void testCaseStarting( TestCaseInfo const& testInfo ) override;
        -:13565:        void testCasePartialStarting(TestCaseInfo const& testInfo, uint64_t partNumber) override;
        -:13566:        void sectionStarting( SectionInfo const& sectionInfo ) override;
        -:13567:        void assertionStarting( AssertionInfo const& assertionInfo ) override;
        -:13568:
        -:13569:        void assertionEnded( AssertionStats const& assertionStats ) override;
        -:13570:        void sectionEnded( SectionStats const& sectionStats ) override;
        -:13571:        void testCasePartialEnded(TestCaseStats const& testStats, uint64_t partNumber) override;
        -:13572:        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
        -:13573:        void testRunEnded( TestRunStats const& testRunStats ) override;
        -:13574:
        -:13575:        void skipTest( TestCaseInfo const& testInfo ) override;
        -:13576:
        -:13577:        void listReporters(std::vector<ReporterDescription> const& descriptions) override;
        -:13578:        void listListeners(std::vector<ListenerDescription> const& descriptions) override;
        -:13579:        void listTests(std::vector<TestCaseHandle> const& tests) override;
        -:13580:        void listTags(std::vector<TagInfo> const& tags) override;
        -:13581:
        -:13582:
        -:13583:    };
        -:13584:
        -:13585:} // end namespace Catch
        -:13586:
        -:13587:#endif // CATCH_REPORTER_MULTI_HPP_INCLUDED
        -:13588:
        -:13589:
        -:13590:#ifndef CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -:13591:#define CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -:13592:
        -:13593:
        -:13594:#include <type_traits>
        -:13595:
        -:13596:namespace Catch {
        -:13597:
        -:13598:    namespace Detail {
        -:13599:
        -:13600:        template <typename T, typename = void>
        -:13601:        struct has_description : std::false_type {};
        -:13602:
        -:13603:        template <typename T>
        -:13604:        struct has_description<
        -:13605:            T,
        -:13606:            void_t<decltype( T::getDescription() )>>
        -:13607:            : std::true_type {};
        -:13608:
        -:13609:        //! Indirection for reporter registration, so that the error handling is
        -:13610:        //! independent on the reporter's concrete type
        -:13611:        void registerReporterImpl( std::string const& name,
        -:13612:                                   IReporterFactoryPtr reporterPtr );
        -:13613:        //! Actually registers the factory, independent on listener's concrete type
        -:13614:        void registerListenerImpl( Detail::unique_ptr<EventListenerFactory> listenerFactory );
        -:13615:    } // namespace Detail
        -:13616:
        -:13617:    class IEventListener;
        -:13618:    using IEventListenerPtr = Detail::unique_ptr<IEventListener>;
        -:13619:
        -:13620:    template <typename T>
        -:13621:    class ReporterFactory : public IReporterFactory {
        -:13622:
        -:13623:        IEventListenerPtr create( ReporterConfig&& config ) const override {
        -:13624:            return Detail::make_unique<T>( CATCH_MOVE(config) );
        -:13625:        }
        -:13626:
        -:13627:        std::string getDescription() const override {
        -:13628:            return T::getDescription();
        -:13629:        }
        -:13630:    };
        -:13631:
        -:13632:
        -:13633:    template<typename T>
        -:13634:    class ReporterRegistrar {
        -:13635:    public:
        -:13636:        explicit ReporterRegistrar( std::string const& name ) {
        -:13637:            registerReporterImpl( name,
        -:13638:                                  Detail::make_unique<ReporterFactory<T>>() );
        -:13639:        }
        -:13640:    };
        -:13641:
        -:13642:    template<typename T>
        -:13643:    class ListenerRegistrar {
        -:13644:
        -:13645:        class TypedListenerFactory : public EventListenerFactory {
        -:13646:            StringRef m_listenerName;
        -:13647:
        -:13648:            std::string getDescriptionImpl( std::true_type ) const {
        -:13649:                return T::getDescription();
        -:13650:            }
        -:13651:
        -:13652:            std::string getDescriptionImpl( std::false_type ) const {
        -:13653:                return "(No description provided)";
        -:13654:            }
        -:13655:
        -:13656:        public:
        -:13657:            TypedListenerFactory( StringRef listenerName ):
        -:13658:                m_listenerName( listenerName ) {}
        -:13659:
        -:13660:            IEventListenerPtr create( IConfig const* config ) const override {
        -:13661:                return Detail::make_unique<T>( config );
        -:13662:            }
        -:13663:
        -:13664:            StringRef getName() const override {
        -:13665:                return m_listenerName;
        -:13666:            }
        -:13667:
        -:13668:            std::string getDescription() const override {
        -:13669:                return getDescriptionImpl( Detail::has_description<T>{} );
        -:13670:            }
        -:13671:        };
        -:13672:
        -:13673:    public:
        -:13674:        ListenerRegistrar(StringRef listenerName) {
        -:13675:            registerListenerImpl( Detail::make_unique<TypedListenerFactory>(listenerName) );
        -:13676:        }
        -:13677:    };
        -:13678:}
        -:13679:
        -:13680:#if !defined(CATCH_CONFIG_DISABLE)
        -:13681:
        -:13682:#    define CATCH_REGISTER_REPORTER( name, reporterType )                      \
        -:13683:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \
        -:13684:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \
        -:13685:        namespace {                                                            \
        -:13686:            Catch::ReporterRegistrar<reporterType> INTERNAL_CATCH_UNIQUE_NAME( \
        -:13687:                catch_internal_RegistrarFor )( name );                         \
        -:13688:        }                                                                      \
        -:13689:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:13690:
        -:13691:#    define CATCH_REGISTER_LISTENER( listenerType )                            \
        -:13692:        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                              \
        -:13693:        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                               \
        -:13694:        namespace {                                                            \
        -:13695:            Catch::ListenerRegistrar<listenerType> INTERNAL_CATCH_UNIQUE_NAME( \
        -:13696:                catch_internal_RegistrarFor )( #listenerType##_catch_sr );     \
        -:13697:        }                                                                      \
        -:13698:        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
        -:13699:
        -:13700:#else // CATCH_CONFIG_DISABLE
        -:13701:
        -:13702:#define CATCH_REGISTER_REPORTER(name, reporterType)
        -:13703:#define CATCH_REGISTER_LISTENER(listenerType)
        -:13704:
        -:13705:#endif // CATCH_CONFIG_DISABLE
        -:13706:
        -:13707:#endif // CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -:13708:
        -:13709:
        -:13710:#ifndef CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:13711:#define CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:13712:
        -:13713:
        -:13714:
        -:13715:namespace Catch {
        -:13716:
        -:13717:    class SonarQubeReporter final : public CumulativeReporterBase {
        -:13718:    public:
        -:13719:        SonarQubeReporter(ReporterConfig&& config)
        -:13720:        : CumulativeReporterBase(CATCH_MOVE(config))
        -:13721:        , xml(m_stream) {
        -:13722:            m_preferences.shouldRedirectStdOut = true;
        -:13723:            m_preferences.shouldReportAllAssertions = true;
        -:13724:            m_shouldStoreSuccesfulAssertions = false;
        -:13725:        }
        -:13726:
        -:13727:        static std::string getDescription() {
        -:13728:            using namespace std::string_literals;
        -:13729:            return "Reports test results in the Generic Test Data SonarQube XML format"s;
        -:13730:        }
        -:13731:
        -:13732:        void testRunStarting( TestRunInfo const& testRunInfo ) override;
        -:13733:
        -:13734:        void testRunEndedCumulative() override {
        -:13735:            writeRun( *m_testRun );
        -:13736:            xml.endElement();
        -:13737:        }
        -:13738:
        -:13739:        void writeRun( TestRunNode const& runNode );
        -:13740:
        -:13741:        void writeTestFile(StringRef filename, std::vector<TestCaseNode const*> const& testCaseNodes);
        -:13742:
        -:13743:        void writeTestCase(TestCaseNode const& testCaseNode);
        -:13744:
        -:13745:        void writeSection(std::string const& rootName, SectionNode const& sectionNode, bool okToFail);
        -:13746:
        -:13747:        void writeAssertions(SectionNode const& sectionNode, bool okToFail);
        -:13748:
        -:13749:        void writeAssertion(AssertionStats const& stats, bool okToFail);
        -:13750:
        -:13751:    private:
        -:13752:        XmlWriter xml;
        -:13753:    };
        -:13754:
        -:13755:
        -:13756:} // end namespace Catch
        -:13757:
        -:13758:#endif // CATCH_REPORTER_SONARQUBE_HPP_INCLUDED
        -:13759:
        -:13760:
        -:13761:#ifndef CATCH_REPORTER_TAP_HPP_INCLUDED
        -:13762:#define CATCH_REPORTER_TAP_HPP_INCLUDED
        -:13763:
        -:13764:
        -:13765:namespace Catch {
        -:13766:
        -:13767:    class TAPReporter final : public StreamingReporterBase {
        -:13768:    public:
        -:13769:        TAPReporter( ReporterConfig&& config ):
        -:13770:            StreamingReporterBase( CATCH_MOVE(config) ) {
        -:13771:            m_preferences.shouldReportAllAssertions = true;
        -:13772:        }
        -:13773:
        -:13774:        static std::string getDescription() {
        -:13775:            using namespace std::string_literals;
        -:13776:            return "Reports test results in TAP format, suitable for test harnesses"s;
        -:13777:        }
        -:13778:
        -:13779:        void testRunStarting( TestRunInfo const& testInfo ) override;
        -:13780:
        -:13781:        void noMatchingTestCases( StringRef unmatchedSpec ) override;
        -:13782:
        -:13783:        void assertionEnded(AssertionStats const& _assertionStats) override;
        -:13784:
        -:13785:        void testRunEnded(TestRunStats const& _testRunStats) override;
        -:13786:
        -:13787:    private:
        -:13788:        std::size_t counter = 0;
        -:13789:    };
        -:13790:
        -:13791:} // end namespace Catch
        -:13792:
        -:13793:#endif // CATCH_REPORTER_TAP_HPP_INCLUDED
        -:13794:
        -:13795:
        -:13796:#ifndef CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:13797:#define CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:13798:
        -:13799:
        -:13800:#include <cstring>
        -:13801:
        -:13802:#ifdef __clang__
        -:13803:#   pragma clang diagnostic push
        -:13804:#   pragma clang diagnostic ignored "-Wpadded"
        -:13805:#endif
        -:13806:
        -:13807:namespace Catch {
        -:13808:
        -:13809:    class TeamCityReporter final : public StreamingReporterBase {
        -:13810:    public:
        -:13811:        TeamCityReporter( ReporterConfig&& _config )
        -:13812:        :   StreamingReporterBase( CATCH_MOVE(_config) )
        -:13813:        {
        -:13814:            m_preferences.shouldRedirectStdOut = true;
        -:13815:        }
        -:13816:
        -:13817:        ~TeamCityReporter() override;
        -:13818:
        -:13819:        static std::string getDescription() {
        -:13820:            using namespace std::string_literals;
        -:13821:            return "Reports test results as TeamCity service messages"s;
        -:13822:        }
        -:13823:
        -:13824:        void testRunStarting( TestRunInfo const& runInfo ) override;
        -:13825:        void testRunEnded( TestRunStats const& runStats ) override;
        -:13826:
        -:13827:
        -:13828:        void assertionEnded(AssertionStats const& assertionStats) override;
        -:13829:
        -:13830:        void sectionStarting(SectionInfo const& sectionInfo) override {
        -:13831:            m_headerPrintedForThisSection = false;
        -:13832:            StreamingReporterBase::sectionStarting( sectionInfo );
        -:13833:        }
        -:13834:
        -:13835:        void testCaseStarting(TestCaseInfo const& testInfo) override;
        -:13836:
        -:13837:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:13838:
        -:13839:    private:
        -:13840:        void printSectionHeader(std::ostream& os);
        -:13841:
        -:13842:        bool m_headerPrintedForThisSection = false;
        -:13843:        Timer m_testTimer;
        -:13844:    };
        -:13845:
        -:13846:} // end namespace Catch
        -:13847:
        -:13848:#ifdef __clang__
        -:13849:#   pragma clang diagnostic pop
        -:13850:#endif
        -:13851:
        -:13852:#endif // CATCH_REPORTER_TEAMCITY_HPP_INCLUDED
        -:13853:
        -:13854:
        -:13855:#ifndef CATCH_REPORTER_XML_HPP_INCLUDED
        -:13856:#define CATCH_REPORTER_XML_HPP_INCLUDED
        -:13857:
        -:13858:
        -:13859:
        -:13860:
        -:13861:namespace Catch {
        -:13862:    class XmlReporter : public StreamingReporterBase {
        -:13863:    public:
        -:13864:        XmlReporter(ReporterConfig&& _config);
        -:13865:
        -:13866:        ~XmlReporter() override;
        -:13867:
        -:13868:        static std::string getDescription();
        -:13869:
        -:13870:        virtual std::string getStylesheetRef() const;
        -:13871:
        -:13872:        void writeSourceInfo(SourceLineInfo const& sourceInfo);
        -:13873:
        -:13874:    public: // StreamingReporterBase
        -:13875:
        -:13876:        void testRunStarting(TestRunInfo const& testInfo) override;
        -:13877:
        -:13878:        void testCaseStarting(TestCaseInfo const& testInfo) override;
        -:13879:
        -:13880:        void sectionStarting(SectionInfo const& sectionInfo) override;
        -:13881:
        -:13882:        void assertionStarting(AssertionInfo const&) override;
        -:13883:
        -:13884:        void assertionEnded(AssertionStats const& assertionStats) override;
        -:13885:
        -:13886:        void sectionEnded(SectionStats const& sectionStats) override;
        -:13887:
        -:13888:        void testCaseEnded(TestCaseStats const& testCaseStats) override;
        -:13889:
        -:13890:        void testRunEnded(TestRunStats const& testRunStats) override;
        -:13891:
        -:13892:        void benchmarkPreparing( StringRef name ) override;
        -:13893:        void benchmarkStarting(BenchmarkInfo const&) override;
        -:13894:        void benchmarkEnded(BenchmarkStats<> const&) override;
        -:13895:        void benchmarkFailed( StringRef error ) override;
        -:13896:
        -:13897:        void listReporters(std::vector<ReporterDescription> const& descriptions) override;
        -:13898:        void listListeners(std::vector<ListenerDescription> const& descriptions) override;
        -:13899:        void listTests(std::vector<TestCaseHandle> const& tests) override;
        -:13900:        void listTags(std::vector<TagInfo> const& tags) override;
        -:13901:
        -:13902:    private:
        -:13903:        Timer m_testCaseTimer;
        -:13904:        XmlWriter m_xml;
        -:13905:        int m_sectionDepth = 0;
        -:13906:    };
        -:13907:
        -:13908:} // end namespace Catch
        -:13909:
        -:13910:#endif // CATCH_REPORTER_XML_HPP_INCLUDED
        -:13911:
        -:13912:#endif // CATCH_REPORTERS_ALL_HPP_INCLUDED
        -:13913:
        -:13914:#endif // CATCH_ALL_HPP_INCLUDED
        -:13915:#endif // CATCH_AMALGAMATED_HPP_INCLUDED
